/*! For license information please see main.47943505.js.LICENSE.txt */
(()=>{var e={4:(e,t,n)=>{"use strict";var a=n(853),r=n(43),o=n(950);function s(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function i(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function l(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function c(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function u(e){if(l(e)!==e)throw Error(s(188))}function h(e){var t=e.tag;if(5===t||26===t||27===t||6===t)return e;for(e=e.child;null!==e;){if(null!==(t=h(e)))return t;e=e.sibling}return null}var d=Object.assign,p=Symbol.for("react.element"),f=Symbol.for("react.transitional.element"),g=Symbol.for("react.portal"),m=Symbol.for("react.fragment"),b=Symbol.for("react.strict_mode"),y=Symbol.for("react.profiler"),v=Symbol.for("react.provider"),x=Symbol.for("react.consumer"),w=Symbol.for("react.context"),k=Symbol.for("react.forward_ref"),S=Symbol.for("react.suspense"),I=Symbol.for("react.suspense_list"),C=Symbol.for("react.memo"),N=Symbol.for("react.lazy");Symbol.for("react.scope");var E=Symbol.for("react.activity");Symbol.for("react.legacy_hidden"),Symbol.for("react.tracing_marker");var T=Symbol.for("react.memo_cache_sentinel");Symbol.for("react.view_transition");var R=Symbol.iterator;function A(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=R&&e[R]||e["@@iterator"])?e:null}var F=Symbol.for("react.client.reference");function D(e){if(null==e)return null;if("function"===typeof e)return e.$$typeof===F?null:e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case m:return"Fragment";case y:return"Profiler";case b:return"StrictMode";case S:return"Suspense";case I:return"SuspenseList";case E:return"Activity"}if("object"===typeof e)switch(e.$$typeof){case g:return"Portal";case w:return(e.displayName||"Context")+".Provider";case x:return(e._context.displayName||"Context")+".Consumer";case k:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case C:return null!==(t=e.displayName||null)?t:D(e.type)||"Memo";case N:t=e._payload,e=e._init;try{return D(e(t))}catch(n){}}return null}var _=Array.isArray,O=r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,L=o.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,z={pending:!1,data:null,method:null,action:null},M=[],P=-1;function B(e){return{current:e}}function W(e){0>P||(e.current=M[P],M[P]=null,P--)}function U(e,t){P++,M[P]=e.current,e.current=t}var V=B(null),G=B(null),j=B(null),H=B(null);function K(e,t){switch(U(j,t),U(G,e),U(V,null),t.nodeType){case 9:case 11:e=(e=t.documentElement)&&(e=e.namespaceURI)?rh(e):0;break;default:if(e=t.tagName,t=t.namespaceURI)e=oh(t=rh(t),e);else switch(e){case"svg":e=1;break;case"math":e=2;break;default:e=0}}W(V),U(V,e)}function q(){W(V),W(G),W(j)}function X(e){null!==e.memoizedState&&U(H,e);var t=V.current,n=oh(t,e.type);t!==n&&(U(G,e),U(V,n))}function Y(e){G.current===e&&(W(V),W(G)),H.current===e&&(W(H),Xh._currentValue=z)}var J=Object.prototype.hasOwnProperty,$=a.unstable_scheduleCallback,Q=a.unstable_cancelCallback,Z=a.unstable_shouldYield,ee=a.unstable_requestPaint,te=a.unstable_now,ne=a.unstable_getCurrentPriorityLevel,ae=a.unstable_ImmediatePriority,re=a.unstable_UserBlockingPriority,oe=a.unstable_NormalPriority,se=a.unstable_LowPriority,ie=a.unstable_IdlePriority,le=a.log,ce=a.unstable_setDisableYieldValue,ue=null,he=null;function de(e){if("function"===typeof le&&ce(e),he&&"function"===typeof he.setStrictMode)try{he.setStrictMode(ue,e)}catch(t){}}var pe=Math.clz32?Math.clz32:function(e){return 0===(e>>>=0)?32:31-(fe(e)/ge|0)|0},fe=Math.log,ge=Math.LN2;var me=256,be=4194304;function ye(e){var t=42&e;if(0!==t)return t;switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194048&e;case 4194304:case 8388608:case 16777216:case 33554432:return 62914560&e;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return e}}function ve(e,t,n){var a=e.pendingLanes;if(0===a)return 0;var r=0,o=e.suspendedLanes,s=e.pingedLanes;e=e.warmLanes;var i=134217727&a;return 0!==i?0!==(a=i&~o)?r=ye(a):0!==(s&=i)?r=ye(s):n||0!==(n=i&~e)&&(r=ye(n)):0!==(i=a&~o)?r=ye(i):0!==s?r=ye(s):n||0!==(n=a&~e)&&(r=ye(n)),0===r?0:0!==t&&t!==r&&0===(t&o)&&((o=r&-r)>=(n=t&-t)||32===o&&0!==(4194048&n))?t:r}function xe(e,t){return 0===(e.pendingLanes&~(e.suspendedLanes&~e.pingedLanes)&t)}function we(e,t){switch(e){case 1:case 2:case 4:case 8:case 64:return t+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ke(){var e=me;return 0===(4194048&(me<<=1))&&(me=256),e}function Se(){var e=be;return 0===(62914560&(be<<=1))&&(be=4194304),e}function Ie(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Ce(e,t){e.pendingLanes|=t,268435456!==t&&(e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0)}function Ne(e,t,n){e.pendingLanes|=t,e.suspendedLanes&=~t;var a=31-pe(t);e.entangledLanes|=t,e.entanglements[a]=1073741824|e.entanglements[a]|4194090&n}function Ee(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var a=31-pe(n),r=1<<a;r&t|e[a]&t&&(e[a]|=t),n&=~r}}function Te(e){switch(e){case 2:e=1;break;case 8:e=4;break;case 32:e=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:e=128;break;case 268435456:e=134217728;break;default:e=0}return e}function Re(e){return 2<(e&=-e)?8<e?0!==(134217727&e)?32:268435456:8:2}function Ae(){var e=L.p;return 0!==e?e:void 0===(e=window.event)?32:cd(e.type)}var Fe=Math.random().toString(36).slice(2),De="__reactFiber$"+Fe,_e="__reactProps$"+Fe,Oe="__reactContainer$"+Fe,Le="__reactEvents$"+Fe,ze="__reactListeners$"+Fe,Me="__reactHandles$"+Fe,Pe="__reactResources$"+Fe,Be="__reactMarker$"+Fe;function We(e){delete e[De],delete e[_e],delete e[Le],delete e[ze],delete e[Me]}function Ue(e){var t=e[De];if(t)return t;for(var n=e.parentNode;n;){if(t=n[Oe]||n[De]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=vh(e);null!==e;){if(n=e[De])return n;e=vh(e)}return t}n=(e=n).parentNode}return null}function Ve(e){if(e=e[De]||e[Oe]){var t=e.tag;if(5===t||6===t||13===t||26===t||27===t||3===t)return e}return null}function Ge(e){var t=e.tag;if(5===t||26===t||27===t||6===t)return e.stateNode;throw Error(s(33))}function je(e){var t=e[Pe];return t||(t=e[Pe]={hoistableStyles:new Map,hoistableScripts:new Map}),t}function He(e){e[Be]=!0}var Ke=new Set,qe={};function Xe(e,t){Ye(e,t),Ye(e+"Capture",t)}function Ye(e,t){for(qe[e]=t,e=0;e<t.length;e++)Ke.add(t[e])}var Je,$e,Qe=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Ze={},et={};function tt(e,t,n){if(r=t,J.call(et,r)||!J.call(Ze,r)&&(Qe.test(r)?et[r]=!0:(Ze[r]=!0,0)))if(null===n)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":return void e.removeAttribute(t);case"boolean":var a=t.toLowerCase().slice(0,5);if("data-"!==a&&"aria-"!==a)return void e.removeAttribute(t)}e.setAttribute(t,""+n)}var r}function nt(e,t,n){if(null===n)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":case"boolean":return void e.removeAttribute(t)}e.setAttribute(t,""+n)}}function at(e,t,n,a){if(null===a)e.removeAttribute(n);else{switch(typeof a){case"undefined":case"function":case"symbol":case"boolean":return void e.removeAttribute(n)}e.setAttributeNS(t,n,""+a)}}function rt(e){if(void 0===Je)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);Je=t&&t[1]||"",$e=-1<n.stack.indexOf("\n    at")?" (<anonymous>)":-1<n.stack.indexOf("@")?"@unknown:0:0":""}return"\n"+Je+e+$e}var ot=!1;function st(e,t){if(!e||ot)return"";ot=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var a={DetermineComponentFrameRoot:function(){try{if(t){var n=function(){throw Error()};if(Object.defineProperty(n.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(n,[])}catch(r){var a=r}Reflect.construct(e,[],n)}else{try{n.call()}catch(o){a=o}e.call(n.prototype)}}else{try{throw Error()}catch(s){a=s}(n=e())&&"function"===typeof n.catch&&n.catch((function(){}))}}catch(i){if(i&&a&&"string"===typeof i.stack)return[i.stack,a.stack]}return[null,null]}};a.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var r=Object.getOwnPropertyDescriptor(a.DetermineComponentFrameRoot,"name");r&&r.configurable&&Object.defineProperty(a.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var o=a.DetermineComponentFrameRoot(),s=o[0],i=o[1];if(s&&i){var l=s.split("\n"),c=i.split("\n");for(r=a=0;a<l.length&&!l[a].includes("DetermineComponentFrameRoot");)a++;for(;r<c.length&&!c[r].includes("DetermineComponentFrameRoot");)r++;if(a===l.length||r===c.length)for(a=l.length-1,r=c.length-1;1<=a&&0<=r&&l[a]!==c[r];)r--;for(;1<=a&&0<=r;a--,r--)if(l[a]!==c[r]){if(1!==a||1!==r)do{if(a--,0>--r||l[a]!==c[r]){var u="\n"+l[a].replace(" at new "," at ");return e.displayName&&u.includes("<anonymous>")&&(u=u.replace("<anonymous>",e.displayName)),u}}while(1<=a&&0<=r);break}}}finally{ot=!1,Error.prepareStackTrace=n}return(n=e?e.displayName||e.name:"")?rt(n):""}function it(e){switch(e.tag){case 26:case 27:case 5:return rt(e.type);case 16:return rt("Lazy");case 13:return rt("Suspense");case 19:return rt("SuspenseList");case 0:case 15:return st(e.type,!1);case 11:return st(e.type.render,!1);case 1:return st(e.type,!0);case 31:return rt("Activity");default:return""}}function lt(e){try{var t="";do{t+=it(e),e=e.return}while(e);return t}catch(n){return"\nError generating stack: "+n.message+"\n"+n.stack}}function ct(e){switch(typeof e){case"bigint":case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function ut(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function ht(e){e._valueTracker||(e._valueTracker=function(e){var t=ut(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),a=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var r=n.get,o=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return r.call(this)},set:function(e){a=""+e,o.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return a},setValue:function(e){a=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function dt(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),a="";return e&&(a=ut(e)?e.checked?"true":"false":e.value),(e=a)!==n&&(t.setValue(e),!0)}function pt(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}var ft=/[\n"\\]/g;function gt(e){return e.replace(ft,(function(e){return"\\"+e.charCodeAt(0).toString(16)+" "}))}function mt(e,t,n,a,r,o,s,i){e.name="",null!=s&&"function"!==typeof s&&"symbol"!==typeof s&&"boolean"!==typeof s?e.type=s:e.removeAttribute("type"),null!=t?"number"===s?(0===t&&""===e.value||e.value!=t)&&(e.value=""+ct(t)):e.value!==""+ct(t)&&(e.value=""+ct(t)):"submit"!==s&&"reset"!==s||e.removeAttribute("value"),null!=t?yt(e,s,ct(t)):null!=n?yt(e,s,ct(n)):null!=a&&e.removeAttribute("value"),null==r&&null!=o&&(e.defaultChecked=!!o),null!=r&&(e.checked=r&&"function"!==typeof r&&"symbol"!==typeof r),null!=i&&"function"!==typeof i&&"symbol"!==typeof i&&"boolean"!==typeof i?e.name=""+ct(i):e.removeAttribute("name")}function bt(e,t,n,a,r,o,s,i){if(null!=o&&"function"!==typeof o&&"symbol"!==typeof o&&"boolean"!==typeof o&&(e.type=o),null!=t||null!=n){if(!("submit"!==o&&"reset"!==o||void 0!==t&&null!==t))return;n=null!=n?""+ct(n):"",t=null!=t?""+ct(t):n,i||t===e.value||(e.value=t),e.defaultValue=t}a="function"!==typeof(a=null!=a?a:r)&&"symbol"!==typeof a&&!!a,e.checked=i?e.checked:!!a,e.defaultChecked=!!a,null!=s&&"function"!==typeof s&&"symbol"!==typeof s&&"boolean"!==typeof s&&(e.name=s)}function yt(e,t,n){"number"===t&&pt(e.ownerDocument)===e||e.defaultValue===""+n||(e.defaultValue=""+n)}function vt(e,t,n,a){if(e=e.options,t){t={};for(var r=0;r<n.length;r++)t["$"+n[r]]=!0;for(n=0;n<e.length;n++)r=t.hasOwnProperty("$"+e[n].value),e[n].selected!==r&&(e[n].selected=r),r&&a&&(e[n].defaultSelected=!0)}else{for(n=""+ct(n),t=null,r=0;r<e.length;r++){if(e[r].value===n)return e[r].selected=!0,void(a&&(e[r].defaultSelected=!0));null!==t||e[r].disabled||(t=e[r])}null!==t&&(t.selected=!0)}}function xt(e,t,n){null==t||((t=""+ct(t))!==e.value&&(e.value=t),null!=n)?e.defaultValue=null!=n?""+ct(n):"":e.defaultValue!==t&&(e.defaultValue=t)}function wt(e,t,n,a){if(null==t){if(null!=a){if(null!=n)throw Error(s(92));if(_(a)){if(1<a.length)throw Error(s(93));a=a[0]}n=a}null==n&&(n=""),t=n}n=ct(t),e.defaultValue=n,(a=e.textContent)===n&&""!==a&&null!==a&&(e.value=a)}function kt(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var St=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function It(e,t,n){var a=0===t.indexOf("--");null==n||"boolean"===typeof n||""===n?a?e.setProperty(t,""):"float"===t?e.cssFloat="":e[t]="":a?e.setProperty(t,n):"number"!==typeof n||0===n||St.has(t)?"float"===t?e.cssFloat=n:e[t]=(""+n).trim():e[t]=n+"px"}function Ct(e,t,n){if(null!=t&&"object"!==typeof t)throw Error(s(62));if(e=e.style,null!=n){for(var a in n)!n.hasOwnProperty(a)||null!=t&&t.hasOwnProperty(a)||(0===a.indexOf("--")?e.setProperty(a,""):"float"===a?e.cssFloat="":e[a]="");for(var r in t)a=t[r],t.hasOwnProperty(r)&&n[r]!==a&&It(e,r,a)}else for(var o in t)t.hasOwnProperty(o)&&It(e,o,t[o])}function Nt(e){if(-1===e.indexOf("-"))return!1;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Et=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Tt=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Rt(e){return Tt.test(""+e)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":e}var At=null;function Ft(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var Dt=null,_t=null;function Ot(e){var t=Ve(e);if(t&&(e=t.stateNode)){var n=e[_e]||null;e:switch(e=t.stateNode,t.type){case"input":if(mt(e,n.value,n.defaultValue,n.defaultValue,n.checked,n.defaultChecked,n.type,n.name),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll('input[name="'+gt(""+t)+'"][type="radio"]'),t=0;t<n.length;t++){var a=n[t];if(a!==e&&a.form===e.form){var r=a[_e]||null;if(!r)throw Error(s(90));mt(a,r.value,r.defaultValue,r.defaultValue,r.checked,r.defaultChecked,r.type,r.name)}}for(t=0;t<n.length;t++)(a=n[t]).form===e.form&&dt(a)}break e;case"textarea":xt(e,n.value,n.defaultValue);break e;case"select":null!=(t=n.value)&&vt(e,!!n.multiple,t,!1)}}}var Lt=!1;function zt(e,t,n){if(Lt)return e(t,n);Lt=!0;try{return e(t)}finally{if(Lt=!1,(null!==Dt||null!==_t)&&(Uc(),Dt&&(t=Dt,e=_t,_t=Dt=null,Ot(t),e)))for(t=0;t<e.length;t++)Ot(e[t])}}function Mt(e,t){var n=e.stateNode;if(null===n)return null;var a=n[_e]||null;if(null===a)return null;n=a[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(a=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!a;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(s(231,t,typeof n));return n}var Pt=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),Bt=!1;if(Pt)try{var Wt={};Object.defineProperty(Wt,"passive",{get:function(){Bt=!0}}),window.addEventListener("test",Wt,Wt),window.removeEventListener("test",Wt,Wt)}catch(_d){Bt=!1}var Ut=null,Vt=null,Gt=null;function jt(){if(Gt)return Gt;var e,t,n=Vt,a=n.length,r="value"in Ut?Ut.value:Ut.textContent,o=r.length;for(e=0;e<a&&n[e]===r[e];e++);var s=a-e;for(t=1;t<=s&&n[a-t]===r[o-t];t++);return Gt=r.slice(e,1<t?1-t:void 0)}function Ht(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function Kt(){return!0}function qt(){return!1}function Xt(e){function t(t,n,a,r,o){for(var s in this._reactName=t,this._targetInst=a,this.type=n,this.nativeEvent=r,this.target=o,this.currentTarget=null,e)e.hasOwnProperty(s)&&(t=e[s],this[s]=t?t(r):r[s]);return this.isDefaultPrevented=(null!=r.defaultPrevented?r.defaultPrevented:!1===r.returnValue)?Kt:qt,this.isPropagationStopped=qt,this}return d(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=Kt)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=Kt)},persist:function(){},isPersistent:Kt}),t}var Yt,Jt,$t,Qt={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Zt=Xt(Qt),en=d({},Qt,{view:0,detail:0}),tn=Xt(en),nn=d({},en,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:fn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==$t&&($t&&"mousemove"===e.type?(Yt=e.screenX-$t.screenX,Jt=e.screenY-$t.screenY):Jt=Yt=0,$t=e),Yt)},movementY:function(e){return"movementY"in e?e.movementY:Jt}}),an=Xt(nn),rn=Xt(d({},nn,{dataTransfer:0})),on=Xt(d({},en,{relatedTarget:0})),sn=Xt(d({},Qt,{animationName:0,elapsedTime:0,pseudoElement:0})),ln=Xt(d({},Qt,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}})),cn=Xt(d({},Qt,{data:0})),un={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},hn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},dn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function pn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=dn[e])&&!!t[e]}function fn(){return pn}var gn=Xt(d({},en,{key:function(e){if(e.key){var t=un[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=Ht(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?hn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:fn,charCode:function(e){return"keypress"===e.type?Ht(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?Ht(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}})),mn=Xt(d({},nn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),bn=Xt(d({},en,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:fn})),yn=Xt(d({},Qt,{propertyName:0,elapsedTime:0,pseudoElement:0})),vn=Xt(d({},nn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0})),xn=Xt(d({},Qt,{newState:0,oldState:0})),wn=[9,13,27,32],kn=Pt&&"CompositionEvent"in window,Sn=null;Pt&&"documentMode"in document&&(Sn=document.documentMode);var In=Pt&&"TextEvent"in window&&!Sn,Cn=Pt&&(!kn||Sn&&8<Sn&&11>=Sn),Nn=String.fromCharCode(32),En=!1;function Tn(e,t){switch(e){case"keyup":return-1!==wn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Rn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var An=!1;var Fn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Dn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Fn[e.type]:"textarea"===t}function _n(e,t,n,a){Dt?_t?_t.push(a):_t=[a]:Dt=a,0<(t=ju(t,"onChange")).length&&(n=new Zt("onChange","change",null,n,a),e.push({event:n,listeners:t}))}var On=null,Ln=null;function zn(e){zu(e,0)}function Mn(e){if(dt(Ge(e)))return e}function Pn(e,t){if("change"===e)return t}var Bn=!1;if(Pt){var Wn;if(Pt){var Un="oninput"in document;if(!Un){var Vn=document.createElement("div");Vn.setAttribute("oninput","return;"),Un="function"===typeof Vn.oninput}Wn=Un}else Wn=!1;Bn=Wn&&(!document.documentMode||9<document.documentMode)}function Gn(){On&&(On.detachEvent("onpropertychange",jn),Ln=On=null)}function jn(e){if("value"===e.propertyName&&Mn(Ln)){var t=[];_n(t,Ln,e,Ft(e)),zt(zn,t)}}function Hn(e,t,n){"focusin"===e?(Gn(),Ln=n,(On=t).attachEvent("onpropertychange",jn)):"focusout"===e&&Gn()}function Kn(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Mn(Ln)}function qn(e,t){if("click"===e)return Mn(t)}function Xn(e,t){if("input"===e||"change"===e)return Mn(t)}var Yn="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function Jn(e,t){if(Yn(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),a=Object.keys(t);if(n.length!==a.length)return!1;for(a=0;a<n.length;a++){var r=n[a];if(!J.call(t,r)||!Yn(e[r],t[r]))return!1}return!0}function $n(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function Qn(e,t){var n,a=$n(e);for(e=0;a;){if(3===a.nodeType){if(n=e+a.textContent.length,e<=t&&n>=t)return{node:a,offset:t-e};e=n}e:{for(;a;){if(a.nextSibling){a=a.nextSibling;break e}a=a.parentNode}a=void 0}a=$n(a)}}function Zn(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?Zn(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function ea(e){for(var t=pt((e=null!=e&&null!=e.ownerDocument&&null!=e.ownerDocument.defaultView?e.ownerDocument.defaultView:window).document);t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(a){n=!1}if(!n)break;t=pt((e=t.contentWindow).document)}return t}function ta(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}var na=Pt&&"documentMode"in document&&11>=document.documentMode,aa=null,ra=null,oa=null,sa=!1;function ia(e,t,n){var a=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;sa||null==aa||aa!==pt(a)||("selectionStart"in(a=aa)&&ta(a)?a={start:a.selectionStart,end:a.selectionEnd}:a={anchorNode:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset},oa&&Jn(oa,a)||(oa=a,0<(a=ju(ra,"onSelect")).length&&(t=new Zt("onSelect","select",null,t,n),e.push({event:t,listeners:a}),t.target=aa)))}function la(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var ca={animationend:la("Animation","AnimationEnd"),animationiteration:la("Animation","AnimationIteration"),animationstart:la("Animation","AnimationStart"),transitionrun:la("Transition","TransitionRun"),transitionstart:la("Transition","TransitionStart"),transitioncancel:la("Transition","TransitionCancel"),transitionend:la("Transition","TransitionEnd")},ua={},ha={};function da(e){if(ua[e])return ua[e];if(!ca[e])return e;var t,n=ca[e];for(t in n)if(n.hasOwnProperty(t)&&t in ha)return ua[e]=n[t];return e}Pt&&(ha=document.createElement("div").style,"AnimationEvent"in window||(delete ca.animationend.animation,delete ca.animationiteration.animation,delete ca.animationstart.animation),"TransitionEvent"in window||delete ca.transitionend.transition);var pa=da("animationend"),fa=da("animationiteration"),ga=da("animationstart"),ma=da("transitionrun"),ba=da("transitionstart"),ya=da("transitioncancel"),va=da("transitionend"),xa=new Map,wa="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function ka(e,t){xa.set(e,t),Xe(t,[e])}wa.push("scrollEnd");var Sa=new WeakMap;function Ia(e,t){if("object"===typeof e&&null!==e){var n=Sa.get(e);return void 0!==n?n:(t={value:e,source:t,stack:lt(t)},Sa.set(e,t),t)}return{value:e,source:t,stack:lt(t)}}var Ca=[],Na=0,Ea=0;function Ta(){for(var e=Na,t=Ea=Na=0;t<e;){var n=Ca[t];Ca[t++]=null;var a=Ca[t];Ca[t++]=null;var r=Ca[t];Ca[t++]=null;var o=Ca[t];if(Ca[t++]=null,null!==a&&null!==r){var s=a.pending;null===s?r.next=r:(r.next=s.next,s.next=r),a.pending=r}0!==o&&Da(n,r,o)}}function Ra(e,t,n,a){Ca[Na++]=e,Ca[Na++]=t,Ca[Na++]=n,Ca[Na++]=a,Ea|=a,e.lanes|=a,null!==(e=e.alternate)&&(e.lanes|=a)}function Aa(e,t,n,a){return Ra(e,t,n,a),_a(e)}function Fa(e,t){return Ra(e,null,null,t),_a(e)}function Da(e,t,n){e.lanes|=n;var a=e.alternate;null!==a&&(a.lanes|=n);for(var r=!1,o=e.return;null!==o;)o.childLanes|=n,null!==(a=o.alternate)&&(a.childLanes|=n),22===o.tag&&(null===(e=o.stateNode)||1&e._visibility||(r=!0)),e=o,o=o.return;return 3===e.tag?(o=e.stateNode,r&&null!==t&&(r=31-pe(n),null===(a=(e=o.hiddenUpdates)[r])?e[r]=[t]:a.push(t),t.lane=536870912|n),o):null}function _a(e){if(50<Dc)throw Dc=0,_c=null,Error(s(185));for(var t=e.return;null!==t;)t=(e=t).return;return 3===e.tag?e.stateNode:null}var Oa={};function La(e,t,n,a){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function za(e,t,n,a){return new La(e,t,n,a)}function Ma(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Pa(e,t){var n=e.alternate;return null===n?((n=za(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=65011712&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n.refCleanup=e.refCleanup,n}function Ba(e,t){e.flags&=65011714;var n=e.alternate;return null===n?(e.childLanes=0,e.lanes=t,e.child=null,e.subtreeFlags=0,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.stateNode=null):(e.childLanes=n.childLanes,e.lanes=n.lanes,e.child=n.child,e.subtreeFlags=0,e.deletions=null,e.memoizedProps=n.memoizedProps,e.memoizedState=n.memoizedState,e.updateQueue=n.updateQueue,e.type=n.type,t=n.dependencies,e.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext}),e}function Wa(e,t,n,a,r,o){var i=0;if(a=e,"function"===typeof e)Ma(e)&&(i=1);else if("string"===typeof e)i=function(e,t,n){if(1===n||null!=t.itemProp)return!1;switch(e){case"meta":case"title":return!0;case"style":if("string"!==typeof t.precedence||"string"!==typeof t.href||""===t.href)break;return!0;case"link":if("string"!==typeof t.rel||"string"!==typeof t.href||""===t.href||t.onLoad||t.onError)break;return"stylesheet"!==t.rel||(e=t.disabled,"string"===typeof t.precedence&&null==e);case"script":if(t.async&&"function"!==typeof t.async&&"symbol"!==typeof t.async&&!t.onLoad&&!t.onError&&t.src&&"string"===typeof t.src)return!0}return!1}(e,n,V.current)?26:"html"===e||"head"===e||"body"===e?27:5;else e:switch(e){case E:return(e=za(31,n,t,r)).elementType=E,e.lanes=o,e;case m:return Ua(n.children,r,o,t);case b:i=8,r|=24;break;case y:return(e=za(12,n,t,2|r)).elementType=y,e.lanes=o,e;case S:return(e=za(13,n,t,r)).elementType=S,e.lanes=o,e;case I:return(e=za(19,n,t,r)).elementType=I,e.lanes=o,e;default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case v:case w:i=10;break e;case x:i=9;break e;case k:i=11;break e;case C:i=14;break e;case N:i=16,a=null;break e}i=29,n=Error(s(130,null===e?"null":typeof e,"")),a=null}return(t=za(i,n,t,r)).elementType=e,t.type=a,t.lanes=o,t}function Ua(e,t,n,a){return(e=za(7,e,a,t)).lanes=n,e}function Va(e,t,n){return(e=za(6,e,null,t)).lanes=n,e}function Ga(e,t,n){return(t=za(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}var ja=[],Ha=0,Ka=null,qa=0,Xa=[],Ya=0,Ja=null,$a=1,Qa="";function Za(e,t){ja[Ha++]=qa,ja[Ha++]=Ka,Ka=e,qa=t}function er(e,t,n){Xa[Ya++]=$a,Xa[Ya++]=Qa,Xa[Ya++]=Ja,Ja=e;var a=$a;e=Qa;var r=32-pe(a)-1;a&=~(1<<r),n+=1;var o=32-pe(t)+r;if(30<o){var s=r-r%5;o=(a&(1<<s)-1).toString(32),a>>=s,r-=s,$a=1<<32-pe(t)+r|n<<r|a,Qa=o+e}else $a=1<<o|n<<r|a,Qa=e}function tr(e){null!==e.return&&(Za(e,1),er(e,1,0))}function nr(e){for(;e===Ka;)Ka=ja[--Ha],ja[Ha]=null,qa=ja[--Ha],ja[Ha]=null;for(;e===Ja;)Ja=Xa[--Ya],Xa[Ya]=null,Qa=Xa[--Ya],Xa[Ya]=null,$a=Xa[--Ya],Xa[Ya]=null}var ar=null,rr=null,or=!1,sr=null,ir=!1,lr=Error(s(519));function cr(e){throw gr(Ia(Error(s(418,"")),e)),lr}function ur(e){var t=e.stateNode,n=e.type,a=e.memoizedProps;switch(t[De]=e,t[_e]=a,n){case"dialog":Mu("cancel",t),Mu("close",t);break;case"iframe":case"object":case"embed":Mu("load",t);break;case"video":case"audio":for(n=0;n<Ou.length;n++)Mu(Ou[n],t);break;case"source":Mu("error",t);break;case"img":case"image":case"link":Mu("error",t),Mu("load",t);break;case"details":Mu("toggle",t);break;case"input":Mu("invalid",t),bt(t,a.value,a.defaultValue,a.checked,a.defaultChecked,a.type,a.name,!0),ht(t);break;case"select":Mu("invalid",t);break;case"textarea":Mu("invalid",t),wt(t,a.value,a.defaultValue,a.children),ht(t)}"string"!==typeof(n=a.children)&&"number"!==typeof n&&"bigint"!==typeof n||t.textContent===""+n||!0===a.suppressHydrationWarning||Ju(t.textContent,n)?(null!=a.popover&&(Mu("beforetoggle",t),Mu("toggle",t)),null!=a.onScroll&&Mu("scroll",t),null!=a.onScrollEnd&&Mu("scrollend",t),null!=a.onClick&&(t.onclick=$u),t=!0):t=!1,t||cr(e)}function hr(e){for(ar=e.return;ar;)switch(ar.tag){case 5:case 13:return void(ir=!1);case 27:case 3:return void(ir=!0);default:ar=ar.return}}function dr(e){if(e!==ar)return!1;if(!or)return hr(e),or=!0,!1;var t,n=e.tag;if((t=3!==n&&27!==n)&&((t=5===n)&&(t=!("form"!==(t=e.type)&&"button"!==t)||sh(e.type,e.memoizedProps)),t=!t),t&&rr&&cr(e),hr(e),13===n){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(s(317));e:{for(e=e.nextSibling,n=0;e;){if(8===e.nodeType)if("/$"===(t=e.data)){if(0===n){rr=bh(e.nextSibling);break e}n--}else"$"!==t&&"$!"!==t&&"$?"!==t||n++;e=e.nextSibling}rr=null}}else 27===n?(n=rr,ph(e.type)?(e=yh,yh=null,rr=e):rr=n):rr=ar?bh(e.stateNode.nextSibling):null;return!0}function pr(){rr=ar=null,or=!1}function fr(){var e=sr;return null!==e&&(null===vc?vc=e:vc.push.apply(vc,e),sr=null),e}function gr(e){null===sr?sr=[e]:sr.push(e)}var mr=B(null),br=null,yr=null;function vr(e,t,n){U(mr,t._currentValue),t._currentValue=n}function xr(e){e._currentValue=mr.current,W(mr)}function wr(e,t,n){for(;null!==e;){var a=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==a&&(a.childLanes|=t)):null!==a&&(a.childLanes&t)!==t&&(a.childLanes|=t),e===n)break;e=e.return}}function kr(e,t,n,a){var r=e.child;for(null!==r&&(r.return=e);null!==r;){var o=r.dependencies;if(null!==o){var i=r.child;o=o.firstContext;e:for(;null!==o;){var l=o;o=r;for(var c=0;c<t.length;c++)if(l.context===t[c]){o.lanes|=n,null!==(l=o.alternate)&&(l.lanes|=n),wr(o.return,n,e),a||(i=null);break e}o=l.next}}else if(18===r.tag){if(null===(i=r.return))throw Error(s(341));i.lanes|=n,null!==(o=i.alternate)&&(o.lanes|=n),wr(i,n,e),i=null}else i=r.child;if(null!==i)i.return=r;else for(i=r;null!==i;){if(i===e){i=null;break}if(null!==(r=i.sibling)){r.return=i.return,i=r;break}i=i.return}r=i}}function Sr(e,t,n,a){e=null;for(var r=t,o=!1;null!==r;){if(!o)if(0!==(524288&r.flags))o=!0;else if(0!==(262144&r.flags))break;if(10===r.tag){var i=r.alternate;if(null===i)throw Error(s(387));if(null!==(i=i.memoizedProps)){var l=r.type;Yn(r.pendingProps.value,i.value)||(null!==e?e.push(l):e=[l])}}else if(r===H.current){if(null===(i=r.alternate))throw Error(s(387));i.memoizedState.memoizedState!==r.memoizedState.memoizedState&&(null!==e?e.push(Xh):e=[Xh])}r=r.return}null!==e&&kr(t,e,n,a),t.flags|=262144}function Ir(e){for(e=e.firstContext;null!==e;){if(!Yn(e.context._currentValue,e.memoizedValue))return!0;e=e.next}return!1}function Cr(e){br=e,yr=null,null!==(e=e.dependencies)&&(e.firstContext=null)}function Nr(e){return Tr(br,e)}function Er(e,t){return null===br&&Cr(e),Tr(e,t)}function Tr(e,t){var n=t._currentValue;if(t={context:t,memoizedValue:n,next:null},null===yr){if(null===e)throw Error(s(308));yr=t,e.dependencies={lanes:0,firstContext:t},e.flags|=524288}else yr=yr.next=t;return n}var Rr="undefined"!==typeof AbortController?AbortController:function(){var e=[],t=this.signal={aborted:!1,addEventListener:function(t,n){e.push(n)}};this.abort=function(){t.aborted=!0,e.forEach((function(e){return e()}))}},Ar=a.unstable_scheduleCallback,Fr=a.unstable_NormalPriority,Dr={$$typeof:w,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function _r(){return{controller:new Rr,data:new Map,refCount:0}}function Or(e){e.refCount--,0===e.refCount&&Ar(Fr,(function(){e.controller.abort()}))}var Lr=null,zr=0,Mr=0,Pr=null;function Br(){if(0===--zr&&null!==Lr){null!==Pr&&(Pr.status="fulfilled");var e=Lr;Lr=null,Mr=0,Pr=null;for(var t=0;t<e.length;t++)(0,e[t])()}}var Wr=O.S;O.S=function(e,t){"object"===typeof t&&null!==t&&"function"===typeof t.then&&function(e,t){if(null===Lr){var n=Lr=[];zr=0,Mr=Ru(),Pr={status:"pending",value:void 0,then:function(e){n.push(e)}}}zr++,t.then(Br,Br)}(0,t),null!==Wr&&Wr(e,t)};var Ur=B(null);function Vr(){var e=Ur.current;return null!==e?e:ac.pooledCache}function Gr(e,t){U(Ur,null===t?Ur.current:t.pool)}function jr(){var e=Vr();return null===e?null:{parent:Dr._currentValue,pool:e}}var Hr=Error(s(460)),Kr=Error(s(474)),qr=Error(s(542)),Xr={then:function(){}};function Yr(e){return"fulfilled"===(e=e.status)||"rejected"===e}function Jr(){}function $r(e,t,n){switch(void 0===(n=e[n])?e.push(t):n!==t&&(t.then(Jr,Jr),t=n),t.status){case"fulfilled":return t.value;case"rejected":throw eo(e=t.reason),e;default:if("string"===typeof t.status)t.then(Jr,Jr);else{if(null!==(e=ac)&&100<e.shellSuspendCounter)throw Error(s(482));(e=t).status="pending",e.then((function(e){if("pending"===t.status){var n=t;n.status="fulfilled",n.value=e}}),(function(e){if("pending"===t.status){var n=t;n.status="rejected",n.reason=e}}))}switch(t.status){case"fulfilled":return t.value;case"rejected":throw eo(e=t.reason),e}throw Qr=t,Hr}}var Qr=null;function Zr(){if(null===Qr)throw Error(s(459));var e=Qr;return Qr=null,e}function eo(e){if(e===Hr||e===qr)throw Error(s(483))}var to=!1;function no(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function ao(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,callbacks:null})}function ro(e){return{lane:e,tag:0,payload:null,callback:null,next:null}}function oo(e,t,n){var a=e.updateQueue;if(null===a)return null;if(a=a.shared,0!==(2&nc)){var r=a.pending;return null===r?t.next=t:(t.next=r.next,r.next=t),a.pending=t,t=_a(e),Da(e,null,n),t}return Ra(e,a,t,n),_a(e)}function so(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194048&n))){var a=t.lanes;n|=a&=e.pendingLanes,t.lanes=n,Ee(e,n)}}function io(e,t){var n=e.updateQueue,a=e.alternate;if(null!==a&&n===(a=a.updateQueue)){var r=null,o=null;if(null!==(n=n.firstBaseUpdate)){do{var s={lane:n.lane,tag:n.tag,payload:n.payload,callback:null,next:null};null===o?r=o=s:o=o.next=s,n=n.next}while(null!==n);null===o?r=o=t:o=o.next=t}else r=o=t;return n={baseState:a.baseState,firstBaseUpdate:r,lastBaseUpdate:o,shared:a.shared,callbacks:a.callbacks},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}var lo=!1;function co(){if(lo){if(null!==Pr)throw Pr}}function uo(e,t,n,a){lo=!1;var r=e.updateQueue;to=!1;var o=r.firstBaseUpdate,s=r.lastBaseUpdate,i=r.shared.pending;if(null!==i){r.shared.pending=null;var l=i,c=l.next;l.next=null,null===s?o=c:s.next=c,s=l;var u=e.alternate;null!==u&&((i=(u=u.updateQueue).lastBaseUpdate)!==s&&(null===i?u.firstBaseUpdate=c:i.next=c,u.lastBaseUpdate=l))}if(null!==o){var h=r.baseState;for(s=0,u=c=l=null,i=o;;){var p=-536870913&i.lane,f=p!==i.lane;if(f?(oc&p)===p:(a&p)===p){0!==p&&p===Mr&&(lo=!0),null!==u&&(u=u.next={lane:0,tag:i.tag,payload:i.payload,callback:null,next:null});e:{var g=e,m=i;p=t;var b=n;switch(m.tag){case 1:if("function"===typeof(g=m.payload)){h=g.call(b,h,p);break e}h=g;break e;case 3:g.flags=-65537&g.flags|128;case 0:if(null===(p="function"===typeof(g=m.payload)?g.call(b,h,p):g)||void 0===p)break e;h=d({},h,p);break e;case 2:to=!0}}null!==(p=i.callback)&&(e.flags|=64,f&&(e.flags|=8192),null===(f=r.callbacks)?r.callbacks=[p]:f.push(p))}else f={lane:p,tag:i.tag,payload:i.payload,callback:i.callback,next:null},null===u?(c=u=f,l=h):u=u.next=f,s|=p;if(null===(i=i.next)){if(null===(i=r.shared.pending))break;i=(f=i).next,f.next=null,r.lastBaseUpdate=f,r.shared.pending=null}}null===u&&(l=h),r.baseState=l,r.firstBaseUpdate=c,r.lastBaseUpdate=u,null===o&&(r.shared.lanes=0),pc|=s,e.lanes=s,e.memoizedState=h}}function ho(e,t){if("function"!==typeof e)throw Error(s(191,e));e.call(t)}function po(e,t){var n=e.callbacks;if(null!==n)for(e.callbacks=null,e=0;e<n.length;e++)ho(n[e],t)}var fo=B(null),go=B(0);function mo(e,t){U(go,e=hc),U(fo,t),hc=e|t.baseLanes}function bo(){U(go,hc),U(fo,fo.current)}function yo(){hc=go.current,W(fo),W(go)}var vo=0,xo=null,wo=null,ko=null,So=!1,Io=!1,Co=!1,No=0,Eo=0,To=null,Ro=0;function Ao(){throw Error(s(321))}function Fo(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Yn(e[n],t[n]))return!1;return!0}function Do(e,t,n,a,r,o){return vo=o,xo=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,O.H=null===e||null===e.memoizedState?Ks:qs,Co=!1,o=n(a,r),Co=!1,Io&&(o=Oo(t,n,a,r)),_o(e),o}function _o(e){O.H=Hs;var t=null!==wo&&null!==wo.next;if(vo=0,ko=wo=xo=null,So=!1,Eo=0,To=null,t)throw Error(s(300));null===e||Ei||null!==(e=e.dependencies)&&Ir(e)&&(Ei=!0)}function Oo(e,t,n,a){xo=e;var r=0;do{if(Io&&(To=null),Eo=0,Io=!1,25<=r)throw Error(s(301));if(r+=1,ko=wo=null,null!=e.updateQueue){var o=e.updateQueue;o.lastEffect=null,o.events=null,o.stores=null,null!=o.memoCache&&(o.memoCache.index=0)}O.H=Xs,o=t(n,a)}while(Io);return o}function Lo(){var e=O.H,t=e.useState()[0];return t="function"===typeof t.then?Uo(t):t,e=e.useState()[0],(null!==wo?wo.memoizedState:null)!==e&&(xo.flags|=1024),t}function zo(){var e=0!==No;return No=0,e}function Mo(e,t,n){t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~n}function Po(e){if(So){for(e=e.memoizedState;null!==e;){var t=e.queue;null!==t&&(t.pending=null),e=e.next}So=!1}vo=0,ko=wo=xo=null,Io=!1,Eo=No=0,To=null}function Bo(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===ko?xo.memoizedState=ko=e:ko=ko.next=e,ko}function Wo(){if(null===wo){var e=xo.alternate;e=null!==e?e.memoizedState:null}else e=wo.next;var t=null===ko?xo.memoizedState:ko.next;if(null!==t)ko=t,wo=e;else{if(null===e){if(null===xo.alternate)throw Error(s(467));throw Error(s(310))}e={memoizedState:(wo=e).memoizedState,baseState:wo.baseState,baseQueue:wo.baseQueue,queue:wo.queue,next:null},null===ko?xo.memoizedState=ko=e:ko=ko.next=e}return ko}function Uo(e){var t=Eo;return Eo+=1,null===To&&(To=[]),e=$r(To,e,t),t=xo,null===(null===ko?t.memoizedState:ko.next)&&(t=t.alternate,O.H=null===t||null===t.memoizedState?Ks:qs),e}function Vo(e){if(null!==e&&"object"===typeof e){if("function"===typeof e.then)return Uo(e);if(e.$$typeof===w)return Nr(e)}throw Error(s(438,String(e)))}function Go(e){var t=null,n=xo.updateQueue;if(null!==n&&(t=n.memoCache),null==t){var a=xo.alternate;null!==a&&(null!==(a=a.updateQueue)&&(null!=(a=a.memoCache)&&(t={data:a.data.map((function(e){return e.slice()})),index:0})))}if(null==t&&(t={data:[],index:0}),null===n&&(n={lastEffect:null,events:null,stores:null,memoCache:null},xo.updateQueue=n),n.memoCache=t,void 0===(n=t.data[t.index]))for(n=t.data[t.index]=Array(e),a=0;a<e;a++)n[a]=T;return t.index++,n}function jo(e,t){return"function"===typeof t?t(e):t}function Ho(e){return Ko(Wo(),wo,e)}function Ko(e,t,n){var a=e.queue;if(null===a)throw Error(s(311));a.lastRenderedReducer=n;var r=e.baseQueue,o=a.pending;if(null!==o){if(null!==r){var i=r.next;r.next=o.next,o.next=i}t.baseQueue=r=o,a.pending=null}if(o=e.baseState,null===r)e.memoizedState=o;else{var l=i=null,c=null,u=t=r.next,h=!1;do{var d=-536870913&u.lane;if(d!==u.lane?(oc&d)===d:(vo&d)===d){var p=u.revertLane;if(0===p)null!==c&&(c=c.next={lane:0,revertLane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),d===Mr&&(h=!0);else{if((vo&p)===p){u=u.next,p===Mr&&(h=!0);continue}d={lane:0,revertLane:u.revertLane,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null},null===c?(l=c=d,i=o):c=c.next=d,xo.lanes|=p,pc|=p}d=u.action,Co&&n(o,d),o=u.hasEagerState?u.eagerState:n(o,d)}else p={lane:d,revertLane:u.revertLane,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null},null===c?(l=c=p,i=o):c=c.next=p,xo.lanes|=d,pc|=d;u=u.next}while(null!==u&&u!==t);if(null===c?i=o:c.next=l,!Yn(o,e.memoizedState)&&(Ei=!0,h&&null!==(n=Pr)))throw n;e.memoizedState=o,e.baseState=i,e.baseQueue=c,a.lastRenderedState=o}return null===r&&(a.lanes=0),[e.memoizedState,a.dispatch]}function qo(e){var t=Wo(),n=t.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=e;var a=n.dispatch,r=n.pending,o=t.memoizedState;if(null!==r){n.pending=null;var i=r=r.next;do{o=e(o,i.action),i=i.next}while(i!==r);Yn(o,t.memoizedState)||(Ei=!0),t.memoizedState=o,null===t.baseQueue&&(t.baseState=o),n.lastRenderedState=o}return[o,a]}function Xo(e,t,n){var a=xo,r=Wo(),o=or;if(o){if(void 0===n)throw Error(s(407));n=n()}else n=t();var i=!Yn((wo||r).memoizedState,n);if(i&&(r.memoizedState=n,Ei=!0),r=r.queue,bs(2048,8,$o.bind(null,a,r,e),[e]),r.getSnapshot!==t||i||null!==ko&&1&ko.memoizedState.tag){if(a.flags|=2048,fs(9,{destroy:void 0,resource:void 0},Jo.bind(null,a,r,n,t),null),null===ac)throw Error(s(349));o||0!==(124&vo)||Yo(a,t,n)}return n}function Yo(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=xo.updateQueue)?(t={lastEffect:null,events:null,stores:null,memoCache:null},xo.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Jo(e,t,n,a){t.value=n,t.getSnapshot=a,Qo(t)&&Zo(e)}function $o(e,t,n){return n((function(){Qo(t)&&Zo(e)}))}function Qo(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Yn(e,n)}catch(a){return!0}}function Zo(e){var t=Fa(e,2);null!==t&&zc(t,e,2)}function es(e){var t=Bo();if("function"===typeof e){var n=e;if(e=n(),Co){de(!0);try{n()}finally{de(!1)}}}return t.memoizedState=t.baseState=e,t.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:jo,lastRenderedState:e},t}function ts(e,t,n,a){return e.baseState=n,Ko(e,wo,"function"===typeof a?a:jo)}function ns(e,t,n,a,r){if(Vs(e))throw Error(s(485));if(null!==(e=t.action)){var o={payload:r,action:e,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(e){o.listeners.push(e)}};null!==O.T?n(!0):o.isTransition=!1,a(o),null===(n=t.pending)?(o.next=t.pending=o,as(t,o)):(o.next=n.next,t.pending=n.next=o)}}function as(e,t){var n=t.action,a=t.payload,r=e.state;if(t.isTransition){var o=O.T,s={};O.T=s;try{var i=n(r,a),l=O.S;null!==l&&l(s,i),rs(e,t,i)}catch(c){ss(e,t,c)}finally{O.T=o}}else try{rs(e,t,o=n(r,a))}catch(u){ss(e,t,u)}}function rs(e,t,n){null!==n&&"object"===typeof n&&"function"===typeof n.then?n.then((function(n){os(e,t,n)}),(function(n){return ss(e,t,n)})):os(e,t,n)}function os(e,t,n){t.status="fulfilled",t.value=n,is(t),e.state=n,null!==(t=e.pending)&&((n=t.next)===t?e.pending=null:(n=n.next,t.next=n,as(e,n)))}function ss(e,t,n){var a=e.pending;if(e.pending=null,null!==a){a=a.next;do{t.status="rejected",t.reason=n,is(t),t=t.next}while(t!==a)}e.action=null}function is(e){e=e.listeners;for(var t=0;t<e.length;t++)(0,e[t])()}function ls(e,t){return t}function cs(e,t){if(or){var n=ac.formState;if(null!==n){e:{var a=xo;if(or){if(rr){t:{for(var r=rr,o=ir;8!==r.nodeType;){if(!o){r=null;break t}if(null===(r=bh(r.nextSibling))){r=null;break t}}r="F!"===(o=r.data)||"F"===o?r:null}if(r){rr=bh(r.nextSibling),a="F!"===r.data;break e}}cr(a)}a=!1}a&&(t=n[0])}}return(n=Bo()).memoizedState=n.baseState=t,a={pending:null,lanes:0,dispatch:null,lastRenderedReducer:ls,lastRenderedState:t},n.queue=a,n=Bs.bind(null,xo,a),a.dispatch=n,a=es(!1),o=Us.bind(null,xo,!1,a.queue),r={state:t,dispatch:null,action:e,pending:null},(a=Bo()).queue=r,n=ns.bind(null,xo,r,o,n),r.dispatch=n,a.memoizedState=e,[t,n,!1]}function us(e){return hs(Wo(),wo,e)}function hs(e,t,n){if(t=Ko(e,t,ls)[0],e=Ho(jo)[0],"object"===typeof t&&null!==t&&"function"===typeof t.then)try{var a=Uo(t)}catch(s){if(s===Hr)throw qr;throw s}else a=t;var r=(t=Wo()).queue,o=r.dispatch;return n!==t.memoizedState&&(xo.flags|=2048,fs(9,{destroy:void 0,resource:void 0},ds.bind(null,r,n),null)),[a,o,e]}function ds(e,t){e.action=t}function ps(e){var t=Wo(),n=wo;if(null!==n)return hs(t,n,e);Wo(),t=t.memoizedState;var a=(n=Wo()).queue.dispatch;return n.memoizedState=e,[t,a,!1]}function fs(e,t,n,a){return e={tag:e,create:n,deps:a,inst:t,next:null},null===(t=xo.updateQueue)&&(t={lastEffect:null,events:null,stores:null,memoCache:null},xo.updateQueue=t),null===(n=t.lastEffect)?t.lastEffect=e.next=e:(a=n.next,n.next=e,e.next=a,t.lastEffect=e),e}function gs(){return Wo().memoizedState}function ms(e,t,n,a){var r=Bo();a=void 0===a?null:a,xo.flags|=e,r.memoizedState=fs(1|t,{destroy:void 0,resource:void 0},n,a)}function bs(e,t,n,a){var r=Wo();a=void 0===a?null:a;var o=r.memoizedState.inst;null!==wo&&null!==a&&Fo(a,wo.memoizedState.deps)?r.memoizedState=fs(t,o,n,a):(xo.flags|=e,r.memoizedState=fs(1|t,o,n,a))}function ys(e,t){ms(8390656,8,e,t)}function vs(e,t){bs(2048,8,e,t)}function xs(e,t){return bs(4,2,e,t)}function ws(e,t){return bs(4,4,e,t)}function ks(e,t){if("function"===typeof t){e=e();var n=t(e);return function(){"function"===typeof n?n():t(null)}}if(null!==t&&void 0!==t)return e=e(),t.current=e,function(){t.current=null}}function Ss(e,t,n){n=null!==n&&void 0!==n?n.concat([e]):null,bs(4,4,ks.bind(null,t,e),n)}function Is(){}function Cs(e,t){var n=Wo();t=void 0===t?null:t;var a=n.memoizedState;return null!==t&&Fo(t,a[1])?a[0]:(n.memoizedState=[e,t],e)}function Ns(e,t){var n=Wo();t=void 0===t?null:t;var a=n.memoizedState;if(null!==t&&Fo(t,a[1]))return a[0];if(a=e(),Co){de(!0);try{e()}finally{de(!1)}}return n.memoizedState=[a,t],a}function Es(e,t,n){return void 0===n||0!==(1073741824&vo)?e.memoizedState=t:(e.memoizedState=n,e=Lc(),xo.lanes|=e,pc|=e,n)}function Ts(e,t,n,a){return Yn(n,t)?n:null!==fo.current?(e=Es(e,n,a),Yn(e,t)||(Ei=!0),e):0===(42&vo)?(Ei=!0,e.memoizedState=n):(e=Lc(),xo.lanes|=e,pc|=e,t)}function Rs(e,t,n,a,r){var o=L.p;L.p=0!==o&&8>o?o:8;var s=O.T,i={};O.T=i,Us(e,!1,t,n);try{var l=r(),c=O.S;if(null!==c&&c(i,l),null!==l&&"object"===typeof l&&"function"===typeof l.then)Ws(e,t,function(e,t){var n=[],a={status:"pending",value:null,reason:null,then:function(e){n.push(e)}};return e.then((function(){a.status="fulfilled",a.value=t;for(var e=0;e<n.length;e++)(0,n[e])(t)}),(function(e){for(a.status="rejected",a.reason=e,e=0;e<n.length;e++)(0,n[e])(void 0)})),a}(l,a),Oc());else Ws(e,t,a,Oc())}catch(u){Ws(e,t,{then:function(){},status:"rejected",reason:u},Oc())}finally{L.p=o,O.T=s}}function As(){}function Fs(e,t,n,a){if(5!==e.tag)throw Error(s(476));var r=Ds(e).queue;Rs(e,r,t,z,null===n?As:function(){return _s(e),n(a)})}function Ds(e){var t=e.memoizedState;if(null!==t)return t;var n={};return(t={memoizedState:z,baseState:z,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:jo,lastRenderedState:z},next:null}).next={memoizedState:n,baseState:n,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:jo,lastRenderedState:n},next:null},e.memoizedState=t,null!==(e=e.alternate)&&(e.memoizedState=t),t}function _s(e){Ws(e,Ds(e).next.queue,{},Oc())}function Os(){return Nr(Xh)}function Ls(){return Wo().memoizedState}function zs(){return Wo().memoizedState}function Ms(e){for(var t=e.return;null!==t;){switch(t.tag){case 24:case 3:var n=Oc(),a=oo(t,e=ro(n),n);return null!==a&&(zc(a,t,n),so(a,t,n)),t={cache:_r()},void(e.payload=t)}t=t.return}}function Ps(e,t,n){var a=Oc();n={lane:a,revertLane:0,action:n,hasEagerState:!1,eagerState:null,next:null},Vs(e)?Gs(t,n):null!==(n=Aa(e,t,n,a))&&(zc(n,e,a),js(n,t,a))}function Bs(e,t,n){Ws(e,t,n,Oc())}function Ws(e,t,n,a){var r={lane:a,revertLane:0,action:n,hasEagerState:!1,eagerState:null,next:null};if(Vs(e))Gs(t,r);else{var o=e.alternate;if(0===e.lanes&&(null===o||0===o.lanes)&&null!==(o=t.lastRenderedReducer))try{var s=t.lastRenderedState,i=o(s,n);if(r.hasEagerState=!0,r.eagerState=i,Yn(i,s))return Ra(e,t,r,0),null===ac&&Ta(),!1}catch(l){}if(null!==(n=Aa(e,t,r,a)))return zc(n,e,a),js(n,t,a),!0}return!1}function Us(e,t,n,a){if(a={lane:2,revertLane:Ru(),action:a,hasEagerState:!1,eagerState:null,next:null},Vs(e)){if(t)throw Error(s(479))}else null!==(t=Aa(e,n,a,2))&&zc(t,e,2)}function Vs(e){var t=e.alternate;return e===xo||null!==t&&t===xo}function Gs(e,t){Io=So=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function js(e,t,n){if(0!==(4194048&n)){var a=t.lanes;n|=a&=e.pendingLanes,t.lanes=n,Ee(e,n)}}var Hs={readContext:Nr,use:Vo,useCallback:Ao,useContext:Ao,useEffect:Ao,useImperativeHandle:Ao,useLayoutEffect:Ao,useInsertionEffect:Ao,useMemo:Ao,useReducer:Ao,useRef:Ao,useState:Ao,useDebugValue:Ao,useDeferredValue:Ao,useTransition:Ao,useSyncExternalStore:Ao,useId:Ao,useHostTransitionStatus:Ao,useFormState:Ao,useActionState:Ao,useOptimistic:Ao,useMemoCache:Ao,useCacheRefresh:Ao},Ks={readContext:Nr,use:Vo,useCallback:function(e,t){return Bo().memoizedState=[e,void 0===t?null:t],e},useContext:Nr,useEffect:ys,useImperativeHandle:function(e,t,n){n=null!==n&&void 0!==n?n.concat([e]):null,ms(4194308,4,ks.bind(null,t,e),n)},useLayoutEffect:function(e,t){return ms(4194308,4,e,t)},useInsertionEffect:function(e,t){ms(4,2,e,t)},useMemo:function(e,t){var n=Bo();t=void 0===t?null:t;var a=e();if(Co){de(!0);try{e()}finally{de(!1)}}return n.memoizedState=[a,t],a},useReducer:function(e,t,n){var a=Bo();if(void 0!==n){var r=n(t);if(Co){de(!0);try{n(t)}finally{de(!1)}}}else r=t;return a.memoizedState=a.baseState=r,e={pending:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:r},a.queue=e,e=e.dispatch=Ps.bind(null,xo,e),[a.memoizedState,e]},useRef:function(e){return e={current:e},Bo().memoizedState=e},useState:function(e){var t=(e=es(e)).queue,n=Bs.bind(null,xo,t);return t.dispatch=n,[e.memoizedState,n]},useDebugValue:Is,useDeferredValue:function(e,t){return Es(Bo(),e,t)},useTransition:function(){var e=es(!1);return e=Rs.bind(null,xo,e.queue,!0,!1),Bo().memoizedState=e,[!1,e]},useSyncExternalStore:function(e,t,n){var a=xo,r=Bo();if(or){if(void 0===n)throw Error(s(407));n=n()}else{if(n=t(),null===ac)throw Error(s(349));0!==(124&oc)||Yo(a,t,n)}r.memoizedState=n;var o={value:n,getSnapshot:t};return r.queue=o,ys($o.bind(null,a,o,e),[e]),a.flags|=2048,fs(9,{destroy:void 0,resource:void 0},Jo.bind(null,a,o,n,t),null),n},useId:function(){var e=Bo(),t=ac.identifierPrefix;if(or){var n=Qa;t="\xab"+t+"R"+(n=($a&~(1<<32-pe($a)-1)).toString(32)+n),0<(n=No++)&&(t+="H"+n.toString(32)),t+="\xbb"}else t="\xab"+t+"r"+(n=Ro++).toString(32)+"\xbb";return e.memoizedState=t},useHostTransitionStatus:Os,useFormState:cs,useActionState:cs,useOptimistic:function(e){var t=Bo();t.memoizedState=t.baseState=e;var n={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return t.queue=n,t=Us.bind(null,xo,!0,n),n.dispatch=t,[e,t]},useMemoCache:Go,useCacheRefresh:function(){return Bo().memoizedState=Ms.bind(null,xo)}},qs={readContext:Nr,use:Vo,useCallback:Cs,useContext:Nr,useEffect:vs,useImperativeHandle:Ss,useInsertionEffect:xs,useLayoutEffect:ws,useMemo:Ns,useReducer:Ho,useRef:gs,useState:function(){return Ho(jo)},useDebugValue:Is,useDeferredValue:function(e,t){return Ts(Wo(),wo.memoizedState,e,t)},useTransition:function(){var e=Ho(jo)[0],t=Wo().memoizedState;return["boolean"===typeof e?e:Uo(e),t]},useSyncExternalStore:Xo,useId:Ls,useHostTransitionStatus:Os,useFormState:us,useActionState:us,useOptimistic:function(e,t){return ts(Wo(),0,e,t)},useMemoCache:Go,useCacheRefresh:zs},Xs={readContext:Nr,use:Vo,useCallback:Cs,useContext:Nr,useEffect:vs,useImperativeHandle:Ss,useInsertionEffect:xs,useLayoutEffect:ws,useMemo:Ns,useReducer:qo,useRef:gs,useState:function(){return qo(jo)},useDebugValue:Is,useDeferredValue:function(e,t){var n=Wo();return null===wo?Es(n,e,t):Ts(n,wo.memoizedState,e,t)},useTransition:function(){var e=qo(jo)[0],t=Wo().memoizedState;return["boolean"===typeof e?e:Uo(e),t]},useSyncExternalStore:Xo,useId:Ls,useHostTransitionStatus:Os,useFormState:ps,useActionState:ps,useOptimistic:function(e,t){var n=Wo();return null!==wo?ts(n,0,e,t):(n.baseState=e,[e,n.queue.dispatch])},useMemoCache:Go,useCacheRefresh:zs},Ys=null,Js=0;function $s(e){var t=Js;return Js+=1,null===Ys&&(Ys=[]),$r(Ys,e,t)}function Qs(e,t){t=t.props.ref,e.ref=void 0!==t?t:null}function Zs(e,t){if(t.$$typeof===p)throw Error(s(525));throw e=Object.prototype.toString.call(t),Error(s(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function ei(e){return(0,e._init)(e._payload)}function ti(e){function t(t,n){if(e){var a=t.deletions;null===a?(t.deletions=[n],t.flags|=16):a.push(n)}}function n(n,a){if(!e)return null;for(;null!==a;)t(n,a),a=a.sibling;return null}function a(e){for(var t=new Map;null!==e;)null!==e.key?t.set(e.key,e):t.set(e.index,e),e=e.sibling;return t}function r(e,t){return(e=Pa(e,t)).index=0,e.sibling=null,e}function o(t,n,a){return t.index=a,e?null!==(a=t.alternate)?(a=a.index)<n?(t.flags|=67108866,n):a:(t.flags|=67108866,n):(t.flags|=1048576,n)}function i(t){return e&&null===t.alternate&&(t.flags|=67108866),t}function l(e,t,n,a){return null===t||6!==t.tag?((t=Va(n,e.mode,a)).return=e,t):((t=r(t,n)).return=e,t)}function c(e,t,n,a){var o=n.type;return o===m?h(e,t,n.props.children,a,n.key):null!==t&&(t.elementType===o||"object"===typeof o&&null!==o&&o.$$typeof===N&&ei(o)===t.type)?(Qs(t=r(t,n.props),n),t.return=e,t):(Qs(t=Wa(n.type,n.key,n.props,null,e.mode,a),n),t.return=e,t)}function u(e,t,n,a){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Ga(n,e.mode,a)).return=e,t):((t=r(t,n.children||[])).return=e,t)}function h(e,t,n,a,o){return null===t||7!==t.tag?((t=Ua(n,e.mode,a,o)).return=e,t):((t=r(t,n)).return=e,t)}function d(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t||"bigint"===typeof t)return(t=Va(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case f:return Qs(n=Wa(t.type,t.key,t.props,null,e.mode,n),t),n.return=e,n;case g:return(t=Ga(t,e.mode,n)).return=e,t;case N:return d(e,t=(0,t._init)(t._payload),n)}if(_(t)||A(t))return(t=Ua(t,e.mode,n,null)).return=e,t;if("function"===typeof t.then)return d(e,$s(t),n);if(t.$$typeof===w)return d(e,Er(e,t),n);Zs(e,t)}return null}function p(e,t,n,a){var r=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n||"bigint"===typeof n)return null!==r?null:l(e,t,""+n,a);if("object"===typeof n&&null!==n){switch(n.$$typeof){case f:return n.key===r?c(e,t,n,a):null;case g:return n.key===r?u(e,t,n,a):null;case N:return p(e,t,n=(r=n._init)(n._payload),a)}if(_(n)||A(n))return null!==r?null:h(e,t,n,a,null);if("function"===typeof n.then)return p(e,t,$s(n),a);if(n.$$typeof===w)return p(e,t,Er(e,n),a);Zs(e,n)}return null}function b(e,t,n,a,r){if("string"===typeof a&&""!==a||"number"===typeof a||"bigint"===typeof a)return l(t,e=e.get(n)||null,""+a,r);if("object"===typeof a&&null!==a){switch(a.$$typeof){case f:return c(t,e=e.get(null===a.key?n:a.key)||null,a,r);case g:return u(t,e=e.get(null===a.key?n:a.key)||null,a,r);case N:return b(e,t,n,a=(0,a._init)(a._payload),r)}if(_(a)||A(a))return h(t,e=e.get(n)||null,a,r,null);if("function"===typeof a.then)return b(e,t,n,$s(a),r);if(a.$$typeof===w)return b(e,t,n,Er(t,a),r);Zs(t,a)}return null}function y(l,c,u,h){if("object"===typeof u&&null!==u&&u.type===m&&null===u.key&&(u=u.props.children),"object"===typeof u&&null!==u){switch(u.$$typeof){case f:e:{for(var v=u.key;null!==c;){if(c.key===v){if((v=u.type)===m){if(7===c.tag){n(l,c.sibling),(h=r(c,u.props.children)).return=l,l=h;break e}}else if(c.elementType===v||"object"===typeof v&&null!==v&&v.$$typeof===N&&ei(v)===c.type){n(l,c.sibling),Qs(h=r(c,u.props),u),h.return=l,l=h;break e}n(l,c);break}t(l,c),c=c.sibling}u.type===m?((h=Ua(u.props.children,l.mode,h,u.key)).return=l,l=h):(Qs(h=Wa(u.type,u.key,u.props,null,l.mode,h),u),h.return=l,l=h)}return i(l);case g:e:{for(v=u.key;null!==c;){if(c.key===v){if(4===c.tag&&c.stateNode.containerInfo===u.containerInfo&&c.stateNode.implementation===u.implementation){n(l,c.sibling),(h=r(c,u.children||[])).return=l,l=h;break e}n(l,c);break}t(l,c),c=c.sibling}(h=Ga(u,l.mode,h)).return=l,l=h}return i(l);case N:return y(l,c,u=(v=u._init)(u._payload),h)}if(_(u))return function(r,s,i,l){for(var c=null,u=null,h=s,f=s=0,g=null;null!==h&&f<i.length;f++){h.index>f?(g=h,h=null):g=h.sibling;var m=p(r,h,i[f],l);if(null===m){null===h&&(h=g);break}e&&h&&null===m.alternate&&t(r,h),s=o(m,s,f),null===u?c=m:u.sibling=m,u=m,h=g}if(f===i.length)return n(r,h),or&&Za(r,f),c;if(null===h){for(;f<i.length;f++)null!==(h=d(r,i[f],l))&&(s=o(h,s,f),null===u?c=h:u.sibling=h,u=h);return or&&Za(r,f),c}for(h=a(h);f<i.length;f++)null!==(g=b(h,r,f,i[f],l))&&(e&&null!==g.alternate&&h.delete(null===g.key?f:g.key),s=o(g,s,f),null===u?c=g:u.sibling=g,u=g);return e&&h.forEach((function(e){return t(r,e)})),or&&Za(r,f),c}(l,c,u,h);if(A(u)){if("function"!==typeof(v=A(u)))throw Error(s(150));return function(r,i,l,c){if(null==l)throw Error(s(151));for(var u=null,h=null,f=i,g=i=0,m=null,y=l.next();null!==f&&!y.done;g++,y=l.next()){f.index>g?(m=f,f=null):m=f.sibling;var v=p(r,f,y.value,c);if(null===v){null===f&&(f=m);break}e&&f&&null===v.alternate&&t(r,f),i=o(v,i,g),null===h?u=v:h.sibling=v,h=v,f=m}if(y.done)return n(r,f),or&&Za(r,g),u;if(null===f){for(;!y.done;g++,y=l.next())null!==(y=d(r,y.value,c))&&(i=o(y,i,g),null===h?u=y:h.sibling=y,h=y);return or&&Za(r,g),u}for(f=a(f);!y.done;g++,y=l.next())null!==(y=b(f,r,g,y.value,c))&&(e&&null!==y.alternate&&f.delete(null===y.key?g:y.key),i=o(y,i,g),null===h?u=y:h.sibling=y,h=y);return e&&f.forEach((function(e){return t(r,e)})),or&&Za(r,g),u}(l,c,u=v.call(u),h)}if("function"===typeof u.then)return y(l,c,$s(u),h);if(u.$$typeof===w)return y(l,c,Er(l,u),h);Zs(l,u)}return"string"===typeof u&&""!==u||"number"===typeof u||"bigint"===typeof u?(u=""+u,null!==c&&6===c.tag?(n(l,c.sibling),(h=r(c,u)).return=l,l=h):(n(l,c),(h=Va(u,l.mode,h)).return=l,l=h),i(l)):n(l,c)}return function(e,t,n,a){try{Js=0;var r=y(e,t,n,a);return Ys=null,r}catch(s){if(s===Hr||s===qr)throw s;var o=za(29,s,null,e.mode);return o.lanes=a,o.return=e,o}}}var ni=ti(!0),ai=ti(!1),ri=B(null),oi=null;function si(e){var t=e.alternate;U(ui,1&ui.current),U(ri,e),null===oi&&(null===t||null!==fo.current||null!==t.memoizedState)&&(oi=e)}function ii(e){if(22===e.tag){if(U(ui,ui.current),U(ri,e),null===oi){var t=e.alternate;null!==t&&null!==t.memoizedState&&(oi=e)}}else li()}function li(){U(ui,ui.current),U(ri,ri.current)}function ci(e){W(ri),oi===e&&(oi=null),W(ui)}var ui=B(0);function hi(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||mh(n)))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}function di(e,t,n,a){n=null===(n=n(a,t=e.memoizedState))||void 0===n?t:d({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var pi={enqueueSetState:function(e,t,n){e=e._reactInternals;var a=Oc(),r=ro(a);r.payload=t,void 0!==n&&null!==n&&(r.callback=n),null!==(t=oo(e,r,a))&&(zc(t,e,a),so(t,e,a))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var a=Oc(),r=ro(a);r.tag=1,r.payload=t,void 0!==n&&null!==n&&(r.callback=n),null!==(t=oo(e,r,a))&&(zc(t,e,a),so(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=Oc(),a=ro(n);a.tag=2,void 0!==t&&null!==t&&(a.callback=t),null!==(t=oo(e,a,n))&&(zc(t,e,n),so(t,e,n))}};function fi(e,t,n,a,r,o,s){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(a,o,s):!t.prototype||!t.prototype.isPureReactComponent||(!Jn(n,a)||!Jn(r,o))}function gi(e,t,n,a){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,a),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,a),t.state!==e&&pi.enqueueReplaceState(t,t.state,null)}function mi(e,t){var n=t;if("ref"in t)for(var a in n={},t)"ref"!==a&&(n[a]=t[a]);if(e=e.defaultProps)for(var r in n===t&&(n=d({},n)),e)void 0===n[r]&&(n[r]=e[r]);return n}var bi="function"===typeof reportError?reportError:function(e){if("object"===typeof window&&"function"===typeof window.ErrorEvent){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:"object"===typeof e&&null!==e&&"string"===typeof e.message?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if("object"===typeof process&&"function"===typeof process.emit)return void process.emit("uncaughtException",e);console.error(e)};function yi(e){bi(e)}function vi(e){console.error(e)}function xi(e){bi(e)}function wi(e,t){try{(0,e.onUncaughtError)(t.value,{componentStack:t.stack})}catch(n){setTimeout((function(){throw n}))}}function ki(e,t,n){try{(0,e.onCaughtError)(n.value,{componentStack:n.stack,errorBoundary:1===t.tag?t.stateNode:null})}catch(a){setTimeout((function(){throw a}))}}function Si(e,t,n){return(n=ro(n)).tag=3,n.payload={element:null},n.callback=function(){wi(e,t)},n}function Ii(e){return(e=ro(e)).tag=3,e}function Ci(e,t,n,a){var r=n.type.getDerivedStateFromError;if("function"===typeof r){var o=a.value;e.payload=function(){return r(o)},e.callback=function(){ki(t,n,a)}}var s=n.stateNode;null!==s&&"function"===typeof s.componentDidCatch&&(e.callback=function(){ki(t,n,a),"function"!==typeof r&&(null===Ic?Ic=new Set([this]):Ic.add(this));var e=a.stack;this.componentDidCatch(a.value,{componentStack:null!==e?e:""})})}var Ni=Error(s(461)),Ei=!1;function Ti(e,t,n,a){t.child=null===e?ai(t,null,n,a):ni(t,e.child,n,a)}function Ri(e,t,n,a,r){n=n.render;var o=t.ref;if("ref"in a){var s={};for(var i in a)"ref"!==i&&(s[i]=a[i])}else s=a;return Cr(t),a=Do(e,t,n,s,o,r),i=zo(),null===e||Ei?(or&&i&&tr(t),t.flags|=1,Ti(e,t,a,r),t.child):(Mo(e,t,r),Yi(e,t,r))}function Ai(e,t,n,a,r){if(null===e){var o=n.type;return"function"!==typeof o||Ma(o)||void 0!==o.defaultProps||null!==n.compare?((e=Wa(n.type,null,a,t,t.mode,r)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=o,Fi(e,t,o,a,r))}if(o=e.child,!Ji(e,r)){var s=o.memoizedProps;if((n=null!==(n=n.compare)?n:Jn)(s,a)&&e.ref===t.ref)return Yi(e,t,r)}return t.flags|=1,(e=Pa(o,a)).ref=t.ref,e.return=t,t.child=e}function Fi(e,t,n,a,r){if(null!==e){var o=e.memoizedProps;if(Jn(o,a)&&e.ref===t.ref){if(Ei=!1,t.pendingProps=a=o,!Ji(e,r))return t.lanes=e.lanes,Yi(e,t,r);0!==(131072&e.flags)&&(Ei=!0)}}return Li(e,t,n,a,r)}function Di(e,t,n){var a=t.pendingProps,r=a.children,o=null!==e?e.memoizedState:null;if("hidden"===a.mode){if(0!==(128&t.flags)){if(a=null!==o?o.baseLanes|n:n,null!==e){for(r=t.child=e.child,o=0;null!==r;)o=o|r.lanes|r.childLanes,r=r.sibling;t.childLanes=o&~a}else t.childLanes=0,t.child=null;return _i(e,t,a,n)}if(0===(536870912&n))return t.lanes=t.childLanes=536870912,_i(e,t,null!==o?o.baseLanes|n:n,n);t.memoizedState={baseLanes:0,cachePool:null},null!==e&&Gr(0,null!==o?o.cachePool:null),null!==o?mo(t,o):bo(),ii(t)}else null!==o?(Gr(0,o.cachePool),mo(t,o),li(),t.memoizedState=null):(null!==e&&Gr(0,null),bo(),li());return Ti(e,t,r,n),t.child}function _i(e,t,n,a){var r=Vr();return r=null===r?null:{parent:Dr._currentValue,pool:r},t.memoizedState={baseLanes:n,cachePool:r},null!==e&&Gr(0,null),bo(),ii(t),null!==e&&Sr(e,t,a,!0),null}function Oi(e,t){var n=t.ref;if(null===n)null!==e&&null!==e.ref&&(t.flags|=4194816);else{if("function"!==typeof n&&"object"!==typeof n)throw Error(s(284));null!==e&&e.ref===n||(t.flags|=4194816)}}function Li(e,t,n,a,r){return Cr(t),n=Do(e,t,n,a,void 0,r),a=zo(),null===e||Ei?(or&&a&&tr(t),t.flags|=1,Ti(e,t,n,r),t.child):(Mo(e,t,r),Yi(e,t,r))}function zi(e,t,n,a,r,o){return Cr(t),t.updateQueue=null,n=Oo(t,a,n,r),_o(e),a=zo(),null===e||Ei?(or&&a&&tr(t),t.flags|=1,Ti(e,t,n,o),t.child):(Mo(e,t,o),Yi(e,t,o))}function Mi(e,t,n,a,r){if(Cr(t),null===t.stateNode){var o=Oa,s=n.contextType;"object"===typeof s&&null!==s&&(o=Nr(s)),o=new n(a,o),t.memoizedState=null!==o.state&&void 0!==o.state?o.state:null,o.updater=pi,t.stateNode=o,o._reactInternals=t,(o=t.stateNode).props=a,o.state=t.memoizedState,o.refs={},no(t),s=n.contextType,o.context="object"===typeof s&&null!==s?Nr(s):Oa,o.state=t.memoizedState,"function"===typeof(s=n.getDerivedStateFromProps)&&(di(t,n,s,a),o.state=t.memoizedState),"function"===typeof n.getDerivedStateFromProps||"function"===typeof o.getSnapshotBeforeUpdate||"function"!==typeof o.UNSAFE_componentWillMount&&"function"!==typeof o.componentWillMount||(s=o.state,"function"===typeof o.componentWillMount&&o.componentWillMount(),"function"===typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount(),s!==o.state&&pi.enqueueReplaceState(o,o.state,null),uo(t,a,o,r),co(),o.state=t.memoizedState),"function"===typeof o.componentDidMount&&(t.flags|=4194308),a=!0}else if(null===e){o=t.stateNode;var i=t.memoizedProps,l=mi(n,i);o.props=l;var c=o.context,u=n.contextType;s=Oa,"object"===typeof u&&null!==u&&(s=Nr(u));var h=n.getDerivedStateFromProps;u="function"===typeof h||"function"===typeof o.getSnapshotBeforeUpdate,i=t.pendingProps!==i,u||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(i||c!==s)&&gi(t,o,a,s),to=!1;var d=t.memoizedState;o.state=d,uo(t,a,o,r),co(),c=t.memoizedState,i||d!==c||to?("function"===typeof h&&(di(t,n,h,a),c=t.memoizedState),(l=to||fi(t,n,l,a,d,c,s))?(u||"function"!==typeof o.UNSAFE_componentWillMount&&"function"!==typeof o.componentWillMount||("function"===typeof o.componentWillMount&&o.componentWillMount(),"function"===typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount()),"function"===typeof o.componentDidMount&&(t.flags|=4194308)):("function"===typeof o.componentDidMount&&(t.flags|=4194308),t.memoizedProps=a,t.memoizedState=c),o.props=a,o.state=c,o.context=s,a=l):("function"===typeof o.componentDidMount&&(t.flags|=4194308),a=!1)}else{o=t.stateNode,ao(e,t),u=mi(n,s=t.memoizedProps),o.props=u,h=t.pendingProps,d=o.context,c=n.contextType,l=Oa,"object"===typeof c&&null!==c&&(l=Nr(c)),(c="function"===typeof(i=n.getDerivedStateFromProps)||"function"===typeof o.getSnapshotBeforeUpdate)||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(s!==h||d!==l)&&gi(t,o,a,l),to=!1,d=t.memoizedState,o.state=d,uo(t,a,o,r),co();var p=t.memoizedState;s!==h||d!==p||to||null!==e&&null!==e.dependencies&&Ir(e.dependencies)?("function"===typeof i&&(di(t,n,i,a),p=t.memoizedState),(u=to||fi(t,n,u,a,d,p,l)||null!==e&&null!==e.dependencies&&Ir(e.dependencies))?(c||"function"!==typeof o.UNSAFE_componentWillUpdate&&"function"!==typeof o.componentWillUpdate||("function"===typeof o.componentWillUpdate&&o.componentWillUpdate(a,p,l),"function"===typeof o.UNSAFE_componentWillUpdate&&o.UNSAFE_componentWillUpdate(a,p,l)),"function"===typeof o.componentDidUpdate&&(t.flags|=4),"function"===typeof o.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof o.componentDidUpdate||s===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||s===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=a,t.memoizedState=p),o.props=a,o.state=p,o.context=l,a=u):("function"!==typeof o.componentDidUpdate||s===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||s===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),a=!1)}return o=a,Oi(e,t),a=0!==(128&t.flags),o||a?(o=t.stateNode,n=a&&"function"!==typeof n.getDerivedStateFromError?null:o.render(),t.flags|=1,null!==e&&a?(t.child=ni(t,e.child,null,r),t.child=ni(t,null,n,r)):Ti(e,t,n,r),t.memoizedState=o.state,e=t.child):e=Yi(e,t,r),e}function Pi(e,t,n,a){return pr(),t.flags|=256,Ti(e,t,n,a),t.child}var Bi={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Wi(e){return{baseLanes:e,cachePool:jr()}}function Ui(e,t,n){return e=null!==e?e.childLanes&~n:0,t&&(e|=mc),e}function Vi(e,t,n){var a,r=t.pendingProps,o=!1,i=0!==(128&t.flags);if((a=i)||(a=(null===e||null!==e.memoizedState)&&0!==(2&ui.current)),a&&(o=!0,t.flags&=-129),a=0!==(32&t.flags),t.flags&=-33,null===e){if(or){if(o?si(t):li(),or){var l,c=rr;if(l=c){e:{for(l=c,c=ir;8!==l.nodeType;){if(!c){c=null;break e}if(null===(l=bh(l.nextSibling))){c=null;break e}}c=l}null!==c?(t.memoizedState={dehydrated:c,treeContext:null!==Ja?{id:$a,overflow:Qa}:null,retryLane:536870912,hydrationErrors:null},(l=za(18,null,null,0)).stateNode=c,l.return=t,t.child=l,ar=t,rr=null,l=!0):l=!1}l||cr(t)}if(null!==(c=t.memoizedState)&&null!==(c=c.dehydrated))return mh(c)?t.lanes=32:t.lanes=536870912,null;ci(t)}return c=r.children,r=r.fallback,o?(li(),c=ji({mode:"hidden",children:c},o=t.mode),r=Ua(r,o,n,null),c.return=t,r.return=t,c.sibling=r,t.child=c,(o=t.child).memoizedState=Wi(n),o.childLanes=Ui(e,a,n),t.memoizedState=Bi,r):(si(t),Gi(t,c))}if(null!==(l=e.memoizedState)&&null!==(c=l.dehydrated)){if(i)256&t.flags?(si(t),t.flags&=-257,t=Hi(e,t,n)):null!==t.memoizedState?(li(),t.child=e.child,t.flags|=128,t=null):(li(),o=r.fallback,c=t.mode,r=ji({mode:"visible",children:r.children},c),(o=Ua(o,c,n,null)).flags|=2,r.return=t,o.return=t,r.sibling=o,t.child=r,ni(t,e.child,null,n),(r=t.child).memoizedState=Wi(n),r.childLanes=Ui(e,a,n),t.memoizedState=Bi,t=o);else if(si(t),mh(c)){if(a=c.nextSibling&&c.nextSibling.dataset)var u=a.dgst;a=u,(r=Error(s(419))).stack="",r.digest=a,gr({value:r,source:null,stack:null}),t=Hi(e,t,n)}else if(Ei||Sr(e,t,n,!1),a=0!==(n&e.childLanes),Ei||a){if(null!==(a=ac)&&(0!==(r=0!==((r=0!==(42&(r=n&-n))?1:Te(r))&(a.suspendedLanes|n))?0:r)&&r!==l.retryLane))throw l.retryLane=r,Fa(e,r),zc(a,e,r),Ni;"$?"===c.data||qc(),t=Hi(e,t,n)}else"$?"===c.data?(t.flags|=192,t.child=e.child,t=null):(e=l.treeContext,rr=bh(c.nextSibling),ar=t,or=!0,sr=null,ir=!1,null!==e&&(Xa[Ya++]=$a,Xa[Ya++]=Qa,Xa[Ya++]=Ja,$a=e.id,Qa=e.overflow,Ja=t),(t=Gi(t,r.children)).flags|=4096);return t}return o?(li(),o=r.fallback,c=t.mode,u=(l=e.child).sibling,(r=Pa(l,{mode:"hidden",children:r.children})).subtreeFlags=65011712&l.subtreeFlags,null!==u?o=Pa(u,o):(o=Ua(o,c,n,null)).flags|=2,o.return=t,r.return=t,r.sibling=o,t.child=r,r=o,o=t.child,null===(c=e.child.memoizedState)?c=Wi(n):(null!==(l=c.cachePool)?(u=Dr._currentValue,l=l.parent!==u?{parent:u,pool:u}:l):l=jr(),c={baseLanes:c.baseLanes|n,cachePool:l}),o.memoizedState=c,o.childLanes=Ui(e,a,n),t.memoizedState=Bi,r):(si(t),e=(n=e.child).sibling,(n=Pa(n,{mode:"visible",children:r.children})).return=t,n.sibling=null,null!==e&&(null===(a=t.deletions)?(t.deletions=[e],t.flags|=16):a.push(e)),t.child=n,t.memoizedState=null,n)}function Gi(e,t){return(t=ji({mode:"visible",children:t},e.mode)).return=e,e.child=t}function ji(e,t){return(e=za(22,e,null,t)).lanes=0,e.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},e}function Hi(e,t,n){return ni(t,e.child,null,n),(e=Gi(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Ki(e,t,n){e.lanes|=t;var a=e.alternate;null!==a&&(a.lanes|=t),wr(e.return,t,n)}function qi(e,t,n,a,r){var o=e.memoizedState;null===o?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:a,tail:n,tailMode:r}:(o.isBackwards=t,o.rendering=null,o.renderingStartTime=0,o.last=a,o.tail=n,o.tailMode=r)}function Xi(e,t,n){var a=t.pendingProps,r=a.revealOrder,o=a.tail;if(Ti(e,t,a.children,n),0!==(2&(a=ui.current)))a=1&a|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Ki(e,n,t);else if(19===e.tag)Ki(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}a&=1}switch(U(ui,a),r){case"forwards":for(n=t.child,r=null;null!==n;)null!==(e=n.alternate)&&null===hi(e)&&(r=n),n=n.sibling;null===(n=r)?(r=t.child,t.child=null):(r=n.sibling,n.sibling=null),qi(t,!1,r,n,o);break;case"backwards":for(n=null,r=t.child,t.child=null;null!==r;){if(null!==(e=r.alternate)&&null===hi(e)){t.child=r;break}e=r.sibling,r.sibling=n,n=r,r=e}qi(t,!0,n,null,o);break;case"together":qi(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Yi(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),pc|=t.lanes,0===(n&t.childLanes)){if(null===e)return null;if(Sr(e,t,n,!1),0===(n&t.childLanes))return null}if(null!==e&&t.child!==e.child)throw Error(s(153));if(null!==t.child){for(n=Pa(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Pa(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Ji(e,t){return 0!==(e.lanes&t)||!(null===(e=e.dependencies)||!Ir(e))}function $i(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps)Ei=!0;else{if(!Ji(e,n)&&0===(128&t.flags))return Ei=!1,function(e,t,n){switch(t.tag){case 3:K(t,t.stateNode.containerInfo),vr(0,Dr,e.memoizedState.cache),pr();break;case 27:case 5:X(t);break;case 4:K(t,t.stateNode.containerInfo);break;case 10:vr(0,t.type,t.memoizedProps.value);break;case 13:var a=t.memoizedState;if(null!==a)return null!==a.dehydrated?(si(t),t.flags|=128,null):0!==(n&t.child.childLanes)?Vi(e,t,n):(si(t),null!==(e=Yi(e,t,n))?e.sibling:null);si(t);break;case 19:var r=0!==(128&e.flags);if((a=0!==(n&t.childLanes))||(Sr(e,t,n,!1),a=0!==(n&t.childLanes)),r){if(a)return Xi(e,t,n);t.flags|=128}if(null!==(r=t.memoizedState)&&(r.rendering=null,r.tail=null,r.lastEffect=null),U(ui,ui.current),a)break;return null;case 22:case 23:return t.lanes=0,Di(e,t,n);case 24:vr(0,Dr,e.memoizedState.cache)}return Yi(e,t,n)}(e,t,n);Ei=0!==(131072&e.flags)}else Ei=!1,or&&0!==(1048576&t.flags)&&er(t,qa,t.index);switch(t.lanes=0,t.tag){case 16:e:{e=t.pendingProps;var a=t.elementType,r=a._init;if(a=r(a._payload),t.type=a,"function"!==typeof a){if(void 0!==a&&null!==a){if((r=a.$$typeof)===k){t.tag=11,t=Ri(null,t,a,e,n);break e}if(r===C){t.tag=14,t=Ai(null,t,a,e,n);break e}}throw t=D(a)||a,Error(s(306,t,""))}Ma(a)?(e=mi(a,e),t.tag=1,t=Mi(null,t,a,e,n)):(t.tag=0,t=Li(null,t,a,e,n))}return t;case 0:return Li(e,t,t.type,t.pendingProps,n);case 1:return Mi(e,t,a=t.type,r=mi(a,t.pendingProps),n);case 3:e:{if(K(t,t.stateNode.containerInfo),null===e)throw Error(s(387));a=t.pendingProps;var o=t.memoizedState;r=o.element,ao(e,t),uo(t,a,null,n);var i=t.memoizedState;if(a=i.cache,vr(0,Dr,a),a!==o.cache&&kr(t,[Dr],n,!0),co(),a=i.element,o.isDehydrated){if(o={element:a,isDehydrated:!1,cache:i.cache},t.updateQueue.baseState=o,t.memoizedState=o,256&t.flags){t=Pi(e,t,a,n);break e}if(a!==r){gr(r=Ia(Error(s(424)),t)),t=Pi(e,t,a,n);break e}if(9===(e=t.stateNode.containerInfo).nodeType)e=e.body;else e="HTML"===e.nodeName?e.ownerDocument.body:e;for(rr=bh(e.firstChild),ar=t,or=!0,sr=null,ir=!0,n=ai(t,null,a,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(pr(),a===r){t=Yi(e,t,n);break e}Ti(e,t,a,n)}t=t.child}return t;case 26:return Oi(e,t),null===e?(n=Th(t.type,null,t.pendingProps,null))?t.memoizedState=n:or||(n=t.type,e=t.pendingProps,(a=ah(j.current).createElement(n))[De]=t,a[_e]=e,eh(a,n,e),He(a),t.stateNode=a):t.memoizedState=Th(t.type,e.memoizedProps,t.pendingProps,e.memoizedState),null;case 27:return X(t),null===e&&or&&(a=t.stateNode=xh(t.type,t.pendingProps,j.current),ar=t,ir=!0,r=rr,ph(t.type)?(yh=r,rr=bh(a.firstChild)):rr=r),Ti(e,t,t.pendingProps.children,n),Oi(e,t),null===e&&(t.flags|=4194304),t.child;case 5:return null===e&&or&&((r=a=rr)&&(null!==(a=function(e,t,n,a){for(;1===e.nodeType;){var r=n;if(e.nodeName.toLowerCase()!==t.toLowerCase()){if(!a&&("INPUT"!==e.nodeName||"hidden"!==e.type))break}else if(a){if(!e[Be])switch(t){case"meta":if(!e.hasAttribute("itemprop"))break;return e;case"link":if("stylesheet"===(o=e.getAttribute("rel"))&&e.hasAttribute("data-precedence"))break;if(o!==r.rel||e.getAttribute("href")!==(null==r.href||""===r.href?null:r.href)||e.getAttribute("crossorigin")!==(null==r.crossOrigin?null:r.crossOrigin)||e.getAttribute("title")!==(null==r.title?null:r.title))break;return e;case"style":if(e.hasAttribute("data-precedence"))break;return e;case"script":if(((o=e.getAttribute("src"))!==(null==r.src?null:r.src)||e.getAttribute("type")!==(null==r.type?null:r.type)||e.getAttribute("crossorigin")!==(null==r.crossOrigin?null:r.crossOrigin))&&o&&e.hasAttribute("async")&&!e.hasAttribute("itemprop"))break;return e;default:return e}}else{if("input"!==t||"hidden"!==e.type)return e;var o=null==r.name?null:""+r.name;if("hidden"===r.type&&e.getAttribute("name")===o)return e}if(null===(e=bh(e.nextSibling)))break}return null}(a,t.type,t.pendingProps,ir))?(t.stateNode=a,ar=t,rr=bh(a.firstChild),ir=!1,r=!0):r=!1),r||cr(t)),X(t),r=t.type,o=t.pendingProps,i=null!==e?e.memoizedProps:null,a=o.children,sh(r,o)?a=null:null!==i&&sh(r,i)&&(t.flags|=32),null!==t.memoizedState&&(r=Do(e,t,Lo,null,null,n),Xh._currentValue=r),Oi(e,t),Ti(e,t,a,n),t.child;case 6:return null===e&&or&&((e=n=rr)&&(null!==(n=function(e,t,n){if(""===t)return null;for(;3!==e.nodeType;){if((1!==e.nodeType||"INPUT"!==e.nodeName||"hidden"!==e.type)&&!n)return null;if(null===(e=bh(e.nextSibling)))return null}return e}(n,t.pendingProps,ir))?(t.stateNode=n,ar=t,rr=null,e=!0):e=!1),e||cr(t)),null;case 13:return Vi(e,t,n);case 4:return K(t,t.stateNode.containerInfo),a=t.pendingProps,null===e?t.child=ni(t,null,a,n):Ti(e,t,a,n),t.child;case 11:return Ri(e,t,t.type,t.pendingProps,n);case 7:return Ti(e,t,t.pendingProps,n),t.child;case 8:case 12:return Ti(e,t,t.pendingProps.children,n),t.child;case 10:return a=t.pendingProps,vr(0,t.type,a.value),Ti(e,t,a.children,n),t.child;case 9:return r=t.type._context,a=t.pendingProps.children,Cr(t),a=a(r=Nr(r)),t.flags|=1,Ti(e,t,a,n),t.child;case 14:return Ai(e,t,t.type,t.pendingProps,n);case 15:return Fi(e,t,t.type,t.pendingProps,n);case 19:return Xi(e,t,n);case 31:return a=t.pendingProps,n=t.mode,a={mode:a.mode,children:a.children},null===e?((n=ji(a,n)).ref=t.ref,t.child=n,n.return=t,t=n):((n=Pa(e.child,a)).ref=t.ref,t.child=n,n.return=t,t=n),t;case 22:return Di(e,t,n);case 24:return Cr(t),a=Nr(Dr),null===e?(null===(r=Vr())&&(r=ac,o=_r(),r.pooledCache=o,o.refCount++,null!==o&&(r.pooledCacheLanes|=n),r=o),t.memoizedState={parent:a,cache:r},no(t),vr(0,Dr,r)):(0!==(e.lanes&n)&&(ao(e,t),uo(t,null,null,n),co()),r=e.memoizedState,o=t.memoizedState,r.parent!==a?(r={parent:a,cache:a},t.memoizedState=r,0===t.lanes&&(t.memoizedState=t.updateQueue.baseState=r),vr(0,Dr,a)):(a=o.cache,vr(0,Dr,a),a!==r.cache&&kr(t,[Dr],n,!0))),Ti(e,t,t.pendingProps.children,n),t.child;case 29:throw t.pendingProps}throw Error(s(156,t.tag))}function Qi(e){e.flags|=4}function Zi(e,t){if("stylesheet"!==t.type||0!==(4&t.state.loading))e.flags&=-16777217;else if(e.flags|=16777216,!Uh(t)){if(null!==(t=ri.current)&&((4194048&oc)===oc?null!==oi:(62914560&oc)!==oc&&0===(536870912&oc)||t!==oi))throw Qr=Xr,Kr;e.flags|=8192}}function el(e,t){null!==t&&(e.flags|=4),16384&e.flags&&(t=22!==e.tag?Se():536870912,e.lanes|=t,bc|=t)}function tl(e,t){if(!or)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var a=null;null!==n;)null!==n.alternate&&(a=n),n=n.sibling;null===a?t||null===e.tail?e.tail=null:e.tail.sibling=null:a.sibling=null}}function nl(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,a=0;if(t)for(var r=e.child;null!==r;)n|=r.lanes|r.childLanes,a|=65011712&r.subtreeFlags,a|=65011712&r.flags,r.return=e,r=r.sibling;else for(r=e.child;null!==r;)n|=r.lanes|r.childLanes,a|=r.subtreeFlags,a|=r.flags,r.return=e,r=r.sibling;return e.subtreeFlags|=a,e.childLanes=n,t}function al(e,t,n){var a=t.pendingProps;switch(nr(t),t.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:case 1:return nl(t),null;case 3:return n=t.stateNode,a=null,null!==e&&(a=e.memoizedState.cache),t.memoizedState.cache!==a&&(t.flags|=2048),xr(Dr),q(),n.pendingContext&&(n.context=n.pendingContext,n.pendingContext=null),null!==e&&null!==e.child||(dr(t)?Qi(t):null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,fr())),nl(t),null;case 26:return n=t.memoizedState,null===e?(Qi(t),null!==n?(nl(t),Zi(t,n)):(nl(t),t.flags&=-16777217)):n?n!==e.memoizedState?(Qi(t),nl(t),Zi(t,n)):(nl(t),t.flags&=-16777217):(e.memoizedProps!==a&&Qi(t),nl(t),t.flags&=-16777217),null;case 27:Y(t),n=j.current;var r=t.type;if(null!==e&&null!=t.stateNode)e.memoizedProps!==a&&Qi(t);else{if(!a){if(null===t.stateNode)throw Error(s(166));return nl(t),null}e=V.current,dr(t)?ur(t):(e=xh(r,a,n),t.stateNode=e,Qi(t))}return nl(t),null;case 5:if(Y(t),n=t.type,null!==e&&null!=t.stateNode)e.memoizedProps!==a&&Qi(t);else{if(!a){if(null===t.stateNode)throw Error(s(166));return nl(t),null}if(e=V.current,dr(t))ur(t);else{switch(r=ah(j.current),e){case 1:e=r.createElementNS("http://www.w3.org/2000/svg",n);break;case 2:e=r.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;default:switch(n){case"svg":e=r.createElementNS("http://www.w3.org/2000/svg",n);break;case"math":e=r.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;case"script":(e=r.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild);break;case"select":e="string"===typeof a.is?r.createElement("select",{is:a.is}):r.createElement("select"),a.multiple?e.multiple=!0:a.size&&(e.size=a.size);break;default:e="string"===typeof a.is?r.createElement(n,{is:a.is}):r.createElement(n)}}e[De]=t,e[_e]=a;e:for(r=t.child;null!==r;){if(5===r.tag||6===r.tag)e.appendChild(r.stateNode);else if(4!==r.tag&&27!==r.tag&&null!==r.child){r.child.return=r,r=r.child;continue}if(r===t)break e;for(;null===r.sibling;){if(null===r.return||r.return===t)break e;r=r.return}r.sibling.return=r.return,r=r.sibling}t.stateNode=e;e:switch(eh(e,n,a),n){case"button":case"input":case"select":case"textarea":e=!!a.autoFocus;break e;case"img":e=!0;break e;default:e=!1}e&&Qi(t)}}return nl(t),t.flags&=-16777217,null;case 6:if(e&&null!=t.stateNode)e.memoizedProps!==a&&Qi(t);else{if("string"!==typeof a&&null===t.stateNode)throw Error(s(166));if(e=j.current,dr(t)){if(e=t.stateNode,n=t.memoizedProps,a=null,null!==(r=ar))switch(r.tag){case 27:case 5:a=r.memoizedProps}e[De]=t,(e=!!(e.nodeValue===n||null!==a&&!0===a.suppressHydrationWarning||Ju(e.nodeValue,n)))||cr(t)}else(e=ah(e).createTextNode(a))[De]=t,t.stateNode=e}return nl(t),null;case 13:if(a=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(r=dr(t),null!==a&&null!==a.dehydrated){if(null===e){if(!r)throw Error(s(318));if(!(r=null!==(r=t.memoizedState)?r.dehydrated:null))throw Error(s(317));r[De]=t}else pr(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;nl(t),r=!1}else r=fr(),null!==e&&null!==e.memoizedState&&(e.memoizedState.hydrationErrors=r),r=!0;if(!r)return 256&t.flags?(ci(t),t):(ci(t),null)}if(ci(t),0!==(128&t.flags))return t.lanes=n,t;if(n=null!==a,e=null!==e&&null!==e.memoizedState,n){r=null,null!==(a=t.child).alternate&&null!==a.alternate.memoizedState&&null!==a.alternate.memoizedState.cachePool&&(r=a.alternate.memoizedState.cachePool.pool);var o=null;null!==a.memoizedState&&null!==a.memoizedState.cachePool&&(o=a.memoizedState.cachePool.pool),o!==r&&(a.flags|=2048)}return n!==e&&n&&(t.child.flags|=8192),el(t,t.updateQueue),nl(t),null;case 4:return q(),null===e&&Wu(t.stateNode.containerInfo),nl(t),null;case 10:return xr(t.type),nl(t),null;case 19:if(W(ui),null===(r=t.memoizedState))return nl(t),null;if(a=0!==(128&t.flags),null===(o=r.rendering))if(a)tl(r,!1);else{if(0!==dc||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(o=hi(e))){for(t.flags|=128,tl(r,!1),e=o.updateQueue,t.updateQueue=e,el(t,e),t.subtreeFlags=0,e=n,n=t.child;null!==n;)Ba(n,e),n=n.sibling;return U(ui,1&ui.current|2),t.child}e=e.sibling}null!==r.tail&&te()>kc&&(t.flags|=128,a=!0,tl(r,!1),t.lanes=4194304)}else{if(!a)if(null!==(e=hi(o))){if(t.flags|=128,a=!0,e=e.updateQueue,t.updateQueue=e,el(t,e),tl(r,!0),null===r.tail&&"hidden"===r.tailMode&&!o.alternate&&!or)return nl(t),null}else 2*te()-r.renderingStartTime>kc&&536870912!==n&&(t.flags|=128,a=!0,tl(r,!1),t.lanes=4194304);r.isBackwards?(o.sibling=t.child,t.child=o):(null!==(e=r.last)?e.sibling=o:t.child=o,r.last=o)}return null!==r.tail?(t=r.tail,r.rendering=t,r.tail=t.sibling,r.renderingStartTime=te(),t.sibling=null,e=ui.current,U(ui,a?1&e|2:1&e),t):(nl(t),null);case 22:case 23:return ci(t),yo(),a=null!==t.memoizedState,null!==e?null!==e.memoizedState!==a&&(t.flags|=8192):a&&(t.flags|=8192),a?0!==(536870912&n)&&0===(128&t.flags)&&(nl(t),6&t.subtreeFlags&&(t.flags|=8192)):nl(t),null!==(n=t.updateQueue)&&el(t,n.retryQueue),n=null,null!==e&&null!==e.memoizedState&&null!==e.memoizedState.cachePool&&(n=e.memoizedState.cachePool.pool),a=null,null!==t.memoizedState&&null!==t.memoizedState.cachePool&&(a=t.memoizedState.cachePool.pool),a!==n&&(t.flags|=2048),null!==e&&W(Ur),null;case 24:return n=null,null!==e&&(n=e.memoizedState.cache),t.memoizedState.cache!==n&&(t.flags|=2048),xr(Dr),nl(t),null;case 25:case 30:return null}throw Error(s(156,t.tag))}function rl(e,t){switch(nr(t),t.tag){case 1:return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return xr(Dr),q(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 26:case 27:case 5:return Y(t),null;case 13:if(ci(t),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(s(340));pr()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return W(ui),null;case 4:return q(),null;case 10:return xr(t.type),null;case 22:case 23:return ci(t),yo(),null!==e&&W(Ur),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 24:return xr(Dr),null;default:return null}}function ol(e,t){switch(nr(t),t.tag){case 3:xr(Dr),q();break;case 26:case 27:case 5:Y(t);break;case 4:q();break;case 13:ci(t);break;case 19:W(ui);break;case 10:xr(t.type);break;case 22:case 23:ci(t),yo(),null!==e&&W(Ur);break;case 24:xr(Dr)}}function sl(e,t){try{var n=t.updateQueue,a=null!==n?n.lastEffect:null;if(null!==a){var r=a.next;n=r;do{if((n.tag&e)===e){a=void 0;var o=n.create,s=n.inst;a=o(),s.destroy=a}n=n.next}while(n!==r)}}catch(i){uu(t,t.return,i)}}function il(e,t,n){try{var a=t.updateQueue,r=null!==a?a.lastEffect:null;if(null!==r){var o=r.next;a=o;do{if((a.tag&e)===e){var s=a.inst,i=s.destroy;if(void 0!==i){s.destroy=void 0,r=t;var l=n,c=i;try{c()}catch(u){uu(r,l,u)}}}a=a.next}while(a!==o)}}catch(u){uu(t,t.return,u)}}function ll(e){var t=e.updateQueue;if(null!==t){var n=e.stateNode;try{po(t,n)}catch(a){uu(e,e.return,a)}}}function cl(e,t,n){n.props=mi(e.type,e.memoizedProps),n.state=e.memoizedState;try{n.componentWillUnmount()}catch(a){uu(e,t,a)}}function ul(e,t){try{var n=e.ref;if(null!==n){switch(e.tag){case 26:case 27:case 5:var a=e.stateNode;break;default:a=e.stateNode}"function"===typeof n?e.refCleanup=n(a):n.current=a}}catch(r){uu(e,t,r)}}function hl(e,t){var n=e.ref,a=e.refCleanup;if(null!==n)if("function"===typeof a)try{a()}catch(r){uu(e,t,r)}finally{e.refCleanup=null,null!=(e=e.alternate)&&(e.refCleanup=null)}else if("function"===typeof n)try{n(null)}catch(o){uu(e,t,o)}else n.current=null}function dl(e){var t=e.type,n=e.memoizedProps,a=e.stateNode;try{e:switch(t){case"button":case"input":case"select":case"textarea":n.autoFocus&&a.focus();break e;case"img":n.src?a.src=n.src:n.srcSet&&(a.srcset=n.srcSet)}}catch(r){uu(e,e.return,r)}}function pl(e,t,n){try{var a=e.stateNode;!function(e,t,n,a){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var r=null,o=null,i=null,l=null,c=null,u=null,h=null;for(f in n){var d=n[f];if(n.hasOwnProperty(f)&&null!=d)switch(f){case"checked":case"value":break;case"defaultValue":c=d;default:a.hasOwnProperty(f)||Qu(e,t,f,null,a,d)}}for(var p in a){var f=a[p];if(d=n[p],a.hasOwnProperty(p)&&(null!=f||null!=d))switch(p){case"type":o=f;break;case"name":r=f;break;case"checked":u=f;break;case"defaultChecked":h=f;break;case"value":i=f;break;case"defaultValue":l=f;break;case"children":case"dangerouslySetInnerHTML":if(null!=f)throw Error(s(137,t));break;default:f!==d&&Qu(e,t,p,f,a,d)}}return void mt(e,i,l,c,u,h,o,r);case"select":for(o in f=i=l=p=null,n)if(c=n[o],n.hasOwnProperty(o)&&null!=c)switch(o){case"value":break;case"multiple":f=c;default:a.hasOwnProperty(o)||Qu(e,t,o,null,a,c)}for(r in a)if(o=a[r],c=n[r],a.hasOwnProperty(r)&&(null!=o||null!=c))switch(r){case"value":p=o;break;case"defaultValue":l=o;break;case"multiple":i=o;default:o!==c&&Qu(e,t,r,o,a,c)}return t=l,n=i,a=f,void(null!=p?vt(e,!!n,p,!1):!!a!==!!n&&(null!=t?vt(e,!!n,t,!0):vt(e,!!n,n?[]:"",!1)));case"textarea":for(l in f=p=null,n)if(r=n[l],n.hasOwnProperty(l)&&null!=r&&!a.hasOwnProperty(l))switch(l){case"value":case"children":break;default:Qu(e,t,l,null,a,r)}for(i in a)if(r=a[i],o=n[i],a.hasOwnProperty(i)&&(null!=r||null!=o))switch(i){case"value":p=r;break;case"defaultValue":f=r;break;case"children":break;case"dangerouslySetInnerHTML":if(null!=r)throw Error(s(91));break;default:r!==o&&Qu(e,t,i,r,a,o)}return void xt(e,p,f);case"option":for(var g in n)if(p=n[g],n.hasOwnProperty(g)&&null!=p&&!a.hasOwnProperty(g))if("selected"===g)e.selected=!1;else Qu(e,t,g,null,a,p);for(c in a)if(p=a[c],f=n[c],a.hasOwnProperty(c)&&p!==f&&(null!=p||null!=f))if("selected"===c)e.selected=p&&"function"!==typeof p&&"symbol"!==typeof p;else Qu(e,t,c,p,a,f);return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var m in n)p=n[m],n.hasOwnProperty(m)&&null!=p&&!a.hasOwnProperty(m)&&Qu(e,t,m,null,a,p);for(u in a)if(p=a[u],f=n[u],a.hasOwnProperty(u)&&p!==f&&(null!=p||null!=f))switch(u){case"children":case"dangerouslySetInnerHTML":if(null!=p)throw Error(s(137,t));break;default:Qu(e,t,u,p,a,f)}return;default:if(Nt(t)){for(var b in n)p=n[b],n.hasOwnProperty(b)&&void 0!==p&&!a.hasOwnProperty(b)&&Zu(e,t,b,void 0,a,p);for(h in a)p=a[h],f=n[h],!a.hasOwnProperty(h)||p===f||void 0===p&&void 0===f||Zu(e,t,h,p,a,f);return}}for(var y in n)p=n[y],n.hasOwnProperty(y)&&null!=p&&!a.hasOwnProperty(y)&&Qu(e,t,y,null,a,p);for(d in a)p=a[d],f=n[d],!a.hasOwnProperty(d)||p===f||null==p&&null==f||Qu(e,t,d,p,a,f)}(a,e.type,n,t),a[_e]=t}catch(r){uu(e,e.return,r)}}function fl(e){return 5===e.tag||3===e.tag||26===e.tag||27===e.tag&&ph(e.type)||4===e.tag}function gl(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||fl(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(27===e.tag&&ph(e.type))continue e;if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function ml(e,t,n){var a=e.tag;if(5===a||6===a)e=e.stateNode,t?(9===n.nodeType?n.body:"HTML"===n.nodeName?n.ownerDocument.body:n).insertBefore(e,t):((t=9===n.nodeType?n.body:"HTML"===n.nodeName?n.ownerDocument.body:n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=$u));else if(4!==a&&(27===a&&ph(e.type)&&(n=e.stateNode,t=null),null!==(e=e.child)))for(ml(e,t,n),e=e.sibling;null!==e;)ml(e,t,n),e=e.sibling}function bl(e,t,n){var a=e.tag;if(5===a||6===a)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==a&&(27===a&&ph(e.type)&&(n=e.stateNode),null!==(e=e.child)))for(bl(e,t,n),e=e.sibling;null!==e;)bl(e,t,n),e=e.sibling}function yl(e){var t=e.stateNode,n=e.memoizedProps;try{for(var a=e.type,r=t.attributes;r.length;)t.removeAttributeNode(r[0]);eh(t,a,n),t[De]=e,t[_e]=n}catch(o){uu(e,e.return,o)}}var vl=!1,xl=!1,wl=!1,kl="function"===typeof WeakSet?WeakSet:Set,Sl=null;function Il(e,t,n){var a=n.flags;switch(n.tag){case 0:case 11:case 15:Ml(e,n),4&a&&sl(5,n);break;case 1:if(Ml(e,n),4&a)if(e=n.stateNode,null===t)try{e.componentDidMount()}catch(s){uu(n,n.return,s)}else{var r=mi(n.type,t.memoizedProps);t=t.memoizedState;try{e.componentDidUpdate(r,t,e.__reactInternalSnapshotBeforeUpdate)}catch(i){uu(n,n.return,i)}}64&a&&ll(n),512&a&&ul(n,n.return);break;case 3:if(Ml(e,n),64&a&&null!==(e=n.updateQueue)){if(t=null,null!==n.child)switch(n.child.tag){case 27:case 5:case 1:t=n.child.stateNode}try{po(e,t)}catch(s){uu(n,n.return,s)}}break;case 27:null===t&&4&a&&yl(n);case 26:case 5:Ml(e,n),null===t&&4&a&&dl(n),512&a&&ul(n,n.return);break;case 12:Ml(e,n);break;case 13:Ml(e,n),4&a&&Al(e,n),64&a&&(null!==(e=n.memoizedState)&&(null!==(e=e.dehydrated)&&function(e,t){var n=e.ownerDocument;if("$?"!==e.data||"complete"===n.readyState)t();else{var a=function(){t(),n.removeEventListener("DOMContentLoaded",a)};n.addEventListener("DOMContentLoaded",a),e._reactRetry=a}}(e,n=fu.bind(null,n))));break;case 22:if(!(a=null!==n.memoizedState||vl)){t=null!==t&&null!==t.memoizedState||xl,r=vl;var o=xl;vl=a,(xl=t)&&!o?Bl(e,n,0!==(8772&n.subtreeFlags)):Ml(e,n),vl=r,xl=o}break;case 30:break;default:Ml(e,n)}}function Cl(e){var t=e.alternate;null!==t&&(e.alternate=null,Cl(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&We(t)),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}var Nl=null,El=!1;function Tl(e,t,n){for(n=n.child;null!==n;)Rl(e,t,n),n=n.sibling}function Rl(e,t,n){if(he&&"function"===typeof he.onCommitFiberUnmount)try{he.onCommitFiberUnmount(ue,n)}catch(o){}switch(n.tag){case 26:xl||hl(n,t),Tl(e,t,n),n.memoizedState?n.memoizedState.count--:n.stateNode&&(n=n.stateNode).parentNode.removeChild(n);break;case 27:xl||hl(n,t);var a=Nl,r=El;ph(n.type)&&(Nl=n.stateNode,El=!1),Tl(e,t,n),wh(n.stateNode),Nl=a,El=r;break;case 5:xl||hl(n,t);case 6:if(a=Nl,r=El,Nl=null,Tl(e,t,n),El=r,null!==(Nl=a))if(El)try{(9===Nl.nodeType?Nl.body:"HTML"===Nl.nodeName?Nl.ownerDocument.body:Nl).removeChild(n.stateNode)}catch(s){uu(n,t,s)}else try{Nl.removeChild(n.stateNode)}catch(s){uu(n,t,s)}break;case 18:null!==Nl&&(El?(fh(9===(e=Nl).nodeType?e.body:"HTML"===e.nodeName?e.ownerDocument.body:e,n.stateNode),Ed(e)):fh(Nl,n.stateNode));break;case 4:a=Nl,r=El,Nl=n.stateNode.containerInfo,El=!0,Tl(e,t,n),Nl=a,El=r;break;case 0:case 11:case 14:case 15:xl||il(2,n,t),xl||il(4,n,t),Tl(e,t,n);break;case 1:xl||(hl(n,t),"function"===typeof(a=n.stateNode).componentWillUnmount&&cl(n,t,a)),Tl(e,t,n);break;case 21:Tl(e,t,n);break;case 22:xl=(a=xl)||null!==n.memoizedState,Tl(e,t,n),xl=a;break;default:Tl(e,t,n)}}function Al(e,t){if(null===t.memoizedState&&(null!==(e=t.alternate)&&(null!==(e=e.memoizedState)&&null!==(e=e.dehydrated))))try{Ed(e)}catch(n){uu(t,t.return,n)}}function Fl(e,t){var n=function(e){switch(e.tag){case 13:case 19:var t=e.stateNode;return null===t&&(t=e.stateNode=new kl),t;case 22:return null===(t=(e=e.stateNode)._retryCache)&&(t=e._retryCache=new kl),t;default:throw Error(s(435,e.tag))}}(e);t.forEach((function(t){var a=gu.bind(null,e,t);n.has(t)||(n.add(t),t.then(a,a))}))}function Dl(e,t){var n=t.deletions;if(null!==n)for(var a=0;a<n.length;a++){var r=n[a],o=e,i=t,l=i;e:for(;null!==l;){switch(l.tag){case 27:if(ph(l.type)){Nl=l.stateNode,El=!1;break e}break;case 5:Nl=l.stateNode,El=!1;break e;case 3:case 4:Nl=l.stateNode.containerInfo,El=!0;break e}l=l.return}if(null===Nl)throw Error(s(160));Rl(o,i,r),Nl=null,El=!1,null!==(o=r.alternate)&&(o.return=null),r.return=null}if(13878&t.subtreeFlags)for(t=t.child;null!==t;)Ol(t,e),t=t.sibling}var _l=null;function Ol(e,t){var n=e.alternate,a=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:Dl(t,e),Ll(e),4&a&&(il(3,e,e.return),sl(3,e),il(5,e,e.return));break;case 1:Dl(t,e),Ll(e),512&a&&(xl||null===n||hl(n,n.return)),64&a&&vl&&(null!==(e=e.updateQueue)&&(null!==(a=e.callbacks)&&(n=e.shared.hiddenCallbacks,e.shared.hiddenCallbacks=null===n?a:n.concat(a))));break;case 26:var r=_l;if(Dl(t,e),Ll(e),512&a&&(xl||null===n||hl(n,n.return)),4&a){var o=null!==n?n.memoizedState:null;if(a=e.memoizedState,null===n)if(null===a)if(null===e.stateNode){e:{a=e.type,n=e.memoizedProps,r=r.ownerDocument||r;t:switch(a){case"title":(!(o=r.getElementsByTagName("title")[0])||o[Be]||o[De]||"http://www.w3.org/2000/svg"===o.namespaceURI||o.hasAttribute("itemprop"))&&(o=r.createElement(a),r.head.insertBefore(o,r.querySelector("head > title"))),eh(o,a,n),o[De]=e,He(o),a=o;break e;case"link":var i=Bh("link","href",r).get(a+(n.href||""));if(i)for(var l=0;l<i.length;l++)if((o=i[l]).getAttribute("href")===(null==n.href||""===n.href?null:n.href)&&o.getAttribute("rel")===(null==n.rel?null:n.rel)&&o.getAttribute("title")===(null==n.title?null:n.title)&&o.getAttribute("crossorigin")===(null==n.crossOrigin?null:n.crossOrigin)){i.splice(l,1);break t}eh(o=r.createElement(a),a,n),r.head.appendChild(o);break;case"meta":if(i=Bh("meta","content",r).get(a+(n.content||"")))for(l=0;l<i.length;l++)if((o=i[l]).getAttribute("content")===(null==n.content?null:""+n.content)&&o.getAttribute("name")===(null==n.name?null:n.name)&&o.getAttribute("property")===(null==n.property?null:n.property)&&o.getAttribute("http-equiv")===(null==n.httpEquiv?null:n.httpEquiv)&&o.getAttribute("charset")===(null==n.charSet?null:n.charSet)){i.splice(l,1);break t}eh(o=r.createElement(a),a,n),r.head.appendChild(o);break;default:throw Error(s(468,a))}o[De]=e,He(o),a=o}e.stateNode=a}else Wh(r,e.type,e.stateNode);else e.stateNode=Oh(r,a,e.memoizedProps);else o!==a?(null===o?null!==n.stateNode&&(n=n.stateNode).parentNode.removeChild(n):o.count--,null===a?Wh(r,e.type,e.stateNode):Oh(r,a,e.memoizedProps)):null===a&&null!==e.stateNode&&pl(e,e.memoizedProps,n.memoizedProps)}break;case 27:Dl(t,e),Ll(e),512&a&&(xl||null===n||hl(n,n.return)),null!==n&&4&a&&pl(e,e.memoizedProps,n.memoizedProps);break;case 5:if(Dl(t,e),Ll(e),512&a&&(xl||null===n||hl(n,n.return)),32&e.flags){r=e.stateNode;try{kt(r,"")}catch(f){uu(e,e.return,f)}}4&a&&null!=e.stateNode&&pl(e,r=e.memoizedProps,null!==n?n.memoizedProps:r),1024&a&&(wl=!0);break;case 6:if(Dl(t,e),Ll(e),4&a){if(null===e.stateNode)throw Error(s(162));a=e.memoizedProps,n=e.stateNode;try{n.nodeValue=a}catch(f){uu(e,e.return,f)}}break;case 3:if(Ph=null,r=_l,_l=Ih(t.containerInfo),Dl(t,e),_l=r,Ll(e),4&a&&null!==n&&n.memoizedState.isDehydrated)try{Ed(t.containerInfo)}catch(f){uu(e,e.return,f)}wl&&(wl=!1,zl(e));break;case 4:a=_l,_l=Ih(e.stateNode.containerInfo),Dl(t,e),Ll(e),_l=a;break;case 12:default:Dl(t,e),Ll(e);break;case 13:Dl(t,e),Ll(e),8192&e.child.flags&&null!==e.memoizedState!==(null!==n&&null!==n.memoizedState)&&(wc=te()),4&a&&(null!==(a=e.updateQueue)&&(e.updateQueue=null,Fl(e,a)));break;case 22:r=null!==e.memoizedState;var c=null!==n&&null!==n.memoizedState,u=vl,h=xl;if(vl=u||r,xl=h||c,Dl(t,e),xl=h,vl=u,Ll(e),8192&a)e:for(t=e.stateNode,t._visibility=r?-2&t._visibility:1|t._visibility,r&&(null===n||c||vl||xl||Pl(e)),n=null,t=e;;){if(5===t.tag||26===t.tag){if(null===n){c=n=t;try{if(o=c.stateNode,r)"function"===typeof(i=o.style).setProperty?i.setProperty("display","none","important"):i.display="none";else{l=c.stateNode;var d=c.memoizedProps.style,p=void 0!==d&&null!==d&&d.hasOwnProperty("display")?d.display:null;l.style.display=null==p||"boolean"===typeof p?"":(""+p).trim()}}catch(f){uu(c,c.return,f)}}}else if(6===t.tag){if(null===n){c=t;try{c.stateNode.nodeValue=r?"":c.memoizedProps}catch(f){uu(c,c.return,f)}}}else if((22!==t.tag&&23!==t.tag||null===t.memoizedState||t===e)&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;null===t.sibling;){if(null===t.return||t.return===e)break e;n===t&&(n=null),t=t.return}n===t&&(n=null),t.sibling.return=t.return,t=t.sibling}4&a&&(null!==(a=e.updateQueue)&&(null!==(n=a.retryQueue)&&(a.retryQueue=null,Fl(e,n))));break;case 19:Dl(t,e),Ll(e),4&a&&(null!==(a=e.updateQueue)&&(e.updateQueue=null,Fl(e,a)));case 30:case 21:}}function Ll(e){var t=e.flags;if(2&t){try{for(var n,a=e.return;null!==a;){if(fl(a)){n=a;break}a=a.return}if(null==n)throw Error(s(160));switch(n.tag){case 27:var r=n.stateNode;bl(e,gl(e),r);break;case 5:var o=n.stateNode;32&n.flags&&(kt(o,""),n.flags&=-33),bl(e,gl(e),o);break;case 3:case 4:var i=n.stateNode.containerInfo;ml(e,gl(e),i);break;default:throw Error(s(161))}}catch(l){uu(e,e.return,l)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function zl(e){if(1024&e.subtreeFlags)for(e=e.child;null!==e;){var t=e;zl(t),5===t.tag&&1024&t.flags&&t.stateNode.reset(),e=e.sibling}}function Ml(e,t){if(8772&t.subtreeFlags)for(t=t.child;null!==t;)Il(e,t.alternate,t),t=t.sibling}function Pl(e){for(e=e.child;null!==e;){var t=e;switch(t.tag){case 0:case 11:case 14:case 15:il(4,t,t.return),Pl(t);break;case 1:hl(t,t.return);var n=t.stateNode;"function"===typeof n.componentWillUnmount&&cl(t,t.return,n),Pl(t);break;case 27:wh(t.stateNode);case 26:case 5:hl(t,t.return),Pl(t);break;case 22:null===t.memoizedState&&Pl(t);break;default:Pl(t)}e=e.sibling}}function Bl(e,t,n){for(n=n&&0!==(8772&t.subtreeFlags),t=t.child;null!==t;){var a=t.alternate,r=e,o=t,s=o.flags;switch(o.tag){case 0:case 11:case 15:Bl(r,o,n),sl(4,o);break;case 1:if(Bl(r,o,n),"function"===typeof(r=(a=o).stateNode).componentDidMount)try{r.componentDidMount()}catch(c){uu(a,a.return,c)}if(null!==(r=(a=o).updateQueue)){var i=a.stateNode;try{var l=r.shared.hiddenCallbacks;if(null!==l)for(r.shared.hiddenCallbacks=null,r=0;r<l.length;r++)ho(l[r],i)}catch(c){uu(a,a.return,c)}}n&&64&s&&ll(o),ul(o,o.return);break;case 27:yl(o);case 26:case 5:Bl(r,o,n),n&&null===a&&4&s&&dl(o),ul(o,o.return);break;case 12:Bl(r,o,n);break;case 13:Bl(r,o,n),n&&4&s&&Al(r,o);break;case 22:null===o.memoizedState&&Bl(r,o,n),ul(o,o.return);break;case 30:break;default:Bl(r,o,n)}t=t.sibling}}function Wl(e,t){var n=null;null!==e&&null!==e.memoizedState&&null!==e.memoizedState.cachePool&&(n=e.memoizedState.cachePool.pool),e=null,null!==t.memoizedState&&null!==t.memoizedState.cachePool&&(e=t.memoizedState.cachePool.pool),e!==n&&(null!=e&&e.refCount++,null!=n&&Or(n))}function Ul(e,t){e=null,null!==t.alternate&&(e=t.alternate.memoizedState.cache),(t=t.memoizedState.cache)!==e&&(t.refCount++,null!=e&&Or(e))}function Vl(e,t,n,a){if(10256&t.subtreeFlags)for(t=t.child;null!==t;)Gl(e,t,n,a),t=t.sibling}function Gl(e,t,n,a){var r=t.flags;switch(t.tag){case 0:case 11:case 15:Vl(e,t,n,a),2048&r&&sl(9,t);break;case 1:case 13:default:Vl(e,t,n,a);break;case 3:Vl(e,t,n,a),2048&r&&(e=null,null!==t.alternate&&(e=t.alternate.memoizedState.cache),(t=t.memoizedState.cache)!==e&&(t.refCount++,null!=e&&Or(e)));break;case 12:if(2048&r){Vl(e,t,n,a),e=t.stateNode;try{var o=t.memoizedProps,s=o.id,i=o.onPostCommit;"function"===typeof i&&i(s,null===t.alternate?"mount":"update",e.passiveEffectDuration,-0)}catch(l){uu(t,t.return,l)}}else Vl(e,t,n,a);break;case 23:break;case 22:o=t.stateNode,s=t.alternate,null!==t.memoizedState?2&o._visibility?Vl(e,t,n,a):Hl(e,t):2&o._visibility?Vl(e,t,n,a):(o._visibility|=2,jl(e,t,n,a,0!==(10256&t.subtreeFlags))),2048&r&&Wl(s,t);break;case 24:Vl(e,t,n,a),2048&r&&Ul(t.alternate,t)}}function jl(e,t,n,a,r){for(r=r&&0!==(10256&t.subtreeFlags),t=t.child;null!==t;){var o=e,s=t,i=n,l=a,c=s.flags;switch(s.tag){case 0:case 11:case 15:jl(o,s,i,l,r),sl(8,s);break;case 23:break;case 22:var u=s.stateNode;null!==s.memoizedState?2&u._visibility?jl(o,s,i,l,r):Hl(o,s):(u._visibility|=2,jl(o,s,i,l,r)),r&&2048&c&&Wl(s.alternate,s);break;case 24:jl(o,s,i,l,r),r&&2048&c&&Ul(s.alternate,s);break;default:jl(o,s,i,l,r)}t=t.sibling}}function Hl(e,t){if(10256&t.subtreeFlags)for(t=t.child;null!==t;){var n=e,a=t,r=a.flags;switch(a.tag){case 22:Hl(n,a),2048&r&&Wl(a.alternate,a);break;case 24:Hl(n,a),2048&r&&Ul(a.alternate,a);break;default:Hl(n,a)}t=t.sibling}}var Kl=8192;function ql(e){if(e.subtreeFlags&Kl)for(e=e.child;null!==e;)Xl(e),e=e.sibling}function Xl(e){switch(e.tag){case 26:ql(e),e.flags&Kl&&null!==e.memoizedState&&function(e,t,n){if(null===Vh)throw Error(s(475));var a=Vh;if("stylesheet"===t.type&&("string"!==typeof n.media||!1!==matchMedia(n.media).matches)&&0===(4&t.state.loading)){if(null===t.instance){var r=Rh(n.href),o=e.querySelector(Ah(r));if(o)return null!==(e=o._p)&&"object"===typeof e&&"function"===typeof e.then&&(a.count++,a=jh.bind(a),e.then(a,a)),t.state.loading|=4,t.instance=o,void He(o);o=e.ownerDocument||e,n=Fh(n),(r=kh.get(r))&&zh(n,r),He(o=o.createElement("link"));var i=o;i._p=new Promise((function(e,t){i.onload=e,i.onerror=t})),eh(o,"link",n),t.instance=o}null===a.stylesheets&&(a.stylesheets=new Map),a.stylesheets.set(t,e),(e=t.state.preload)&&0===(3&t.state.loading)&&(a.count++,t=jh.bind(a),e.addEventListener("load",t),e.addEventListener("error",t))}}(_l,e.memoizedState,e.memoizedProps);break;case 5:default:ql(e);break;case 3:case 4:var t=_l;_l=Ih(e.stateNode.containerInfo),ql(e),_l=t;break;case 22:null===e.memoizedState&&(null!==(t=e.alternate)&&null!==t.memoizedState?(t=Kl,Kl=16777216,ql(e),Kl=t):ql(e))}}function Yl(e){var t=e.alternate;if(null!==t&&null!==(e=t.child)){t.child=null;do{t=e.sibling,e.sibling=null,e=t}while(null!==e)}}function Jl(e){var t=e.deletions;if(0!==(16&e.flags)){if(null!==t)for(var n=0;n<t.length;n++){var a=t[n];Sl=a,Zl(a,e)}Yl(e)}if(10256&e.subtreeFlags)for(e=e.child;null!==e;)$l(e),e=e.sibling}function $l(e){switch(e.tag){case 0:case 11:case 15:Jl(e),2048&e.flags&&il(9,e,e.return);break;case 3:case 12:default:Jl(e);break;case 22:var t=e.stateNode;null!==e.memoizedState&&2&t._visibility&&(null===e.return||13!==e.return.tag)?(t._visibility&=-3,Ql(e)):Jl(e)}}function Ql(e){var t=e.deletions;if(0!==(16&e.flags)){if(null!==t)for(var n=0;n<t.length;n++){var a=t[n];Sl=a,Zl(a,e)}Yl(e)}for(e=e.child;null!==e;){switch((t=e).tag){case 0:case 11:case 15:il(8,t,t.return),Ql(t);break;case 22:2&(n=t.stateNode)._visibility&&(n._visibility&=-3,Ql(t));break;default:Ql(t)}e=e.sibling}}function Zl(e,t){for(;null!==Sl;){var n=Sl;switch(n.tag){case 0:case 11:case 15:il(8,n,t);break;case 23:case 22:if(null!==n.memoizedState&&null!==n.memoizedState.cachePool){var a=n.memoizedState.cachePool.pool;null!=a&&a.refCount++}break;case 24:Or(n.memoizedState.cache)}if(null!==(a=n.child))a.return=n,Sl=a;else e:for(n=e;null!==Sl;){var r=(a=Sl).sibling,o=a.return;if(Cl(a),a===n){Sl=null;break e}if(null!==r){r.return=o,Sl=r;break e}Sl=o}}}var ec={getCacheForType:function(e){var t=Nr(Dr),n=t.data.get(e);return void 0===n&&(n=e(),t.data.set(e,n)),n}},tc="function"===typeof WeakMap?WeakMap:Map,nc=0,ac=null,rc=null,oc=0,sc=0,ic=null,lc=!1,cc=!1,uc=!1,hc=0,dc=0,pc=0,fc=0,gc=0,mc=0,bc=0,yc=null,vc=null,xc=!1,wc=0,kc=1/0,Sc=null,Ic=null,Cc=0,Nc=null,Ec=null,Tc=0,Rc=0,Ac=null,Fc=null,Dc=0,_c=null;function Oc(){if(0!==(2&nc)&&0!==oc)return oc&-oc;if(null!==O.T){return 0!==Mr?Mr:Ru()}return Ae()}function Lc(){0===mc&&(mc=0===(536870912&oc)||or?ke():536870912);var e=ri.current;return null!==e&&(e.flags|=32),mc}function zc(e,t,n){(e!==ac||2!==sc&&9!==sc)&&null===e.cancelPendingCommit||(Gc(e,0),Wc(e,oc,mc,!1)),Ce(e,n),0!==(2&nc)&&e===ac||(e===ac&&(0===(2&nc)&&(fc|=n),4===dc&&Wc(e,oc,mc,!1)),ku(e))}function Mc(e,t,n){if(0!==(6&nc))throw Error(s(327));for(var a=!n&&0===(124&t)&&0===(t&e.expiredLanes)||xe(e,t),r=a?function(e,t){var n=nc;nc|=2;var a=Hc(),r=Kc();ac!==e||oc!==t?(Sc=null,kc=te()+500,Gc(e,t)):cc=xe(e,t);e:for(;;)try{if(0!==sc&&null!==rc){t=rc;var o=ic;t:switch(sc){case 1:sc=0,ic=null,Zc(e,t,o,1);break;case 2:case 9:if(Yr(o)){sc=0,ic=null,Qc(t);break}t=function(){2!==sc&&9!==sc||ac!==e||(sc=7),ku(e)},o.then(t,t);break e;case 3:sc=7;break e;case 4:sc=5;break e;case 7:Yr(o)?(sc=0,ic=null,Qc(t)):(sc=0,ic=null,Zc(e,t,o,7));break;case 5:var i=null;switch(rc.tag){case 26:i=rc.memoizedState;case 5:case 27:var l=rc;if(!i||Uh(i)){sc=0,ic=null;var c=l.sibling;if(null!==c)rc=c;else{var u=l.return;null!==u?(rc=u,eu(u)):rc=null}break t}}sc=0,ic=null,Zc(e,t,o,5);break;case 6:sc=0,ic=null,Zc(e,t,o,6);break;case 8:Vc(),dc=6;break e;default:throw Error(s(462))}}Jc();break}catch(h){jc(e,h)}return yr=br=null,O.H=a,O.A=r,nc=n,null!==rc?0:(ac=null,oc=0,Ta(),dc)}(e,t):Xc(e,t,!0),o=a;;){if(0===r){cc&&!a&&Wc(e,t,0,!1);break}if(n=e.current.alternate,!o||Bc(n)){if(2===r){if(o=t,e.errorRecoveryDisabledLanes&o)var i=0;else i=0!==(i=-536870913&e.pendingLanes)?i:536870912&i?536870912:0;if(0!==i){t=i;e:{var l=e;r=yc;var c=l.current.memoizedState.isDehydrated;if(c&&(Gc(l,i).flags|=256),2!==(i=Xc(l,i,!1))){if(uc&&!c){l.errorRecoveryDisabledLanes|=o,fc|=o,r=4;break e}o=vc,vc=r,null!==o&&(null===vc?vc=o:vc.push.apply(vc,o))}r=i}if(o=!1,2!==r)continue}}if(1===r){Gc(e,0),Wc(e,t,0,!0);break}e:{switch(a=e,o=r){case 0:case 1:throw Error(s(345));case 4:if((4194048&t)!==t)break;case 6:Wc(a,t,mc,!lc);break e;case 2:vc=null;break;case 3:case 5:break;default:throw Error(s(329))}if((62914560&t)===t&&10<(r=wc+300-te())){if(Wc(a,t,mc,!lc),0!==ve(a,0,!0))break e;a.timeoutHandle=lh(Pc.bind(null,a,n,vc,Sc,xc,t,mc,fc,bc,lc,o,2,-0,0),r)}else Pc(a,n,vc,Sc,xc,t,mc,fc,bc,lc,o,0,-0,0)}break}r=Xc(e,t,!1),o=!1}ku(e)}function Pc(e,t,n,a,r,o,i,l,c,u,h,d,p,f){if(e.timeoutHandle=-1,(8192&(d=t.subtreeFlags)||16785408===(16785408&d))&&(Vh={stylesheets:null,count:0,unsuspend:Gh},Xl(t),null!==(d=function(){if(null===Vh)throw Error(s(475));var e=Vh;return e.stylesheets&&0===e.count&&Kh(e,e.stylesheets),0<e.count?function(t){var n=setTimeout((function(){if(e.stylesheets&&Kh(e,e.stylesheets),e.unsuspend){var t=e.unsuspend;e.unsuspend=null,t()}}),6e4);return e.unsuspend=t,function(){e.unsuspend=null,clearTimeout(n)}}:null}())))return e.cancelPendingCommit=d(nu.bind(null,e,t,o,n,a,r,i,l,c,h,1,p,f)),void Wc(e,o,i,!u);nu(e,t,o,n,a,r,i,l,c)}function Bc(e){for(var t=e;;){var n=t.tag;if((0===n||11===n||15===n)&&16384&t.flags&&(null!==(n=t.updateQueue)&&null!==(n=n.stores)))for(var a=0;a<n.length;a++){var r=n[a],o=r.getSnapshot;r=r.value;try{if(!Yn(o(),r))return!1}catch(s){return!1}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Wc(e,t,n,a){t&=~gc,t&=~fc,e.suspendedLanes|=t,e.pingedLanes&=~t,a&&(e.warmLanes|=t),a=e.expirationTimes;for(var r=t;0<r;){var o=31-pe(r),s=1<<o;a[o]=-1,r&=~s}0!==n&&Ne(e,n,t)}function Uc(){return 0!==(6&nc)||(Su(0,!1),!1)}function Vc(){if(null!==rc){if(0===sc)var e=rc.return;else yr=br=null,Po(e=rc),Ys=null,Js=0,e=rc;for(;null!==e;)ol(e.alternate,e),e=e.return;rc=null}}function Gc(e,t){var n=e.timeoutHandle;-1!==n&&(e.timeoutHandle=-1,ch(n)),null!==(n=e.cancelPendingCommit)&&(e.cancelPendingCommit=null,n()),Vc(),ac=e,rc=n=Pa(e.current,null),oc=t,sc=0,ic=null,lc=!1,cc=xe(e,t),uc=!1,bc=mc=gc=fc=pc=dc=0,vc=yc=null,xc=!1,0!==(8&t)&&(t|=32&t);var a=e.entangledLanes;if(0!==a)for(e=e.entanglements,a&=t;0<a;){var r=31-pe(a),o=1<<r;t|=e[r],a&=~o}return hc=t,Ta(),n}function jc(e,t){xo=null,O.H=Hs,t===Hr||t===qr?(t=Zr(),sc=3):t===Kr?(t=Zr(),sc=4):sc=t===Ni?8:null!==t&&"object"===typeof t&&"function"===typeof t.then?6:1,ic=t,null===rc&&(dc=1,wi(e,Ia(t,e.current)))}function Hc(){var e=O.H;return O.H=Hs,null===e?Hs:e}function Kc(){var e=O.A;return O.A=ec,e}function qc(){dc=4,lc||(4194048&oc)!==oc&&null!==ri.current||(cc=!0),0===(134217727&pc)&&0===(134217727&fc)||null===ac||Wc(ac,oc,mc,!1)}function Xc(e,t,n){var a=nc;nc|=2;var r=Hc(),o=Kc();ac===e&&oc===t||(Sc=null,Gc(e,t)),t=!1;var s=dc;e:for(;;)try{if(0!==sc&&null!==rc){var i=rc,l=ic;switch(sc){case 8:Vc(),s=6;break e;case 3:case 2:case 9:case 6:null===ri.current&&(t=!0);var c=sc;if(sc=0,ic=null,Zc(e,i,l,c),n&&cc){s=0;break e}break;default:c=sc,sc=0,ic=null,Zc(e,i,l,c)}}Yc(),s=dc;break}catch(u){jc(e,u)}return t&&e.shellSuspendCounter++,yr=br=null,nc=a,O.H=r,O.A=o,null===rc&&(ac=null,oc=0,Ta()),s}function Yc(){for(;null!==rc;)$c(rc)}function Jc(){for(;null!==rc&&!Z();)$c(rc)}function $c(e){var t=$i(e.alternate,e,hc);e.memoizedProps=e.pendingProps,null===t?eu(e):rc=t}function Qc(e){var t=e,n=t.alternate;switch(t.tag){case 15:case 0:t=zi(n,t,t.pendingProps,t.type,void 0,oc);break;case 11:t=zi(n,t,t.pendingProps,t.type.render,t.ref,oc);break;case 5:Po(t);default:ol(n,t),t=$i(n,t=rc=Ba(t,hc),hc)}e.memoizedProps=e.pendingProps,null===t?eu(e):rc=t}function Zc(e,t,n,a){yr=br=null,Po(t),Ys=null,Js=0;var r=t.return;try{if(function(e,t,n,a,r){if(n.flags|=32768,null!==a&&"object"===typeof a&&"function"===typeof a.then){if(null!==(t=n.alternate)&&Sr(t,n,r,!0),null!==(n=ri.current)){switch(n.tag){case 13:return null===oi?qc():null===n.alternate&&0===dc&&(dc=3),n.flags&=-257,n.flags|=65536,n.lanes=r,a===Xr?n.flags|=16384:(null===(t=n.updateQueue)?n.updateQueue=new Set([a]):t.add(a),hu(e,a,r)),!1;case 22:return n.flags|=65536,a===Xr?n.flags|=16384:(null===(t=n.updateQueue)?(t={transitions:null,markerInstances:null,retryQueue:new Set([a])},n.updateQueue=t):null===(n=t.retryQueue)?t.retryQueue=new Set([a]):n.add(a),hu(e,a,r)),!1}throw Error(s(435,n.tag))}return hu(e,a,r),qc(),!1}if(or)return null!==(t=ri.current)?(0===(65536&t.flags)&&(t.flags|=256),t.flags|=65536,t.lanes=r,a!==lr&&gr(Ia(e=Error(s(422),{cause:a}),n))):(a!==lr&&gr(Ia(t=Error(s(423),{cause:a}),n)),(e=e.current.alternate).flags|=65536,r&=-r,e.lanes|=r,a=Ia(a,n),io(e,r=Si(e.stateNode,a,r)),4!==dc&&(dc=2)),!1;var o=Error(s(520),{cause:a});if(o=Ia(o,n),null===yc?yc=[o]:yc.push(o),4!==dc&&(dc=2),null===t)return!0;a=Ia(a,n),n=t;do{switch(n.tag){case 3:return n.flags|=65536,e=r&-r,n.lanes|=e,io(n,e=Si(n.stateNode,a,e)),!1;case 1:if(t=n.type,o=n.stateNode,0===(128&n.flags)&&("function"===typeof t.getDerivedStateFromError||null!==o&&"function"===typeof o.componentDidCatch&&(null===Ic||!Ic.has(o))))return n.flags|=65536,r&=-r,n.lanes|=r,Ci(r=Ii(r),e,n,a),io(n,r),!1}n=n.return}while(null!==n);return!1}(e,r,t,n,oc))return dc=1,wi(e,Ia(n,e.current)),void(rc=null)}catch(o){if(null!==r)throw rc=r,o;return dc=1,wi(e,Ia(n,e.current)),void(rc=null)}32768&t.flags?(or||1===a?e=!0:cc||0!==(536870912&oc)?e=!1:(lc=e=!0,(2===a||9===a||3===a||6===a)&&(null!==(a=ri.current)&&13===a.tag&&(a.flags|=16384))),tu(t,e)):eu(t)}function eu(e){var t=e;do{if(0!==(32768&t.flags))return void tu(t,lc);e=t.return;var n=al(t.alternate,t,hc);if(null!==n)return void(rc=n);if(null!==(t=t.sibling))return void(rc=t);rc=t=e}while(null!==t);0===dc&&(dc=5)}function tu(e,t){do{var n=rl(e.alternate,e);if(null!==n)return n.flags&=32767,void(rc=n);if(null!==(n=e.return)&&(n.flags|=32768,n.subtreeFlags=0,n.deletions=null),!t&&null!==(e=e.sibling))return void(rc=e);rc=e=n}while(null!==e);dc=6,rc=null}function nu(e,t,n,a,r,o,i,l,c){e.cancelPendingCommit=null;do{iu()}while(0!==Cc);if(0!==(6&nc))throw Error(s(327));if(null!==t){if(t===e.current)throw Error(s(177));if(o=t.lanes|t.childLanes,function(e,t,n,a,r,o){var s=e.pendingLanes;e.pendingLanes=n,e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0,e.expiredLanes&=n,e.entangledLanes&=n,e.errorRecoveryDisabledLanes&=n,e.shellSuspendCounter=0;var i=e.entanglements,l=e.expirationTimes,c=e.hiddenUpdates;for(n=s&~n;0<n;){var u=31-pe(n),h=1<<u;i[u]=0,l[u]=-1;var d=c[u];if(null!==d)for(c[u]=null,u=0;u<d.length;u++){var p=d[u];null!==p&&(p.lane&=-536870913)}n&=~h}0!==a&&Ne(e,a,0),0!==o&&0===r&&0!==e.tag&&(e.suspendedLanes|=o&~(s&~t))}(e,n,o|=Ea,i,l,c),e===ac&&(rc=ac=null,oc=0),Ec=t,Nc=e,Tc=n,Rc=o,Ac=r,Fc=a,0!==(10256&t.subtreeFlags)||0!==(10256&t.flags)?(e.callbackNode=null,e.callbackPriority=0,$(oe,(function(){return lu(),null}))):(e.callbackNode=null,e.callbackPriority=0),a=0!==(13878&t.flags),0!==(13878&t.subtreeFlags)||a){a=O.T,O.T=null,r=L.p,L.p=2,i=nc,nc|=4;try{!function(e,t){if(e=e.containerInfo,th=nd,ta(e=ea(e))){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var a=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(a&&0!==a.rangeCount){n=a.anchorNode;var r=a.anchorOffset,o=a.focusNode;a=a.focusOffset;try{n.nodeType,o.nodeType}catch(m){n=null;break e}var i=0,l=-1,c=-1,u=0,h=0,d=e,p=null;t:for(;;){for(var f;d!==n||0!==r&&3!==d.nodeType||(l=i+r),d!==o||0!==a&&3!==d.nodeType||(c=i+a),3===d.nodeType&&(i+=d.nodeValue.length),null!==(f=d.firstChild);)p=d,d=f;for(;;){if(d===e)break t;if(p===n&&++u===r&&(l=i),p===o&&++h===a&&(c=i),null!==(f=d.nextSibling))break;p=(d=p).parentNode}d=f}n=-1===l||-1===c?null:{start:l,end:c}}else n=null}n=n||{start:0,end:0}}else n=null;for(nh={focusedElem:e,selectionRange:n},nd=!1,Sl=t;null!==Sl;)if(e=(t=Sl).child,0!==(1024&t.subtreeFlags)&&null!==e)e.return=t,Sl=e;else for(;null!==Sl;){switch(o=(t=Sl).alternate,e=t.flags,t.tag){case 0:case 11:case 15:case 5:case 26:case 27:case 6:case 4:case 17:break;case 1:if(0!==(1024&e)&&null!==o){e=void 0,n=t,r=o.memoizedProps,o=o.memoizedState,a=n.stateNode;try{var g=mi(n.type,r,(n.elementType,n.type));e=a.getSnapshotBeforeUpdate(g,o),a.__reactInternalSnapshotBeforeUpdate=e}catch(b){uu(n,n.return,b)}}break;case 3:if(0!==(1024&e))if(9===(n=(e=t.stateNode.containerInfo).nodeType))gh(e);else if(1===n)switch(e.nodeName){case"HEAD":case"HTML":case"BODY":gh(e);break;default:e.textContent=""}break;default:if(0!==(1024&e))throw Error(s(163))}if(null!==(e=t.sibling)){e.return=t.return,Sl=e;break}Sl=t.return}}(e,t)}finally{nc=i,L.p=r,O.T=a}}Cc=1,au(),ru(),ou()}}function au(){if(1===Cc){Cc=0;var e=Nc,t=Ec,n=0!==(13878&t.flags);if(0!==(13878&t.subtreeFlags)||n){n=O.T,O.T=null;var a=L.p;L.p=2;var r=nc;nc|=4;try{Ol(t,e);var o=nh,s=ea(e.containerInfo),i=o.focusedElem,l=o.selectionRange;if(s!==i&&i&&i.ownerDocument&&Zn(i.ownerDocument.documentElement,i)){if(null!==l&&ta(i)){var c=l.start,u=l.end;if(void 0===u&&(u=c),"selectionStart"in i)i.selectionStart=c,i.selectionEnd=Math.min(u,i.value.length);else{var h=i.ownerDocument||document,d=h&&h.defaultView||window;if(d.getSelection){var p=d.getSelection(),f=i.textContent.length,g=Math.min(l.start,f),m=void 0===l.end?g:Math.min(l.end,f);!p.extend&&g>m&&(s=m,m=g,g=s);var b=Qn(i,g),y=Qn(i,m);if(b&&y&&(1!==p.rangeCount||p.anchorNode!==b.node||p.anchorOffset!==b.offset||p.focusNode!==y.node||p.focusOffset!==y.offset)){var v=h.createRange();v.setStart(b.node,b.offset),p.removeAllRanges(),g>m?(p.addRange(v),p.extend(y.node,y.offset)):(v.setEnd(y.node,y.offset),p.addRange(v))}}}}for(h=[],p=i;p=p.parentNode;)1===p.nodeType&&h.push({element:p,left:p.scrollLeft,top:p.scrollTop});for("function"===typeof i.focus&&i.focus(),i=0;i<h.length;i++){var x=h[i];x.element.scrollLeft=x.left,x.element.scrollTop=x.top}}nd=!!th,nh=th=null}finally{nc=r,L.p=a,O.T=n}}e.current=t,Cc=2}}function ru(){if(2===Cc){Cc=0;var e=Nc,t=Ec,n=0!==(8772&t.flags);if(0!==(8772&t.subtreeFlags)||n){n=O.T,O.T=null;var a=L.p;L.p=2;var r=nc;nc|=4;try{Il(e,t.alternate,t)}finally{nc=r,L.p=a,O.T=n}}Cc=3}}function ou(){if(4===Cc||3===Cc){Cc=0,ee();var e=Nc,t=Ec,n=Tc,a=Fc;0!==(10256&t.subtreeFlags)||0!==(10256&t.flags)?Cc=5:(Cc=0,Ec=Nc=null,su(e,e.pendingLanes));var r=e.pendingLanes;if(0===r&&(Ic=null),Re(n),t=t.stateNode,he&&"function"===typeof he.onCommitFiberRoot)try{he.onCommitFiberRoot(ue,t,void 0,128===(128&t.current.flags))}catch(l){}if(null!==a){t=O.T,r=L.p,L.p=2,O.T=null;try{for(var o=e.onRecoverableError,s=0;s<a.length;s++){var i=a[s];o(i.value,{componentStack:i.stack})}}finally{O.T=t,L.p=r}}0!==(3&Tc)&&iu(),ku(e),r=e.pendingLanes,0!==(4194090&n)&&0!==(42&r)?e===_c?Dc++:(Dc=0,_c=e):Dc=0,Su(0,!1)}}function su(e,t){0===(e.pooledCacheLanes&=t)&&(null!=(t=e.pooledCache)&&(e.pooledCache=null,Or(t)))}function iu(e){return au(),ru(),ou(),lu()}function lu(){if(5!==Cc)return!1;var e=Nc,t=Rc;Rc=0;var n=Re(Tc),a=O.T,r=L.p;try{L.p=32>n?32:n,O.T=null,n=Ac,Ac=null;var o=Nc,i=Tc;if(Cc=0,Ec=Nc=null,Tc=0,0!==(6&nc))throw Error(s(331));var l=nc;if(nc|=4,$l(o.current),Gl(o,o.current,i,n),nc=l,Su(0,!1),he&&"function"===typeof he.onPostCommitFiberRoot)try{he.onPostCommitFiberRoot(ue,o)}catch(c){}return!0}finally{L.p=r,O.T=a,su(e,t)}}function cu(e,t,n){t=Ia(n,t),null!==(e=oo(e,t=Si(e.stateNode,t,2),2))&&(Ce(e,2),ku(e))}function uu(e,t,n){if(3===e.tag)cu(e,e,n);else for(;null!==t;){if(3===t.tag){cu(t,e,n);break}if(1===t.tag){var a=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof a.componentDidCatch&&(null===Ic||!Ic.has(a))){e=Ia(n,e),null!==(a=oo(t,n=Ii(2),2))&&(Ci(n,a,t,e),Ce(a,2),ku(a));break}}t=t.return}}function hu(e,t,n){var a=e.pingCache;if(null===a){a=e.pingCache=new tc;var r=new Set;a.set(t,r)}else void 0===(r=a.get(t))&&(r=new Set,a.set(t,r));r.has(n)||(uc=!0,r.add(n),e=du.bind(null,e,t,n),t.then(e,e))}function du(e,t,n){var a=e.pingCache;null!==a&&a.delete(t),e.pingedLanes|=e.suspendedLanes&n,e.warmLanes&=~n,ac===e&&(oc&n)===n&&(4===dc||3===dc&&(62914560&oc)===oc&&300>te()-wc?0===(2&nc)&&Gc(e,0):gc|=n,bc===oc&&(bc=0)),ku(e)}function pu(e,t){0===t&&(t=Se()),null!==(e=Fa(e,t))&&(Ce(e,t),ku(e))}function fu(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),pu(e,n)}function gu(e,t){var n=0;switch(e.tag){case 13:var a=e.stateNode,r=e.memoizedState;null!==r&&(n=r.retryLane);break;case 19:a=e.stateNode;break;case 22:a=e.stateNode._retryCache;break;default:throw Error(s(314))}null!==a&&a.delete(t),pu(e,n)}var mu=null,bu=null,yu=!1,vu=!1,xu=!1,wu=0;function ku(e){e!==bu&&null===e.next&&(null===bu?mu=bu=e:bu=bu.next=e),vu=!0,yu||(yu=!0,hh((function(){0!==(6&nc)?$(ae,Iu):Cu()})))}function Su(e,t){if(!xu&&vu){xu=!0;do{for(var n=!1,a=mu;null!==a;){if(!t)if(0!==e){var r=a.pendingLanes;if(0===r)var o=0;else{var s=a.suspendedLanes,i=a.pingedLanes;o=(1<<31-pe(42|e)+1)-1,o=201326741&(o&=r&~(s&~i))?201326741&o|1:o?2|o:0}0!==o&&(n=!0,Tu(a,o))}else o=oc,0===(3&(o=ve(a,a===ac?o:0,null!==a.cancelPendingCommit||-1!==a.timeoutHandle)))||xe(a,o)||(n=!0,Tu(a,o));a=a.next}}while(n);xu=!1}}function Iu(){Cu()}function Cu(){vu=yu=!1;var e=0;0!==wu&&(function(){var e=window.event;if(e&&"popstate"===e.type)return e!==ih&&(ih=e,!0);return ih=null,!1}()&&(e=wu),wu=0);for(var t=te(),n=null,a=mu;null!==a;){var r=a.next,o=Nu(a,t);0===o?(a.next=null,null===n?mu=r:n.next=r,null===r&&(bu=n)):(n=a,(0!==e||0!==(3&o))&&(vu=!0)),a=r}Su(e,!1)}function Nu(e,t){for(var n=e.suspendedLanes,a=e.pingedLanes,r=e.expirationTimes,o=-62914561&e.pendingLanes;0<o;){var s=31-pe(o),i=1<<s,l=r[s];-1===l?0!==(i&n)&&0===(i&a)||(r[s]=we(i,t)):l<=t&&(e.expiredLanes|=i),o&=~i}if(n=oc,n=ve(e,e===(t=ac)?n:0,null!==e.cancelPendingCommit||-1!==e.timeoutHandle),a=e.callbackNode,0===n||e===t&&(2===sc||9===sc)||null!==e.cancelPendingCommit)return null!==a&&null!==a&&Q(a),e.callbackNode=null,e.callbackPriority=0;if(0===(3&n)||xe(e,n)){if((t=n&-n)===e.callbackPriority)return t;switch(null!==a&&Q(a),Re(n)){case 2:case 8:n=re;break;case 32:default:n=oe;break;case 268435456:n=ie}return a=Eu.bind(null,e),n=$(n,a),e.callbackPriority=t,e.callbackNode=n,t}return null!==a&&null!==a&&Q(a),e.callbackPriority=2,e.callbackNode=null,2}function Eu(e,t){if(0!==Cc&&5!==Cc)return e.callbackNode=null,e.callbackPriority=0,null;var n=e.callbackNode;if(iu()&&e.callbackNode!==n)return null;var a=oc;return 0===(a=ve(e,e===ac?a:0,null!==e.cancelPendingCommit||-1!==e.timeoutHandle))?null:(Mc(e,a,t),Nu(e,te()),null!=e.callbackNode&&e.callbackNode===n?Eu.bind(null,e):null)}function Tu(e,t){if(iu())return null;Mc(e,t,!0)}function Ru(){return 0===wu&&(wu=ke()),wu}function Au(e){return null==e||"symbol"===typeof e||"boolean"===typeof e?null:"function"===typeof e?e:Rt(""+e)}function Fu(e,t){var n=t.ownerDocument.createElement("input");return n.name=t.name,n.value=t.value,e.id&&n.setAttribute("form",e.id),t.parentNode.insertBefore(n,t),e=new FormData(e),n.parentNode.removeChild(n),e}for(var Du=0;Du<wa.length;Du++){var _u=wa[Du];ka(_u.toLowerCase(),"on"+(_u[0].toUpperCase()+_u.slice(1)))}ka(pa,"onAnimationEnd"),ka(fa,"onAnimationIteration"),ka(ga,"onAnimationStart"),ka("dblclick","onDoubleClick"),ka("focusin","onFocus"),ka("focusout","onBlur"),ka(ma,"onTransitionRun"),ka(ba,"onTransitionStart"),ka(ya,"onTransitionCancel"),ka(va,"onTransitionEnd"),Ye("onMouseEnter",["mouseout","mouseover"]),Ye("onMouseLeave",["mouseout","mouseover"]),Ye("onPointerEnter",["pointerout","pointerover"]),Ye("onPointerLeave",["pointerout","pointerover"]),Xe("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Xe("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Xe("onBeforeInput",["compositionend","keypress","textInput","paste"]),Xe("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Xe("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Xe("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Ou="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Lu=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Ou));function zu(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var a=e[n],r=a.event;a=a.listeners;e:{var o=void 0;if(t)for(var s=a.length-1;0<=s;s--){var i=a[s],l=i.instance,c=i.currentTarget;if(i=i.listener,l!==o&&r.isPropagationStopped())break e;o=i,r.currentTarget=c;try{o(r)}catch(u){bi(u)}r.currentTarget=null,o=l}else for(s=0;s<a.length;s++){if(l=(i=a[s]).instance,c=i.currentTarget,i=i.listener,l!==o&&r.isPropagationStopped())break e;o=i,r.currentTarget=c;try{o(r)}catch(u){bi(u)}r.currentTarget=null,o=l}}}}function Mu(e,t){var n=t[Le];void 0===n&&(n=t[Le]=new Set);var a=e+"__bubble";n.has(a)||(Uu(t,e,2,!1),n.add(a))}function Pu(e,t,n){var a=0;t&&(a|=4),Uu(n,e,a,t)}var Bu="_reactListening"+Math.random().toString(36).slice(2);function Wu(e){if(!e[Bu]){e[Bu]=!0,Ke.forEach((function(t){"selectionchange"!==t&&(Lu.has(t)||Pu(t,!1,e),Pu(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Bu]||(t[Bu]=!0,Pu("selectionchange",!1,t))}}function Uu(e,t,n,a){switch(cd(t)){case 2:var r=ad;break;case 8:r=rd;break;default:r=od}n=r.bind(null,t,n,e),r=void 0,!Bt||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(r=!0),a?void 0!==r?e.addEventListener(t,n,{capture:!0,passive:r}):e.addEventListener(t,n,!0):void 0!==r?e.addEventListener(t,n,{passive:r}):e.addEventListener(t,n,!1)}function Vu(e,t,n,a,r){var o=a;if(0===(1&t)&&0===(2&t)&&null!==a)e:for(;;){if(null===a)return;var s=a.tag;if(3===s||4===s){var i=a.stateNode.containerInfo;if(i===r)break;if(4===s)for(s=a.return;null!==s;){var c=s.tag;if((3===c||4===c)&&s.stateNode.containerInfo===r)return;s=s.return}for(;null!==i;){if(null===(s=Ue(i)))return;if(5===(c=s.tag)||6===c||26===c||27===c){a=o=s;continue e}i=i.parentNode}}a=a.return}zt((function(){var a=o,r=Ft(n),s=[];e:{var i=xa.get(e);if(void 0!==i){var c=Zt,u=e;switch(e){case"keypress":if(0===Ht(n))break e;case"keydown":case"keyup":c=gn;break;case"focusin":u="focus",c=on;break;case"focusout":u="blur",c=on;break;case"beforeblur":case"afterblur":c=on;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":c=an;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":c=rn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":c=bn;break;case pa:case fa:case ga:c=sn;break;case va:c=yn;break;case"scroll":case"scrollend":c=tn;break;case"wheel":c=vn;break;case"copy":case"cut":case"paste":c=ln;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":c=mn;break;case"toggle":case"beforetoggle":c=xn}var h=0!==(4&t),d=!h&&("scroll"===e||"scrollend"===e),p=h?null!==i?i+"Capture":null:i;h=[];for(var f,g=a;null!==g;){var m=g;if(f=m.stateNode,5!==(m=m.tag)&&26!==m&&27!==m||null===f||null===p||null!=(m=Mt(g,p))&&h.push(Gu(g,m,f)),d)break;g=g.return}0<h.length&&(i=new c(i,u,null,n,r),s.push({event:i,listeners:h}))}}if(0===(7&t)){if(c="mouseout"===e||"pointerout"===e,(!(i="mouseover"===e||"pointerover"===e)||n===At||!(u=n.relatedTarget||n.fromElement)||!Ue(u)&&!u[Oe])&&(c||i)&&(i=r.window===r?r:(i=r.ownerDocument)?i.defaultView||i.parentWindow:window,c?(c=a,null!==(u=(u=n.relatedTarget||n.toElement)?Ue(u):null)&&(d=l(u),h=u.tag,u!==d||5!==h&&27!==h&&6!==h)&&(u=null)):(c=null,u=a),c!==u)){if(h=an,m="onMouseLeave",p="onMouseEnter",g="mouse","pointerout"!==e&&"pointerover"!==e||(h=mn,m="onPointerLeave",p="onPointerEnter",g="pointer"),d=null==c?i:Ge(c),f=null==u?i:Ge(u),(i=new h(m,g+"leave",c,n,r)).target=d,i.relatedTarget=f,m=null,Ue(r)===a&&((h=new h(p,g+"enter",u,n,r)).target=f,h.relatedTarget=d,m=h),d=m,c&&u)e:{for(p=u,g=0,f=h=c;f;f=Hu(f))g++;for(f=0,m=p;m;m=Hu(m))f++;for(;0<g-f;)h=Hu(h),g--;for(;0<f-g;)p=Hu(p),f--;for(;g--;){if(h===p||null!==p&&h===p.alternate)break e;h=Hu(h),p=Hu(p)}h=null}else h=null;null!==c&&Ku(s,i,c,h,!1),null!==u&&null!==d&&Ku(s,d,u,h,!0)}if("select"===(c=(i=a?Ge(a):window).nodeName&&i.nodeName.toLowerCase())||"input"===c&&"file"===i.type)var b=Pn;else if(Dn(i))if(Bn)b=Xn;else{b=Kn;var y=Hn}else!(c=i.nodeName)||"input"!==c.toLowerCase()||"checkbox"!==i.type&&"radio"!==i.type?a&&Nt(a.elementType)&&(b=Pn):b=qn;switch(b&&(b=b(e,a))?_n(s,b,n,r):(y&&y(e,i,a),"focusout"===e&&a&&"number"===i.type&&null!=a.memoizedProps.value&&yt(i,"number",i.value)),y=a?Ge(a):window,e){case"focusin":(Dn(y)||"true"===y.contentEditable)&&(aa=y,ra=a,oa=null);break;case"focusout":oa=ra=aa=null;break;case"mousedown":sa=!0;break;case"contextmenu":case"mouseup":case"dragend":sa=!1,ia(s,n,r);break;case"selectionchange":if(na)break;case"keydown":case"keyup":ia(s,n,r)}var v;if(kn)e:{switch(e){case"compositionstart":var x="onCompositionStart";break e;case"compositionend":x="onCompositionEnd";break e;case"compositionupdate":x="onCompositionUpdate";break e}x=void 0}else An?Tn(e,n)&&(x="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(x="onCompositionStart");x&&(Cn&&"ko"!==n.locale&&(An||"onCompositionStart"!==x?"onCompositionEnd"===x&&An&&(v=jt()):(Vt="value"in(Ut=r)?Ut.value:Ut.textContent,An=!0)),0<(y=ju(a,x)).length&&(x=new cn(x,e,null,n,r),s.push({event:x,listeners:y}),v?x.data=v:null!==(v=Rn(n))&&(x.data=v))),(v=In?function(e,t){switch(e){case"compositionend":return Rn(t);case"keypress":return 32!==t.which?null:(En=!0,Nn);case"textInput":return(e=t.data)===Nn&&En?null:e;default:return null}}(e,n):function(e,t){if(An)return"compositionend"===e||!kn&&Tn(e,t)?(e=jt(),Gt=Vt=Ut=null,An=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Cn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(x=ju(a,"onBeforeInput")).length&&(y=new cn("onBeforeInput","beforeinput",null,n,r),s.push({event:y,listeners:x}),y.data=v)),function(e,t,n,a,r){if("submit"===t&&n&&n.stateNode===r){var o=Au((r[_e]||null).action),s=a.submitter;s&&null!==(t=(t=s[_e]||null)?Au(t.formAction):s.getAttribute("formAction"))&&(o=t,s=null);var i=new Zt("action","action",null,a,r);e.push({event:i,listeners:[{instance:null,listener:function(){if(a.defaultPrevented){if(0!==wu){var e=s?Fu(r,s):new FormData(r);Fs(n,{pending:!0,data:e,method:r.method,action:o},null,e)}}else"function"===typeof o&&(i.preventDefault(),e=s?Fu(r,s):new FormData(r),Fs(n,{pending:!0,data:e,method:r.method,action:o},o,e))},currentTarget:r}]})}}(s,e,a,n,r)}zu(s,t)}))}function Gu(e,t,n){return{instance:e,listener:t,currentTarget:n}}function ju(e,t){for(var n=t+"Capture",a=[];null!==e;){var r=e,o=r.stateNode;if(5!==(r=r.tag)&&26!==r&&27!==r||null===o||(null!=(r=Mt(e,n))&&a.unshift(Gu(e,r,o)),null!=(r=Mt(e,t))&&a.push(Gu(e,r,o))),3===e.tag)return a;e=e.return}return[]}function Hu(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag&&27!==e.tag);return e||null}function Ku(e,t,n,a,r){for(var o=t._reactName,s=[];null!==n&&n!==a;){var i=n,l=i.alternate,c=i.stateNode;if(i=i.tag,null!==l&&l===a)break;5!==i&&26!==i&&27!==i||null===c||(l=c,r?null!=(c=Mt(n,o))&&s.unshift(Gu(n,c,l)):r||null!=(c=Mt(n,o))&&s.push(Gu(n,c,l))),n=n.return}0!==s.length&&e.push({event:t,listeners:s})}var qu=/\r\n?/g,Xu=/\u0000|\uFFFD/g;function Yu(e){return("string"===typeof e?e:""+e).replace(qu,"\n").replace(Xu,"")}function Ju(e,t){return t=Yu(t),Yu(e)===t}function $u(){}function Qu(e,t,n,a,r,o){switch(n){case"children":"string"===typeof a?"body"===t||"textarea"===t&&""===a||kt(e,a):("number"===typeof a||"bigint"===typeof a)&&"body"!==t&&kt(e,""+a);break;case"className":nt(e,"class",a);break;case"tabIndex":nt(e,"tabindex",a);break;case"dir":case"role":case"viewBox":case"width":case"height":nt(e,n,a);break;case"style":Ct(e,a,o);break;case"data":if("object"!==t){nt(e,"data",a);break}case"src":case"href":if(""===a&&("a"!==t||"href"!==n)){e.removeAttribute(n);break}if(null==a||"function"===typeof a||"symbol"===typeof a||"boolean"===typeof a){e.removeAttribute(n);break}a=Rt(""+a),e.setAttribute(n,a);break;case"action":case"formAction":if("function"===typeof a){e.setAttribute(n,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}if("function"===typeof o&&("formAction"===n?("input"!==t&&Qu(e,t,"name",r.name,r,null),Qu(e,t,"formEncType",r.formEncType,r,null),Qu(e,t,"formMethod",r.formMethod,r,null),Qu(e,t,"formTarget",r.formTarget,r,null)):(Qu(e,t,"encType",r.encType,r,null),Qu(e,t,"method",r.method,r,null),Qu(e,t,"target",r.target,r,null))),null==a||"symbol"===typeof a||"boolean"===typeof a){e.removeAttribute(n);break}a=Rt(""+a),e.setAttribute(n,a);break;case"onClick":null!=a&&(e.onclick=$u);break;case"onScroll":null!=a&&Mu("scroll",e);break;case"onScrollEnd":null!=a&&Mu("scrollend",e);break;case"dangerouslySetInnerHTML":if(null!=a){if("object"!==typeof a||!("__html"in a))throw Error(s(61));if(null!=(n=a.__html)){if(null!=r.children)throw Error(s(60));e.innerHTML=n}}break;case"multiple":e.multiple=a&&"function"!==typeof a&&"symbol"!==typeof a;break;case"muted":e.muted=a&&"function"!==typeof a&&"symbol"!==typeof a;break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":case"autoFocus":break;case"xlinkHref":if(null==a||"function"===typeof a||"boolean"===typeof a||"symbol"===typeof a){e.removeAttribute("xlink:href");break}n=Rt(""+a),e.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",n);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":null!=a&&"function"!==typeof a&&"symbol"!==typeof a?e.setAttribute(n,""+a):e.removeAttribute(n);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":a&&"function"!==typeof a&&"symbol"!==typeof a?e.setAttribute(n,""):e.removeAttribute(n);break;case"capture":case"download":!0===a?e.setAttribute(n,""):!1!==a&&null!=a&&"function"!==typeof a&&"symbol"!==typeof a?e.setAttribute(n,a):e.removeAttribute(n);break;case"cols":case"rows":case"size":case"span":null!=a&&"function"!==typeof a&&"symbol"!==typeof a&&!isNaN(a)&&1<=a?e.setAttribute(n,a):e.removeAttribute(n);break;case"rowSpan":case"start":null==a||"function"===typeof a||"symbol"===typeof a||isNaN(a)?e.removeAttribute(n):e.setAttribute(n,a);break;case"popover":Mu("beforetoggle",e),Mu("toggle",e),tt(e,"popover",a);break;case"xlinkActuate":at(e,"http://www.w3.org/1999/xlink","xlink:actuate",a);break;case"xlinkArcrole":at(e,"http://www.w3.org/1999/xlink","xlink:arcrole",a);break;case"xlinkRole":at(e,"http://www.w3.org/1999/xlink","xlink:role",a);break;case"xlinkShow":at(e,"http://www.w3.org/1999/xlink","xlink:show",a);break;case"xlinkTitle":at(e,"http://www.w3.org/1999/xlink","xlink:title",a);break;case"xlinkType":at(e,"http://www.w3.org/1999/xlink","xlink:type",a);break;case"xmlBase":at(e,"http://www.w3.org/XML/1998/namespace","xml:base",a);break;case"xmlLang":at(e,"http://www.w3.org/XML/1998/namespace","xml:lang",a);break;case"xmlSpace":at(e,"http://www.w3.org/XML/1998/namespace","xml:space",a);break;case"is":tt(e,"is",a);break;case"innerText":case"textContent":break;default:(!(2<n.length)||"o"!==n[0]&&"O"!==n[0]||"n"!==n[1]&&"N"!==n[1])&&tt(e,n=Et.get(n)||n,a)}}function Zu(e,t,n,a,r,o){switch(n){case"style":Ct(e,a,o);break;case"dangerouslySetInnerHTML":if(null!=a){if("object"!==typeof a||!("__html"in a))throw Error(s(61));if(null!=(n=a.__html)){if(null!=r.children)throw Error(s(60));e.innerHTML=n}}break;case"children":"string"===typeof a?kt(e,a):("number"===typeof a||"bigint"===typeof a)&&kt(e,""+a);break;case"onScroll":null!=a&&Mu("scroll",e);break;case"onScrollEnd":null!=a&&Mu("scrollend",e);break;case"onClick":null!=a&&(e.onclick=$u);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":case"innerText":case"textContent":break;default:qe.hasOwnProperty(n)||("o"!==n[0]||"n"!==n[1]||(r=n.endsWith("Capture"),t=n.slice(2,r?n.length-7:void 0),"function"===typeof(o=null!=(o=e[_e]||null)?o[n]:null)&&e.removeEventListener(t,o,r),"function"!==typeof a)?n in e?e[n]=a:!0===a?e.setAttribute(n,""):tt(e,n,a):("function"!==typeof o&&null!==o&&(n in e?e[n]=null:e.hasAttribute(n)&&e.removeAttribute(n)),e.addEventListener(t,a,r)))}}function eh(e,t,n){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Mu("error",e),Mu("load",e);var a,r=!1,o=!1;for(a in n)if(n.hasOwnProperty(a)){var i=n[a];if(null!=i)switch(a){case"src":r=!0;break;case"srcSet":o=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,t));default:Qu(e,t,a,i,n,null)}}return o&&Qu(e,t,"srcSet",n.srcSet,n,null),void(r&&Qu(e,t,"src",n.src,n,null));case"input":Mu("invalid",e);var l=a=i=o=null,c=null,u=null;for(r in n)if(n.hasOwnProperty(r)){var h=n[r];if(null!=h)switch(r){case"name":o=h;break;case"type":i=h;break;case"checked":c=h;break;case"defaultChecked":u=h;break;case"value":a=h;break;case"defaultValue":l=h;break;case"children":case"dangerouslySetInnerHTML":if(null!=h)throw Error(s(137,t));break;default:Qu(e,t,r,h,n,null)}}return bt(e,a,l,c,u,i,o,!1),void ht(e);case"select":for(o in Mu("invalid",e),r=i=a=null,n)if(n.hasOwnProperty(o)&&null!=(l=n[o]))switch(o){case"value":a=l;break;case"defaultValue":i=l;break;case"multiple":r=l;default:Qu(e,t,o,l,n,null)}return t=a,n=i,e.multiple=!!r,void(null!=t?vt(e,!!r,t,!1):null!=n&&vt(e,!!r,n,!0));case"textarea":for(i in Mu("invalid",e),a=o=r=null,n)if(n.hasOwnProperty(i)&&null!=(l=n[i]))switch(i){case"value":r=l;break;case"defaultValue":o=l;break;case"children":a=l;break;case"dangerouslySetInnerHTML":if(null!=l)throw Error(s(91));break;default:Qu(e,t,i,l,n,null)}return wt(e,r,o,a),void ht(e);case"option":for(c in n)if(n.hasOwnProperty(c)&&null!=(r=n[c]))if("selected"===c)e.selected=r&&"function"!==typeof r&&"symbol"!==typeof r;else Qu(e,t,c,r,n,null);return;case"dialog":Mu("beforetoggle",e),Mu("toggle",e),Mu("cancel",e),Mu("close",e);break;case"iframe":case"object":Mu("load",e);break;case"video":case"audio":for(r=0;r<Ou.length;r++)Mu(Ou[r],e);break;case"image":Mu("error",e),Mu("load",e);break;case"details":Mu("toggle",e);break;case"embed":case"source":case"link":Mu("error",e),Mu("load",e);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(u in n)if(n.hasOwnProperty(u)&&null!=(r=n[u]))switch(u){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,t));default:Qu(e,t,u,r,n,null)}return;default:if(Nt(t)){for(h in n)n.hasOwnProperty(h)&&(void 0!==(r=n[h])&&Zu(e,t,h,r,n,void 0));return}}for(l in n)n.hasOwnProperty(l)&&(null!=(r=n[l])&&Qu(e,t,l,r,n,null))}var th=null,nh=null;function ah(e){return 9===e.nodeType?e:e.ownerDocument}function rh(e){switch(e){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function oh(e,t){if(0===e)switch(t){case"svg":return 1;case"math":return 2;default:return 0}return 1===e&&"foreignObject"===t?0:e}function sh(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"bigint"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var ih=null;var lh="function"===typeof setTimeout?setTimeout:void 0,ch="function"===typeof clearTimeout?clearTimeout:void 0,uh="function"===typeof Promise?Promise:void 0,hh="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof uh?function(e){return uh.resolve(null).then(e).catch(dh)}:lh;function dh(e){setTimeout((function(){throw e}))}function ph(e){return"head"===e}function fh(e,t){var n=t,a=0,r=0;do{var o=n.nextSibling;if(e.removeChild(n),o&&8===o.nodeType)if("/$"===(n=o.data)){if(0<a&&8>a){n=a;var s=e.ownerDocument;if(1&n&&wh(s.documentElement),2&n&&wh(s.body),4&n)for(wh(n=s.head),s=n.firstChild;s;){var i=s.nextSibling,l=s.nodeName;s[Be]||"SCRIPT"===l||"STYLE"===l||"LINK"===l&&"stylesheet"===s.rel.toLowerCase()||n.removeChild(s),s=i}}if(0===r)return e.removeChild(o),void Ed(t);r--}else"$"===n||"$?"===n||"$!"===n?r++:a=n.charCodeAt(0)-48;else a=0;n=o}while(n);Ed(t)}function gh(e){var t=e.firstChild;for(t&&10===t.nodeType&&(t=t.nextSibling);t;){var n=t;switch(t=t.nextSibling,n.nodeName){case"HTML":case"HEAD":case"BODY":gh(n),We(n);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if("stylesheet"===n.rel.toLowerCase())continue}e.removeChild(n)}}function mh(e){return"$!"===e.data||"$?"===e.data&&"complete"===e.ownerDocument.readyState}function bh(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t||"F!"===t||"F"===t)break;if("/$"===t)return null}}return e}var yh=null;function vh(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}function xh(e,t,n){switch(t=ah(n),e){case"html":if(!(e=t.documentElement))throw Error(s(452));return e;case"head":if(!(e=t.head))throw Error(s(453));return e;case"body":if(!(e=t.body))throw Error(s(454));return e;default:throw Error(s(451))}}function wh(e){for(var t=e.attributes;t.length;)e.removeAttributeNode(t[0]);We(e)}var kh=new Map,Sh=new Set;function Ih(e){return"function"===typeof e.getRootNode?e.getRootNode():9===e.nodeType?e:e.ownerDocument}var Ch=L.d;L.d={f:function(){var e=Ch.f(),t=Uc();return e||t},r:function(e){var t=Ve(e);null!==t&&5===t.tag&&"form"===t.type?_s(t):Ch.r(e)},D:function(e){Ch.D(e),Eh("dns-prefetch",e,null)},C:function(e,t){Ch.C(e,t),Eh("preconnect",e,t)},L:function(e,t,n){Ch.L(e,t,n);var a=Nh;if(a&&e&&t){var r='link[rel="preload"][as="'+gt(t)+'"]';"image"===t&&n&&n.imageSrcSet?(r+='[imagesrcset="'+gt(n.imageSrcSet)+'"]',"string"===typeof n.imageSizes&&(r+='[imagesizes="'+gt(n.imageSizes)+'"]')):r+='[href="'+gt(e)+'"]';var o=r;switch(t){case"style":o=Rh(e);break;case"script":o=Dh(e)}kh.has(o)||(e=d({rel:"preload",href:"image"===t&&n&&n.imageSrcSet?void 0:e,as:t},n),kh.set(o,e),null!==a.querySelector(r)||"style"===t&&a.querySelector(Ah(o))||"script"===t&&a.querySelector(_h(o))||(eh(t=a.createElement("link"),"link",e),He(t),a.head.appendChild(t)))}},m:function(e,t){Ch.m(e,t);var n=Nh;if(n&&e){var a=t&&"string"===typeof t.as?t.as:"script",r='link[rel="modulepreload"][as="'+gt(a)+'"][href="'+gt(e)+'"]',o=r;switch(a){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":o=Dh(e)}if(!kh.has(o)&&(e=d({rel:"modulepreload",href:e},t),kh.set(o,e),null===n.querySelector(r))){switch(a){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(n.querySelector(_h(o)))return}eh(a=n.createElement("link"),"link",e),He(a),n.head.appendChild(a)}}},X:function(e,t){Ch.X(e,t);var n=Nh;if(n&&e){var a=je(n).hoistableScripts,r=Dh(e),o=a.get(r);o||((o=n.querySelector(_h(r)))||(e=d({src:e,async:!0},t),(t=kh.get(r))&&Mh(e,t),He(o=n.createElement("script")),eh(o,"link",e),n.head.appendChild(o)),o={type:"script",instance:o,count:1,state:null},a.set(r,o))}},S:function(e,t,n){Ch.S(e,t,n);var a=Nh;if(a&&e){var r=je(a).hoistableStyles,o=Rh(e);t=t||"default";var s=r.get(o);if(!s){var i={loading:0,preload:null};if(s=a.querySelector(Ah(o)))i.loading=5;else{e=d({rel:"stylesheet",href:e,"data-precedence":t},n),(n=kh.get(o))&&zh(e,n);var l=s=a.createElement("link");He(l),eh(l,"link",e),l._p=new Promise((function(e,t){l.onload=e,l.onerror=t})),l.addEventListener("load",(function(){i.loading|=1})),l.addEventListener("error",(function(){i.loading|=2})),i.loading|=4,Lh(s,t,a)}s={type:"stylesheet",instance:s,count:1,state:i},r.set(o,s)}}},M:function(e,t){Ch.M(e,t);var n=Nh;if(n&&e){var a=je(n).hoistableScripts,r=Dh(e),o=a.get(r);o||((o=n.querySelector(_h(r)))||(e=d({src:e,async:!0,type:"module"},t),(t=kh.get(r))&&Mh(e,t),He(o=n.createElement("script")),eh(o,"link",e),n.head.appendChild(o)),o={type:"script",instance:o,count:1,state:null},a.set(r,o))}}};var Nh="undefined"===typeof document?null:document;function Eh(e,t,n){var a=Nh;if(a&&"string"===typeof t&&t){var r=gt(t);r='link[rel="'+e+'"][href="'+r+'"]',"string"===typeof n&&(r+='[crossorigin="'+n+'"]'),Sh.has(r)||(Sh.add(r),e={rel:e,crossOrigin:n,href:t},null===a.querySelector(r)&&(eh(t=a.createElement("link"),"link",e),He(t),a.head.appendChild(t)))}}function Th(e,t,n,a){var r,o,i,l,c=(c=j.current)?Ih(c):null;if(!c)throw Error(s(446));switch(e){case"meta":case"title":return null;case"style":return"string"===typeof n.precedence&&"string"===typeof n.href?(t=Rh(n.href),(a=(n=je(c).hoistableStyles).get(t))||(a={type:"style",instance:null,count:0,state:null},n.set(t,a)),a):{type:"void",instance:null,count:0,state:null};case"link":if("stylesheet"===n.rel&&"string"===typeof n.href&&"string"===typeof n.precedence){e=Rh(n.href);var u=je(c).hoistableStyles,h=u.get(e);if(h||(c=c.ownerDocument||c,h={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},u.set(e,h),(u=c.querySelector(Ah(e)))&&!u._p&&(h.instance=u,h.state.loading=5),kh.has(e)||(n={rel:"preload",as:"style",href:n.href,crossOrigin:n.crossOrigin,integrity:n.integrity,media:n.media,hrefLang:n.hrefLang,referrerPolicy:n.referrerPolicy},kh.set(e,n),u||(r=c,o=e,i=n,l=h.state,r.querySelector('link[rel="preload"][as="style"]['+o+"]")?l.loading=1:(o=r.createElement("link"),l.preload=o,o.addEventListener("load",(function(){return l.loading|=1})),o.addEventListener("error",(function(){return l.loading|=2})),eh(o,"link",i),He(o),r.head.appendChild(o))))),t&&null===a)throw Error(s(528,""));return h}if(t&&null!==a)throw Error(s(529,""));return null;case"script":return t=n.async,"string"===typeof(n=n.src)&&t&&"function"!==typeof t&&"symbol"!==typeof t?(t=Dh(n),(a=(n=je(c).hoistableScripts).get(t))||(a={type:"script",instance:null,count:0,state:null},n.set(t,a)),a):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,e))}}function Rh(e){return'href="'+gt(e)+'"'}function Ah(e){return'link[rel="stylesheet"]['+e+"]"}function Fh(e){return d({},e,{"data-precedence":e.precedence,precedence:null})}function Dh(e){return'[src="'+gt(e)+'"]'}function _h(e){return"script[async]"+e}function Oh(e,t,n){if(t.count++,null===t.instance)switch(t.type){case"style":var a=e.querySelector('style[data-href~="'+gt(n.href)+'"]');if(a)return t.instance=a,He(a),a;var r=d({},n,{"data-href":n.href,"data-precedence":n.precedence,href:null,precedence:null});return He(a=(e.ownerDocument||e).createElement("style")),eh(a,"style",r),Lh(a,n.precedence,e),t.instance=a;case"stylesheet":r=Rh(n.href);var o=e.querySelector(Ah(r));if(o)return t.state.loading|=4,t.instance=o,He(o),o;a=Fh(n),(r=kh.get(r))&&zh(a,r),He(o=(e.ownerDocument||e).createElement("link"));var i=o;return i._p=new Promise((function(e,t){i.onload=e,i.onerror=t})),eh(o,"link",a),t.state.loading|=4,Lh(o,n.precedence,e),t.instance=o;case"script":return o=Dh(n.src),(r=e.querySelector(_h(o)))?(t.instance=r,He(r),r):(a=n,(r=kh.get(o))&&Mh(a=d({},n),r),He(r=(e=e.ownerDocument||e).createElement("script")),eh(r,"link",a),e.head.appendChild(r),t.instance=r);case"void":return null;default:throw Error(s(443,t.type))}else"stylesheet"===t.type&&0===(4&t.state.loading)&&(a=t.instance,t.state.loading|=4,Lh(a,n.precedence,e));return t.instance}function Lh(e,t,n){for(var a=n.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),r=a.length?a[a.length-1]:null,o=r,s=0;s<a.length;s++){var i=a[s];if(i.dataset.precedence===t)o=i;else if(o!==r)break}o?o.parentNode.insertBefore(e,o.nextSibling):(t=9===n.nodeType?n.head:n).insertBefore(e,t.firstChild)}function zh(e,t){null==e.crossOrigin&&(e.crossOrigin=t.crossOrigin),null==e.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),null==e.title&&(e.title=t.title)}function Mh(e,t){null==e.crossOrigin&&(e.crossOrigin=t.crossOrigin),null==e.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),null==e.integrity&&(e.integrity=t.integrity)}var Ph=null;function Bh(e,t,n){if(null===Ph){var a=new Map,r=Ph=new Map;r.set(n,a)}else(a=(r=Ph).get(n))||(a=new Map,r.set(n,a));if(a.has(e))return a;for(a.set(e,null),n=n.getElementsByTagName(e),r=0;r<n.length;r++){var o=n[r];if(!(o[Be]||o[De]||"link"===e&&"stylesheet"===o.getAttribute("rel"))&&"http://www.w3.org/2000/svg"!==o.namespaceURI){var s=o.getAttribute(t)||"";s=e+s;var i=a.get(s);i?i.push(o):a.set(s,[o])}}return a}function Wh(e,t,n){(e=e.ownerDocument||e).head.insertBefore(n,"title"===t?e.querySelector("head > title"):null)}function Uh(e){return"stylesheet"!==e.type||0!==(3&e.state.loading)}var Vh=null;function Gh(){}function jh(){if(this.count--,0===this.count)if(this.stylesheets)Kh(this,this.stylesheets);else if(this.unsuspend){var e=this.unsuspend;this.unsuspend=null,e()}}var Hh=null;function Kh(e,t){e.stylesheets=null,null!==e.unsuspend&&(e.count++,Hh=new Map,t.forEach(qh,e),Hh=null,jh.call(e))}function qh(e,t){if(!(4&t.state.loading)){var n=Hh.get(e);if(n)var a=n.get(null);else{n=new Map,Hh.set(e,n);for(var r=e.querySelectorAll("link[data-precedence],style[data-precedence]"),o=0;o<r.length;o++){var s=r[o];"LINK"!==s.nodeName&&"not all"===s.getAttribute("media")||(n.set(s.dataset.precedence,s),a=s)}a&&n.set(null,a)}s=(r=t.instance).getAttribute("data-precedence"),(o=n.get(s)||a)===a&&n.set(null,r),n.set(s,r),this.count++,a=jh.bind(this),r.addEventListener("load",a),r.addEventListener("error",a),o?o.parentNode.insertBefore(r,o.nextSibling):(e=9===e.nodeType?e.head:e).insertBefore(r,e.firstChild),t.state.loading|=4}}var Xh={$$typeof:w,Provider:null,Consumer:null,_currentValue:z,_currentValue2:z,_threadCount:0};function Yh(e,t,n,a,r,o,s,i){this.tag=1,this.containerInfo=e,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Ie(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ie(0),this.hiddenUpdates=Ie(null),this.identifierPrefix=a,this.onUncaughtError=r,this.onCaughtError=o,this.onRecoverableError=s,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=i,this.incompleteTransitions=new Map}function Jh(e,t,n,a,r,o,s,i,l,c,u,h){return e=new Yh(e,t,n,s,i,l,c,h),t=1,!0===o&&(t|=24),o=za(3,null,null,t),e.current=o,o.stateNode=e,(t=_r()).refCount++,e.pooledCache=t,t.refCount++,o.memoizedState={element:a,isDehydrated:n,cache:t},no(o),e}function $h(e){return e?e=Oa:Oa}function Qh(e,t,n,a,r,o){r=$h(r),null===a.context?a.context=r:a.pendingContext=r,(a=ro(t)).payload={element:n},null!==(o=void 0===o?null:o)&&(a.callback=o),null!==(n=oo(e,a,t))&&(zc(n,0,t),so(n,e,t))}function Zh(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function ed(e,t){Zh(e,t),(e=e.alternate)&&Zh(e,t)}function td(e){if(13===e.tag){var t=Fa(e,67108864);null!==t&&zc(t,0,67108864),ed(e,67108864)}}var nd=!0;function ad(e,t,n,a){var r=O.T;O.T=null;var o=L.p;try{L.p=2,od(e,t,n,a)}finally{L.p=o,O.T=r}}function rd(e,t,n,a){var r=O.T;O.T=null;var o=L.p;try{L.p=8,od(e,t,n,a)}finally{L.p=o,O.T=r}}function od(e,t,n,a){if(nd){var r=sd(a);if(null===r)Vu(e,t,a,id,n),yd(e,a);else if(function(e,t,n,a,r){switch(t){case"focusin":return hd=vd(hd,e,t,n,a,r),!0;case"dragenter":return dd=vd(dd,e,t,n,a,r),!0;case"mouseover":return pd=vd(pd,e,t,n,a,r),!0;case"pointerover":var o=r.pointerId;return fd.set(o,vd(fd.get(o)||null,e,t,n,a,r)),!0;case"gotpointercapture":return o=r.pointerId,gd.set(o,vd(gd.get(o)||null,e,t,n,a,r)),!0}return!1}(r,e,t,n,a))a.stopPropagation();else if(yd(e,a),4&t&&-1<bd.indexOf(e)){for(;null!==r;){var o=Ve(r);if(null!==o)switch(o.tag){case 3:if((o=o.stateNode).current.memoizedState.isDehydrated){var s=ye(o.pendingLanes);if(0!==s){var i=o;for(i.pendingLanes|=2,i.entangledLanes|=2;s;){var l=1<<31-pe(s);i.entanglements[1]|=l,s&=~l}ku(o),0===(6&nc)&&(kc=te()+500,Su(0,!1))}}break;case 13:null!==(i=Fa(o,2))&&zc(i,0,2),Uc(),ed(o,2)}if(null===(o=sd(a))&&Vu(e,t,a,id,n),o===r)break;r=o}null!==r&&a.stopPropagation()}else Vu(e,t,a,null,n)}}function sd(e){return ld(e=Ft(e))}var id=null;function ld(e){if(id=null,null!==(e=Ue(e))){var t=l(e);if(null===t)e=null;else{var n=t.tag;if(13===n){if(null!==(e=c(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null)}}return id=e,null}function cd(e){switch(e){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(ne()){case ae:return 2;case re:return 8;case oe:case se:return 32;case ie:return 268435456;default:return 32}default:return 32}}var ud=!1,hd=null,dd=null,pd=null,fd=new Map,gd=new Map,md=[],bd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function yd(e,t){switch(e){case"focusin":case"focusout":hd=null;break;case"dragenter":case"dragleave":dd=null;break;case"mouseover":case"mouseout":pd=null;break;case"pointerover":case"pointerout":fd.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":gd.delete(t.pointerId)}}function vd(e,t,n,a,r,o){return null===e||e.nativeEvent!==o?(e={blockedOn:t,domEventName:n,eventSystemFlags:a,nativeEvent:o,targetContainers:[r]},null!==t&&(null!==(t=Ve(t))&&td(t)),e):(e.eventSystemFlags|=a,t=e.targetContainers,null!==r&&-1===t.indexOf(r)&&t.push(r),e)}function xd(e){var t=Ue(e.target);if(null!==t){var n=l(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=c(n)))return e.blockedOn=t,void function(e,t){var n=L.p;try{return L.p=e,t()}finally{L.p=n}}(e.priority,(function(){if(13===n.tag){var e=Oc();e=Te(e);var t=Fa(n,e);null!==t&&zc(t,0,e),ed(n,e)}}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function wd(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=sd(e.nativeEvent);if(null!==n)return null!==(t=Ve(n))&&td(t),e.blockedOn=n,!1;var a=new(n=e.nativeEvent).constructor(n.type,n);At=a,n.target.dispatchEvent(a),At=null,t.shift()}return!0}function kd(e,t,n){wd(e)&&n.delete(t)}function Sd(){ud=!1,null!==hd&&wd(hd)&&(hd=null),null!==dd&&wd(dd)&&(dd=null),null!==pd&&wd(pd)&&(pd=null),fd.forEach(kd),gd.forEach(kd)}function Id(e,t){e.blockedOn===t&&(e.blockedOn=null,ud||(ud=!0,a.unstable_scheduleCallback(a.unstable_NormalPriority,Sd)))}var Cd=null;function Nd(e){Cd!==e&&(Cd=e,a.unstable_scheduleCallback(a.unstable_NormalPriority,(function(){Cd===e&&(Cd=null);for(var t=0;t<e.length;t+=3){var n=e[t],a=e[t+1],r=e[t+2];if("function"!==typeof a){if(null===ld(a||n))continue;break}var o=Ve(n);null!==o&&(e.splice(t,3),t-=3,Fs(o,{pending:!0,data:r,method:n.method,action:a},a,r))}})))}function Ed(e){function t(t){return Id(t,e)}null!==hd&&Id(hd,e),null!==dd&&Id(dd,e),null!==pd&&Id(pd,e),fd.forEach(t),gd.forEach(t);for(var n=0;n<md.length;n++){var a=md[n];a.blockedOn===e&&(a.blockedOn=null)}for(;0<md.length&&null===(n=md[0]).blockedOn;)xd(n),null===n.blockedOn&&md.shift();if(null!=(n=(e.ownerDocument||e).$$reactFormReplay))for(a=0;a<n.length;a+=3){var r=n[a],o=n[a+1],s=r[_e]||null;if("function"===typeof o)s||Nd(n);else if(s){var i=null;if(o&&o.hasAttribute("formAction")){if(r=o,s=o[_e]||null)i=s.formAction;else if(null!==ld(r))continue}else i=s.action;"function"===typeof i?n[a+1]=i:(n.splice(a,3),a-=3),Nd(n)}}}function Td(e){this._internalRoot=e}function Rd(e){this._internalRoot=e}Rd.prototype.render=Td.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(s(409));Qh(t.current,Oc(),e,t,null,null)},Rd.prototype.unmount=Td.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;Qh(e.current,2,null,e,null,null),Uc(),t[Oe]=null}},Rd.prototype.unstable_scheduleHydration=function(e){if(e){var t=Ae();e={blockedOn:null,target:e,priority:t};for(var n=0;n<md.length&&0!==t&&t<md[n].priority;n++);md.splice(n,0,e),0===n&&xd(e)}};var Ad=r.version;if("19.1.0"!==Ad)throw Error(s(527,Ad,"19.1.0"));L.findDOMNode=function(e){var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(s(188));throw e=Object.keys(e).join(","),Error(s(268,e))}return e=function(e){var t=e.alternate;if(!t){if(null===(t=l(e)))throw Error(s(188));return t!==e?null:e}for(var n=e,a=t;;){var r=n.return;if(null===r)break;var o=r.alternate;if(null===o){if(null!==(a=r.return)){n=a;continue}break}if(r.child===o.child){for(o=r.child;o;){if(o===n)return u(r),e;if(o===a)return u(r),t;o=o.sibling}throw Error(s(188))}if(n.return!==a.return)n=r,a=o;else{for(var i=!1,c=r.child;c;){if(c===n){i=!0,n=r,a=o;break}if(c===a){i=!0,a=r,n=o;break}c=c.sibling}if(!i){for(c=o.child;c;){if(c===n){i=!0,n=o,a=r;break}if(c===a){i=!0,a=o,n=r;break}c=c.sibling}if(!i)throw Error(s(189))}}if(n.alternate!==a)throw Error(s(190))}if(3!==n.tag)throw Error(s(188));return n.stateNode.current===n?e:t}(t),e=null===(e=null!==e?h(e):null)?null:e.stateNode};var Fd={bundleType:0,version:"19.1.0",rendererPackageName:"react-dom",currentDispatcherRef:O,reconcilerVersion:"19.1.0"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var Dd=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Dd.isDisabled&&Dd.supportsFiber)try{ue=Dd.inject(Fd),he=Dd}catch(Od){}}t.createRoot=function(e,t){if(!i(e))throw Error(s(299));var n=!1,a="",r=yi,o=vi,l=xi;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(a=t.identifierPrefix),void 0!==t.onUncaughtError&&(r=t.onUncaughtError),void 0!==t.onCaughtError&&(o=t.onCaughtError),void 0!==t.onRecoverableError&&(l=t.onRecoverableError),void 0!==t.unstable_transitionCallbacks&&t.unstable_transitionCallbacks),t=Jh(e,1,!1,null,0,n,a,r,o,l,0,null),e[Oe]=t.current,Wu(e),new Td(t)},t.hydrateRoot=function(e,t,n){if(!i(e))throw Error(s(299));var a=!1,r="",o=yi,l=vi,c=xi,u=null;return null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(a=!0),void 0!==n.identifierPrefix&&(r=n.identifierPrefix),void 0!==n.onUncaughtError&&(o=n.onUncaughtError),void 0!==n.onCaughtError&&(l=n.onCaughtError),void 0!==n.onRecoverableError&&(c=n.onRecoverableError),void 0!==n.unstable_transitionCallbacks&&n.unstable_transitionCallbacks,void 0!==n.formState&&(u=n.formState)),(t=Jh(e,1,!0,t,0,a,r,o,l,c,0,u)).context=$h(null),n=t.current,(r=ro(a=Te(a=Oc()))).callback=null,oo(n,r,a),n=a,t.current.lanes=n,Ce(t,n),ku(t),e[Oe]=t.current,Wu(e),new Rd(t)},t.version="19.1.0"},16:function(e,t,n){var a;!function(e,r){function o(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),a==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function i(e,t){var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&s(a,n),r.state=function(){return s(n,{})}),r}r&&r.exports?r.exports=i:n.amdD&&n.amdO?void 0===(a=function(){return i}.call(t,n,t,r))||(r.exports=a):this.xorwow=i}(0,e=n.nmd(e),n.amdD)},43:(e,t,n)=>{"use strict";e.exports=n(288)},66:function(e,t,n){var a;!function(e,r){function o(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function i(e,t){var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&s(a,n),r.state=function(){return s(n,{})}),r}r&&r.exports?r.exports=i:n.amdD&&n.amdO?void 0===(a=function(){return i}.call(t,n,t,r))||(r.exports=a):this.xor128=i}(0,e=n.nmd(e),n.amdD)},108:()=>{},234:()=>{},262:function(e,t,n){var a;!function(e,r){function o(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,a=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-a|0,a=a<<24^a>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-a|0,t.d=a<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var a=0;a<n.length+20;a++)t.b^=0|n.charCodeAt(a),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function i(e,t){var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&s(a,n),r.state=function(){return s(n,{})}),r}r&&r.exports?r.exports=i:n.amdD&&n.amdO?void 0===(a=function(){return i}.call(t,n,t,r))||(r.exports=a):this.tychei=i}(0,e=n.nmd(e),n.amdD)},288:(e,t)=>{"use strict";var n=Symbol.for("react.transitional.element"),a=Symbol.for("react.portal"),r=Symbol.for("react.fragment"),o=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),i=Symbol.for("react.consumer"),l=Symbol.for("react.context"),c=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,m={};function b(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||f}function y(){}function v(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||f}b.prototype.isReactComponent={},b.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},b.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},y.prototype=b.prototype;var x=v.prototype=new y;x.constructor=v,g(x,b.prototype),x.isPureReactComponent=!0;var w=Array.isArray,k={H:null,A:null,T:null,S:null,V:null},S=Object.prototype.hasOwnProperty;function I(e,t,a,r,o,s){return a=s.ref,{$$typeof:n,type:e,key:t,ref:void 0!==a?a:null,props:s}}function C(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var N=/\/+/g;function E(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function T(){}function R(e,t,r,o,s){var i=typeof e;"undefined"!==i&&"boolean"!==i||(e=null);var l,c,u=!1;if(null===e)u=!0;else switch(i){case"bigint":case"string":case"number":u=!0;break;case"object":switch(e.$$typeof){case n:case a:u=!0;break;case d:return R((u=e._init)(e._payload),t,r,o,s)}}if(u)return s=s(e),u=""===o?"."+E(e,0):o,w(s)?(r="",null!=u&&(r=u.replace(N,"$&/")+"/"),R(s,t,r,"",(function(e){return e}))):null!=s&&(C(s)&&(l=s,c=r+(null==s.key||e&&e.key===s.key?"":(""+s.key).replace(N,"$&/")+"/")+u,s=I(l.type,c,void 0,0,0,l.props)),t.push(s)),1;u=0;var h,f=""===o?".":o+":";if(w(e))for(var g=0;g<e.length;g++)u+=R(o=e[g],t,r,i=f+E(o,g),s);else if("function"===typeof(g=null===(h=e)||"object"!==typeof h?null:"function"===typeof(h=p&&h[p]||h["@@iterator"])?h:null))for(e=g.call(e),g=0;!(o=e.next()).done;)u+=R(o=o.value,t,r,i=f+E(o,g++),s);else if("object"===i){if("function"===typeof e.then)return R(function(e){switch(e.status){case"fulfilled":return e.value;case"rejected":throw e.reason;default:switch("string"===typeof e.status?e.then(T,T):(e.status="pending",e.then((function(t){"pending"===e.status&&(e.status="fulfilled",e.value=t)}),(function(t){"pending"===e.status&&(e.status="rejected",e.reason=t)}))),e.status){case"fulfilled":return e.value;case"rejected":throw e.reason}}throw e}(e),t,r,o,s);throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.")}return u}function A(e,t,n){if(null==e)return e;var a=[],r=0;return R(e,a,"","",(function(e){return t.call(n,e,r++)})),a}function F(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var D="function"===typeof reportError?reportError:function(e){if("object"===typeof window&&"function"===typeof window.ErrorEvent){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:"object"===typeof e&&null!==e&&"string"===typeof e.message?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if("object"===typeof process&&"function"===typeof process.emit)return void process.emit("uncaughtException",e);console.error(e)};function _(){}t.Children={map:A,forEach:function(e,t,n){A(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return A(e,(function(){t++})),t},toArray:function(e){return A(e,(function(e){return e}))||[]},only:function(e){if(!C(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=b,t.Fragment=r,t.Profiler=s,t.PureComponent=v,t.StrictMode=o,t.Suspense=u,t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=k,t.__COMPILER_RUNTIME={__proto__:null,c:function(e){return k.H.useMemoCache(e)}},t.cache=function(e){return function(){return e.apply(null,arguments)}},t.cloneElement=function(e,t,n){if(null===e||void 0===e)throw Error("The argument must be a React element, but you passed "+e+".");var a=g({},e.props),r=e.key;if(null!=t)for(o in void 0!==t.ref&&void 0,void 0!==t.key&&(r=""+t.key),t)!S.call(t,o)||"key"===o||"__self"===o||"__source"===o||"ref"===o&&void 0===t.ref||(a[o]=t[o]);var o=arguments.length-2;if(1===o)a.children=n;else if(1<o){for(var s=Array(o),i=0;i<o;i++)s[i]=arguments[i+2];a.children=s}return I(e.type,r,void 0,0,0,a)},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider=e,e.Consumer={$$typeof:i,_context:e},e},t.createElement=function(e,t,n){var a,r={},o=null;if(null!=t)for(a in void 0!==t.key&&(o=""+t.key),t)S.call(t,a)&&"key"!==a&&"__self"!==a&&"__source"!==a&&(r[a]=t[a]);var s=arguments.length-2;if(1===s)r.children=n;else if(1<s){for(var i=Array(s),l=0;l<s;l++)i[l]=arguments[l+2];r.children=i}if(e&&e.defaultProps)for(a in s=e.defaultProps)void 0===r[a]&&(r[a]=s[a]);return I(e,o,void 0,0,0,r)},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:c,render:e}},t.isValidElement=C,t.lazy=function(e){return{$$typeof:d,_payload:{_status:-1,_result:e},_init:F}},t.memo=function(e,t){return{$$typeof:h,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=k.T,n={};k.T=n;try{var a=e(),r=k.S;null!==r&&r(n,a),"object"===typeof a&&null!==a&&"function"===typeof a.then&&a.then(_,D)}catch(o){D(o)}finally{k.T=t}},t.unstable_useCacheRefresh=function(){return k.H.useCacheRefresh()},t.use=function(e){return k.H.use(e)},t.useActionState=function(e,t,n){return k.H.useActionState(e,t,n)},t.useCallback=function(e,t){return k.H.useCallback(e,t)},t.useContext=function(e){return k.H.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e,t){return k.H.useDeferredValue(e,t)},t.useEffect=function(e,t,n){var a=k.H;if("function"===typeof n)throw Error("useEffect CRUD overload is not enabled in this build of React.");return a.useEffect(e,t)},t.useId=function(){return k.H.useId()},t.useImperativeHandle=function(e,t,n){return k.H.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return k.H.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return k.H.useLayoutEffect(e,t)},t.useMemo=function(e,t){return k.H.useMemo(e,t)},t.useOptimistic=function(e,t){return k.H.useOptimistic(e,t)},t.useReducer=function(e,t,n){return k.H.useReducer(e,t,n)},t.useRef=function(e){return k.H.useRef(e)},t.useState=function(e){return k.H.useState(e)},t.useSyncExternalStore=function(e,t,n){return k.H.useSyncExternalStore(e,t,n)},t.useTransition=function(){return k.H.useTransition()},t.version="19.1.0"},334:(e,t,n)=>{var a=n(359),r=n(66),o=n(16),s=n(538),i=n(907),l=n(262),c=n(430);c.alea=a,c.xor128=r,c.xorwow=o,c.xorshift7=s,c.xor4096=i,c.tychei=l,e.exports=c},353:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(C){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=a;var r={},o={};function s(e,t){var n,a,s;return t?(s=0<=(e>>>=0)&&e<256)&&(a=o[e])?a:(n=l(e,(0|e)<0?-1:0,!0),s&&(o[e]=n),n):(s=-128<=(e|=0)&&e<128)&&(a=r[e])?a:(n=l(e,e<0?-1:0,!1),s&&(r[e]=n),n)}function i(e,t){if(isNaN(e))return t?b:m;if(t){if(e<0)return b;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?i(-e,t).neg():l(e%d|0,e/d|0,t)}function l(e,t,a){return new n(e,t,a)}n.fromInt=s,n.fromNumber=i,n.fromBits=l;var c=Math.pow;function u(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return m;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var a;if((a=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===a)return u(e.substring(1),t,n).neg();for(var r=i(c(n,8)),o=m,s=0;s<e.length;s+=8){var l=Math.min(8,e.length-s),h=parseInt(e.substring(s,s+l),n);if(l<8){var d=i(c(n,l));o=o.mul(d).add(i(h))}else o=(o=o.mul(r)).add(i(h))}return o.unsigned=t,o}function h(e,t){return"number"===typeof e?i(e,t):"string"===typeof e?u(e,t):l(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=u,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,g=s(1<<24),m=s(0);n.ZERO=m;var b=s(0,!0);n.UZERO=b;var y=s(1);n.ONE=y;var v=s(1,!0);n.UONE=v;var x=s(-1);n.NEG_ONE=x;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=i(e),n=this.div(t),a=n.mul(t).sub(this);return n.toString(e)+a.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var r=i(c(e,6),this.unsigned),o=this,s="";;){var l=o.div(r),u=(o.sub(l.mul(r)).toInt()>>>0).toString(e);if((o=l).isZero())return u+s;for(;u.length<6;)u="0"+u;s=""+u+s}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(e){return a(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(a(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(y)},I.neg=I.negate,I.add=function(e){a(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,o=65535&this.low,s=e.high>>>16,i=65535&e.high,c=e.low>>>16,u=0,d=0,p=0,f=0;return p+=(f+=o+(65535&e.low))>>>16,d+=(p+=r+c)>>>16,u+=(d+=n+i)>>>16,u+=t+s,l((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(d&=65535),this.unsigned)},I.subtract=function(e){return a(e)||(e=h(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return m;if(a(e)||(e=h(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return m;if(this.eq(S))return e.isOdd()?S:m;if(e.eq(S))return this.isOdd()?S:m;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return i(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,r=65535&this.high,o=this.low>>>16,s=65535&this.low,c=e.high>>>16,u=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,b=0,y=0,v=0;return y+=(v+=s*p)>>>16,b+=(y+=o*p)>>>16,y&=65535,b+=(y+=s*d)>>>16,f+=(b+=r*p)>>>16,b&=65535,f+=(b+=o*d)>>>16,b&=65535,f+=(b+=s*u)>>>16,f+=n*p+r*d+o*u+s*c,l((y&=65535)<<16|(v&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(a(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,r,o;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:m;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return v;o=b}else{if(this.eq(S))return e.eq(y)||e.eq(x)?S:e.eq(S)?y:(n=this.shr(1).div(e).shl(1)).eq(m)?e.isNegative()?y:x:(r=this.sub(e.mul(n)),o=n.add(r.div(e)));if(e.eq(S))return this.unsigned?b:m;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=m}for(r=this;r.gte(e);){n=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var s=Math.ceil(Math.log(n)/Math.LN2),u=s<=48?1:c(2,s-48),d=i(n),p=d.mul(e);p.isNegative()||p.gt(r);)p=(d=i(n-=u,this.unsigned)).mul(e);d.isZero()&&(d=y),o=o.add(d),r=r.sub(p)}return o},I.div=I.divide,I.modulo=function(e){return a(e)||(e=h(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return l(~this.low,~this.high,this.unsigned)},I.and=function(e){return a(e)||(e=h(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return a(e)||(e=h(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return a(e)||(e=h(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,a){return a?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},358:(e,t)=>{"use strict";const n=/^[\u0021-\u003A\u003C\u003E-\u007E]+$/,a=/^[\u0021-\u003A\u003C-\u007E]*$/,r=/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,o=/^[\u0020-\u003A\u003D-\u007E]*$/,s=Object.prototype.toString,i=(()=>{const e=function(){};return e.prototype=Object.create(null),e})();function l(e,t,n){do{const n=e.charCodeAt(t);if(32!==n&&9!==n)return t}while(++t<n);return n}function c(e,t,n){for(;t>n;){const n=e.charCodeAt(--t);if(32!==n&&9!==n)return t+1}return n}function u(e){if(-1===e.indexOf("%"))return e;try{return decodeURIComponent(e)}catch(t){return e}}},359:function(e,t,n){var a;!function(e,r){function o(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var a=.02519603282416938*(e+=t.charCodeAt(n));a-=e=a>>>0,e=(a*=e)>>>0,e+=4294967296*(a-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function i(e,t){var n=new o(e),a=t&&t.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,a&&("object"==typeof a&&s(a,n),r.state=function(){return s(n,{})}),r}r&&r.exports?r.exports=i:n.amdD&&n.amdO?void 0===(a=function(){return i}.call(t,n,t,r))||(r.exports=a):this.alea=i}(0,e=n.nmd(e),n.amdD)},391:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(4)},430:function(e,t,n){var a;!function(r,o,s){var i,l=256,c=s.pow(l,6),u=s.pow(2,52),h=2*u,d=255;function p(e,t,n){var a=[],d=b(m((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(o)]:null==e?function(){try{var e;return i&&(e=i.randomBytes)?e=e(l):(e=new Uint8Array(l),(r.crypto||r.msCrypto).getRandomValues(e)),y(e)}catch(a){var t=r.navigator,n=t&&t.plugins;return[+new Date,r,n,r.screen,y(o)]}}():e,3),a),p=new f(a),v=function(){for(var e=p.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,b(y(p.S),o),(t.pass||n||function(e,t,n,a){return a&&(a.S&&g(a,p),e.state=function(){return g(p,{})}),n?(s.random=e,t):e})(v,d,"global"in t?t.global:this==s,t.state)}function f(e){var t,n=e.length,a=this,r=0,o=a.i=a.j=0,s=a.S=[];for(n||(e=[n++]);r<l;)s[r]=r++;for(r=0;r<l;r++)s[r]=s[o=d&o+e[r%n]+(t=s[r])],s[o]=t;(a.g=function(e){for(var t,n=0,r=a.i,o=a.j,s=a.S;e--;)t=s[r=d&r+1],n=n*l+s[d&(s[r]=s[o=d&o+t])+(s[o]=t)];return a.i=r,a.j=o,n})(l)}function g(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function m(e,t){var n,a=[],r=typeof e;if(t&&"object"==r)for(n in e)try{a.push(m(e[n],t-1))}catch(o){}return a.length?a:"string"==r?e:e+"\0"}function b(e,t){for(var n,a=e+"",r=0;r<a.length;)t[d&r]=d&(n^=19*t[d&r])+a.charCodeAt(r++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(b(s.random(),o),e.exports){e.exports=p;try{i=n(234)}catch(v){}}else void 0===(a=function(){return p}.call(t,n,t,e))||(e.exports=a)}("undefined"!==typeof self?self:this,[],Math)},530:()=>{},538:function(e,t,n){var a;!function(e,r){function o(e){var t=this;t.next=function(){var e,n,a=t.x,r=t.i;return e=a[r],n=(e^=e>>>7)^e<<24,n^=(e=a[r+1&7])^e>>>10,n^=(e=a[r+3&7])^e>>>3,n^=(e=a[r+4&7])^e<<7,e=a[r+7&7],n^=(e^=e<<13)^e<<9,a[r]=n,t.i=r+1&7,n},function(e,t){var n,a=[];if(t===(0|t))a[0]=t;else for(t=""+t,n=0;n<t.length;++n)a[7&n]=a[7&n]<<15^t.charCodeAt(n)+a[n+1&7]<<13;for(;a.length<8;)a.push(0);for(n=0;n<8&&0===a[n];++n);for(8==n?a[7]=-1:a[n],e.x=a,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function i(e,t){null==e&&(e=+new Date);var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.x&&s(a,n),r.state=function(){return s(n,{})}),r}r&&r.exports?r.exports=i:n.amdD&&n.amdO?void 0===(a=function(){return i}.call(t,n,t,r))||(r.exports=a):this.xorshift7=i}(0,e=n.nmd(e),n.amdD)},551:()=>{},579:(e,t,n)=>{"use strict";e.exports=n(799)},590:()=>{},672:(e,t,n)=>{"use strict";var a=n(43);function r(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function o(){}var s={d:{f:o,r:function(){throw Error(r(522))},D:o,C:o,L:o,m:o,X:o,S:o,M:o},p:0,findDOMNode:null},i=Symbol.for("react.portal");var l=a.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function c(e,t){return"font"===e?"":"string"===typeof t?"use-credentials"===t?t:"":void 0}t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType)throw Error(r(299));return function(e,t,n){var a=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:i,key:null==a?null:""+a,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.flushSync=function(e){var t=l.T,n=s.p;try{if(l.T=null,s.p=2,e)return e()}finally{l.T=t,s.p=n,s.d.f()}},t.preconnect=function(e,t){"string"===typeof e&&(t?t="string"===typeof(t=t.crossOrigin)?"use-credentials"===t?t:"":void 0:t=null,s.d.C(e,t))},t.prefetchDNS=function(e){"string"===typeof e&&s.d.D(e)},t.preinit=function(e,t){if("string"===typeof e&&t&&"string"===typeof t.as){var n=t.as,a=c(n,t.crossOrigin),r="string"===typeof t.integrity?t.integrity:void 0,o="string"===typeof t.fetchPriority?t.fetchPriority:void 0;"style"===n?s.d.S(e,"string"===typeof t.precedence?t.precedence:void 0,{crossOrigin:a,integrity:r,fetchPriority:o}):"script"===n&&s.d.X(e,{crossOrigin:a,integrity:r,fetchPriority:o,nonce:"string"===typeof t.nonce?t.nonce:void 0})}},t.preinitModule=function(e,t){if("string"===typeof e)if("object"===typeof t&&null!==t){if(null==t.as||"script"===t.as){var n=c(t.as,t.crossOrigin);s.d.M(e,{crossOrigin:n,integrity:"string"===typeof t.integrity?t.integrity:void 0,nonce:"string"===typeof t.nonce?t.nonce:void 0})}}else null==t&&s.d.M(e)},t.preload=function(e,t){if("string"===typeof e&&"object"===typeof t&&null!==t&&"string"===typeof t.as){var n=t.as,a=c(n,t.crossOrigin);s.d.L(e,n,{crossOrigin:a,integrity:"string"===typeof t.integrity?t.integrity:void 0,nonce:"string"===typeof t.nonce?t.nonce:void 0,type:"string"===typeof t.type?t.type:void 0,fetchPriority:"string"===typeof t.fetchPriority?t.fetchPriority:void 0,referrerPolicy:"string"===typeof t.referrerPolicy?t.referrerPolicy:void 0,imageSrcSet:"string"===typeof t.imageSrcSet?t.imageSrcSet:void 0,imageSizes:"string"===typeof t.imageSizes?t.imageSizes:void 0,media:"string"===typeof t.media?t.media:void 0})}},t.preloadModule=function(e,t){if("string"===typeof e)if(t){var n=c(t.as,t.crossOrigin);s.d.m(e,{as:"string"===typeof t.as&&"script"!==t.as?t.as:void 0,crossOrigin:n,integrity:"string"===typeof t.integrity?t.integrity:void 0})}else s.d.m(e)},t.requestFormReset=function(e){s.d.r(e)},t.unstable_batchedUpdates=function(e,t){return e(t)},t.useFormState=function(e,t,n){return l.H.useFormState(e,t,n)},t.useFormStatus=function(){return l.H.useHostTransitionStatus()},t.version="19.1.0"},799:(e,t)=>{"use strict";var n=Symbol.for("react.transitional.element"),a=Symbol.for("react.fragment");function r(e,t,a){var r=null;if(void 0!==a&&(r=""+a),void 0!==t.key&&(r=""+t.key),"key"in t)for(var o in a={},t)"key"!==o&&(a[o]=t[o]);else a=t;return t=a.ref,{$$typeof:n,type:e,key:r,ref:void 0!==t?t:null,props:a}}t.Fragment=a,t.jsx=r,t.jsxs=r},817:()=>{},844:e=>{e.exports={area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}},853:(e,t,n)=>{"use strict";e.exports=n(896)},896:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var a=n-1>>>1,r=e[a];if(!(0<o(r,t)))break e;e[a]=t,e[n]=r,n=a}}function a(e){return 0===e.length?null:e[0]}function r(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var a=0,r=e.length,s=r>>>1;a<s;){var i=2*(a+1)-1,l=e[i],c=i+1,u=e[c];if(0>o(l,n))c<r&&0>o(u,l)?(e[a]=u,e[c]=n,a=c):(e[a]=l,e[i]=n,a=i);else{if(!(c<r&&0>o(u,n)))break e;e[a]=u,e[c]=n,a=c}}}return t}function o(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if(t.unstable_now=void 0,"object"===typeof performance&&"function"===typeof performance.now){var s=performance;t.unstable_now=function(){return s.now()}}else{var i=Date,l=i.now();t.unstable_now=function(){return i.now()-l}}var c=[],u=[],h=1,d=null,p=3,f=!1,g=!1,m=!1,b=!1,y="function"===typeof setTimeout?setTimeout:null,v="function"===typeof clearTimeout?clearTimeout:null,x="undefined"!==typeof setImmediate?setImmediate:null;function w(e){for(var t=a(u);null!==t;){if(null===t.callback)r(u);else{if(!(t.startTime<=e))break;r(u),t.sortIndex=t.expirationTime,n(c,t)}t=a(u)}}function k(e){if(m=!1,w(e),!g)if(null!==a(c))g=!0,I||(I=!0,S());else{var t=a(u);null!==t&&D(k,t.startTime-e)}}var S,I=!1,C=-1,N=5,E=-1;function T(){return!!b||!(t.unstable_now()-E<N)}function R(){if(b=!1,I){var e=t.unstable_now();E=e;var n=!0;try{e:{g=!1,m&&(m=!1,v(C),C=-1),f=!0;var o=p;try{t:{for(w(e),d=a(c);null!==d&&!(d.expirationTime>e&&T());){var s=d.callback;if("function"===typeof s){d.callback=null,p=d.priorityLevel;var i=s(d.expirationTime<=e);if(e=t.unstable_now(),"function"===typeof i){d.callback=i,w(e),n=!0;break t}d===a(c)&&r(c),w(e)}else r(c);d=a(c)}if(null!==d)n=!0;else{var l=a(u);null!==l&&D(k,l.startTime-e),n=!1}}break e}finally{d=null,p=o,f=!1}n=void 0}}finally{n?S():I=!1}}}if("function"===typeof x)S=function(){x(R)};else if("undefined"!==typeof MessageChannel){var A=new MessageChannel,F=A.port2;A.port1.onmessage=R,S=function(){F.postMessage(null)}}else S=function(){y(R,0)};function D(e,n){C=y((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):N=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_requestPaint=function(){b=!0},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,r,o){var s=t.unstable_now();switch("object"===typeof o&&null!==o?o="number"===typeof(o=o.delay)&&0<o?s+o:s:o=s,e){case 1:var i=-1;break;case 2:i=250;break;case 5:i=1073741823;break;case 4:i=1e4;break;default:i=5e3}return e={id:h++,callback:r,priorityLevel:e,startTime:o,expirationTime:i=o+i,sortIndex:-1},o>s?(e.sortIndex=o,n(u,e),null===a(c)&&e===a(u)&&(m?(v(C),C=-1):m=!0,D(k,o-s))):(e.sortIndex=i,n(c,e),g||f||(g=!0,I||(I=!0,S()))),e},t.unstable_shouldYield=T,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},907:function(e,t,n){var a;!function(e,r){function o(e){var t=this;t.next=function(){var e,n,a=t.w,r=t.X,o=t.i;return t.w=a=a+1640531527|0,n=r[o+34&127],e=r[o=o+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=r[o]=n^e,t.i=o,n+(a^a>>>16)|0},function(e,t){var n,a,r,o,s,i=[],l=128;for(t===(0|t)?(a=t,t=null):(t+="\0",a=0,l=Math.max(l,t.length)),r=0,o=-32;o<l;++o)t&&(a^=t.charCodeAt((o+32)%t.length)),0===o&&(s=a),a^=a<<10,a^=a>>>15,a^=a<<4,a^=a>>>13,o>=0&&(s=s+1640531527|0,r=0==(n=i[127&o]^=a+s)?r+1:0);for(r>=128&&(i[127&(t&&t.length||0)]=-1),r=127,o=512;o>0;--o)a=i[r+34&127],n=i[r=r+1&127],a^=a<<13,n^=n<<17,a^=a>>>15,n^=n>>>12,i[r]=a^n;e.w=s,e.X=i,e.i=r}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function i(e,t){null==e&&(e=+new Date);var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.X&&s(a,n),r.state=function(){return s(n,{})}),r}r&&r.exports?r.exports=i:n.amdD&&n.amdO?void 0===(a=function(){return i}.call(t,n,t,r))||(r.exports=a):this.xor4096=i}(0,e=n.nmd(e),n.amdD)},950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(672)}},t={};function n(a){var r=t[a];if(void 0!==r)return r.exports;var o=t[a]={id:a,loaded:!1,exports:{}};return e[a].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.f={},n.e=e=>Promise.all(Object.keys(n.f).reduce(((t,a)=>(n.f[a](e,t),t)),[])),n.u=e=>"static/js/"+e+".5e560239.chunk.js",n.miniCssF=e=>{},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e={},t="project:";n.l=(a,r,o,s)=>{if(e[a])e[a].push(r);else{var i,l;if(void 0!==o)for(var c=document.getElementsByTagName("script"),u=0;u<c.length;u++){var h=c[u];if(h.getAttribute("src")==a||h.getAttribute("data-webpack")==t+o){i=h;break}}i||(l=!0,(i=document.createElement("script")).charset="utf-8",i.timeout=120,n.nc&&i.setAttribute("nonce",n.nc),i.setAttribute("data-webpack",t+o),i.src=a),e[a]=[r];var d=(t,n)=>{i.onerror=i.onload=null,clearTimeout(p);var r=e[a];if(delete e[a],i.parentNode&&i.parentNode.removeChild(i),r&&r.forEach((e=>e(n))),t)return t(n)},p=setTimeout(d.bind(null,void 0,{type:"timeout",target:i}),12e4);i.onerror=d.bind(null,i.onerror),i.onload=d.bind(null,i.onload),l&&document.head.appendChild(i)}}})(),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),n.p="/",(()=>{var e={792:0};n.f.j=(t,a)=>{var r=n.o(e,t)?e[t]:void 0;if(0!==r)if(r)a.push(r[2]);else{var o=new Promise(((n,a)=>r=e[t]=[n,a]));a.push(r[2]=o);var s=n.p+n.u(t),i=new Error;n.l(s,(a=>{if(n.o(e,t)&&(0!==(r=e[t])&&(e[t]=void 0),r)){var o=a&&("load"===a.type?"missing":a.type),s=a&&a.target&&a.target.src;i.message="Loading chunk "+t+" failed.\n("+o+": "+s+")",i.name="ChunkLoadError",i.type=o,i.request=s,r[1](i)}}),"chunk-"+t,t)}};var t=(t,a)=>{var r,o,s=a[0],i=a[1],l=a[2],c=0;if(s.some((t=>0!==e[t]))){for(r in i)n.o(i,r)&&(n.m[r]=i[r]);if(l)l(n)}for(t&&t(a);c<s.length;c++)o=s[c],n.o(e,o)&&e[o]&&e[o][0](),e[o]=0},a=self.webpackChunkproject=self.webpackChunkproject||[];a.forEach(t.bind(null,0)),a.push=t.bind(null,a.push.bind(a))})(),(()=>{"use strict";var e={};n.r(e),n.d(e,{assertParamsValid:()=>Vl,computeFlatOffset:()=>tc,computeOutShape:()=>jl,getNormalizedAxes:()=>Xl,isSliceContinous:()=>ec,maskToAxes:()=>Gl,parseSliceParams:()=>nc,sliceInfo:()=>ac,startForAxis:()=>Ql,startIndicesWithElidedDims:()=>Yl,stopForAxis:()=>Zl,stopIndicesWithElidedDims:()=>Jl,stridesForAxis:()=>$l,stridesWithElidedDims:()=>Hl});var t={};n.r(t),n.d(t,{collectGatherOpShapeInfo:()=>wp,computeOutShape:()=>xp,segOpComputeOptimalWindowSize:()=>vp});var a={};n.r(a),n.d(a,{ERF_A1:()=>Md,ERF_A2:()=>Pd,ERF_A3:()=>Bd,ERF_A4:()=>Wd,ERF_A5:()=>Ud,ERF_P:()=>zd,PARALLELIZE_THRESHOLD:()=>kd,RowPartitionType:()=>bd,SELU_SCALE:()=>Ld,SELU_SCALEALPHA:()=>Od,applyActivation:()=>xh,assertAndGetBroadcastShape:()=>kl,assertAxesAreInnerMostDims:()=>pu,assertParamsConsistent:()=>gd,assignToTypedArray:()=>qd,axesAreInnerMostDims:()=>cu,calculateShapes:()=>_d,checkEinsumDimSizes:()=>np,checkPadOnDimRoundingMode:()=>kc,combineLocations:()=>uu,combineRaggedTensorToTensorShapes:()=>yd,complexWithEvenIndex:()=>jd,complexWithOddIndex:()=>Hd,computeConv2DInfo:()=>hc,computeConv3DInfo:()=>dc,computeDefaultPad:()=>pc,computeDilation2DInfo:()=>lc,computeOptimalWindowSize:()=>Sd,computeOutAndReduceShapes:()=>hu,computeOutShape:()=>md,computePool2DInfo:()=>cc,computePool3DInfo:()=>uc,convertConv2DDataFormat:()=>wc,decodeEinsumEquation:()=>ep,eitherStridesOrDilationsAreOne:()=>vc,expandShapeToKeepDim:()=>du,exponent:()=>Yd,exponents:()=>Xd,fromStringArrayToUint8:()=>Sp,fromUint8ToStringArray:()=>kp,getAxesPermutation:()=>fu,getBroadcastDims:()=>xl,getComplexWithIndex:()=>Kd,getEinsumComputePath:()=>ap,getEinsumPermutation:()=>tp,getFusedBiasGradient:()=>vh,getFusedDyActivation:()=>yh,getImageCenter:()=>Id,getInnerMostAxes:()=>mu,getPermuted:()=>Nd,getRaggedRank:()=>xd,getReductionAxes:()=>wl,getReshaped:()=>Cd,getReshapedPermuted:()=>Ed,getRowPartitionTypesHelper:()=>vd,getSliceBeginCoords:()=>Td,getSliceSize:()=>Rd,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>ip,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>lp,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>cp,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>dp,getSparseReshapeInputOutputMismatchErrorMessage:()=>fp,getSparseReshapeInputOutputMultipleErrorMessage:()=>pp,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>up,getSparseReshapeNegativeOutputDimErrorMessage:()=>hp,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>yp,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>gp,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>mp,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>bp,getUndoAxesPermutation:()=>gu,isIdentityPermutation:()=>rp,log:()=>Ao,mergeRealAndImagArrays:()=>Vd,prepareAndValidate:()=>Ad,prepareSplitSize:()=>sp,segment_util:()=>t,shouldFuse:()=>wh,slice_util:()=>e,splitRealAndImagArrays:()=>Gd,stridesOrDilationsArePositive:()=>xc,tupleValuesAreOne:()=>yc,upcastType:()=>Ts,validateDefaultValueShape:()=>wd,validateInput:()=>Dd,validateUpdateShape:()=>Fd,warn:()=>Ro});var r={};n.r(r),n.d(r,{mx:()=>mS,XI:()=>lI,Nk:()=>cI,f6:()=>hI,ct:()=>hS,YG:()=>fI,hH:()=>xI,z3:()=>rC,sG:()=>gC,uM:()=>xC,vS:()=>MC,qB:()=>HC,GG:()=>qC,lg:()=>QC,rq:()=>YC,cu:()=>hN,WR:()=>lN,GE:()=>fN,px:()=>mN,jC:()=>FN,He:()=>ON,hE:()=>jN,BF:()=>JI,Dk:()=>eE,cl:()=>lE,_B:()=>wE,ub:()=>NE,_f:()=>RE,Ku:()=>LE,qy:()=>ME,Zy:()=>YE,bu:()=>QE,zv:()=>nS,dH:()=>CS,HS:()=>rI,yH:()=>yT,l3:()=>xT,z9:()=>kT,x6:()=>ET,_m:()=>OT,eW:()=>BT,GK:()=>VT,SP:()=>HT,yr:()=>qT,dl:()=>NC,Dw:()=>ZT,xT:()=>aR,_X:()=>DS,wz:()=>uR});var o=n(43),s=n(391);function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n={};for(var a in e)if({}.hasOwnProperty.call(e,a)){if(-1!==t.indexOf(a))continue;n[a]=e[a]}return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],-1===t.indexOf(n)&&{}.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}function l(e){return l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},l(e)}function c(e){var t=function(e,t){if("object"!=l(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var a=n.call(e,t||"default");if("object"!=l(a))return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==l(t)?t:t+""}function u(e,t,n){return(t=c(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function h(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function d(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?h(Object(n),!0).forEach((function(t){u(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):h(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}n(358);const p=["sri"],f=["page"],g=["page","matches"],m=["onClick","discover","prefetch","relative","reloadDocument","replace","state","target","to","preventScrollReset","viewTransition"],b=["aria-current","caseSensitive","className","end","style","to","viewTransition","children"],y=["discover","fetcherKey","navigate","reloadDocument","replace","state","method","action","onSubmit","relative","preventScrollReset","viewTransition"];var v="popstate";function x(){return E((function(e,t){let{pathname:n,search:a,hash:r}=e.location;return I("",{pathname:n,search:a,hash:r},t.state&&t.state.usr||null,t.state&&t.state.key||"default")}),(function(e,t){return"string"===typeof t?t:C(t)}),null,arguments.length>0&&void 0!==arguments[0]?arguments[0]:{})}function w(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}function k(e,t){if(!e){"undefined"!==typeof console&&console.warn(t);try{throw new Error(t)}catch(n){}}}function S(e,t){return{usr:e.state,key:e.key,idx:t}}function I(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3?arguments[3]:void 0;return d(d({pathname:"string"===typeof e?e:e.pathname,search:"",hash:""},"string"===typeof t?N(t):t),{},{state:n,key:t&&t.key||a||Math.random().toString(36).substring(2,10)})}function C(e){let{pathname:t="/",search:n="",hash:a=""}=e;return n&&"?"!==n&&(t+="?"===n.charAt(0)?n:"?"+n),a&&"#"!==a&&(t+="#"===a.charAt(0)?a:"#"+a),t}function N(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substring(n),e=e.substring(0,n));let a=e.indexOf("?");a>=0&&(t.search=e.substring(a),e=e.substring(0,a)),e&&(t.pathname=e)}return t}function E(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},{window:r=document.defaultView,v5Compat:o=!1}=a,s=r.history,i="POP",l=null,c=u();function u(){return(s.state||{idx:null}).idx}function h(){i="POP";let e=u(),t=null==e?null:e-c;c=e,l&&l({action:i,location:f.location,delta:t})}function p(e){return T(e)}null==c&&(c=0,s.replaceState(d(d({},s.state),{},{idx:c}),""));let f={get action(){return i},get location(){return e(r,s)},listen(e){if(l)throw new Error("A history only accepts one active listener");return r.addEventListener(v,h),l=e,()=>{r.removeEventListener(v,h),l=null}},createHref:e=>t(r,e),createURL:p,encodeLocation(e){let t=p(e);return{pathname:t.pathname,search:t.search,hash:t.hash}},push:function(e,t){i="PUSH";let a=I(f.location,e,t);n&&n(a,e),c=u()+1;let h=S(a,c),d=f.createHref(a);try{s.pushState(h,"",d)}catch(p){if(p instanceof DOMException&&"DataCloneError"===p.name)throw p;r.location.assign(d)}o&&l&&l({action:i,location:f.location,delta:1})},replace:function(e,t){i="REPLACE";let a=I(f.location,e,t);n&&n(a,e),c=u();let r=S(a,c),h=f.createHref(a);s.replaceState(r,"",h),o&&l&&l({action:i,location:f.location,delta:0})},go:e=>s.go(e)};return f}function T(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n="http://localhost";"undefined"!==typeof window&&(n="null"!==window.location.origin?window.location.origin:window.location.href),w(n,"No window.location.(origin|href) available to create URL");let a="string"===typeof e?e:C(e);return a=a.replace(/ $/,"%20"),!t&&a.startsWith("//")&&(a=n+a),new URL(a,n)}new WeakMap;function R(e,t){return A(e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:"/",!1)}function A(e,t,n,a){let r=H(("string"===typeof t?N(t):t).pathname||"/",n);if(null==r)return null;let o=F(e);!function(e){e.sort(((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){let n=e.length===t.length&&e.slice(0,-1).every(((e,n)=>e===t[n]));return n?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map((e=>e.childrenIndex)),t.routesMeta.map((e=>e.childrenIndex)))))}(o);let s=null;for(let i=0;null==s&&i<o.length;++i){let e=j(r);s=U(o[i],e,a)}return s}function F(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"",r=(e,r,o)=>{let s={relativePath:void 0===o?e.path||"":o,caseSensitive:!0===e.caseSensitive,childrenIndex:r,route:e};s.relativePath.startsWith("/")&&(w(s.relativePath.startsWith(a),'Absolute route path "'.concat(s.relativePath,'" nested under path "').concat(a,'" is not valid. An absolute child route path must start with the combined path of all its parent routes.')),s.relativePath=s.relativePath.slice(a.length));let i=J([a,s.relativePath]),l=n.concat(s);e.children&&e.children.length>0&&(w(!0!==e.index,'Index routes must not have child routes. Please remove all child routes from route path "'.concat(i,'".')),F(e.children,t,l,i)),(null!=e.path||e.index)&&t.push({path:i,score:W(i,e.index),routesMeta:l})};return e.forEach(((e,t)=>{var n;if(""!==e.path&&null!==(n=e.path)&&void 0!==n&&n.includes("?"))for(let a of D(e.path))r(e,t,a);else r(e,t)})),t}function D(e){let t=e.split("/");if(0===t.length)return[];let[n,...a]=t,r=n.endsWith("?"),o=n.replace(/\?$/,"");if(0===a.length)return r?[o,""]:[o];let s=D(a.join("/")),i=[];return i.push(...s.map((e=>""===e?o:[o,e].join("/")))),r&&i.push(...s),i.map((t=>e.startsWith("/")&&""===t?"/":t))}var _=/^:[\w-]+$/,O=3,L=2,z=1,M=10,P=-2,B=e=>"*"===e;function W(e,t){let n=e.split("/"),a=n.length;return n.some(B)&&(a+=P),t&&(a+=L),n.filter((e=>!B(e))).reduce(((e,t)=>e+(_.test(t)?O:""===t?z:M)),a)}function U(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{routesMeta:a}=e,r={},o="/",s=[];for(let i=0;i<a.length;++i){let e=a[i],l=i===a.length-1,c="/"===o?t:t.slice(o.length)||"/",u=V({path:e.relativePath,caseSensitive:e.caseSensitive,end:l},c),h=e.route;if(!u&&l&&n&&!a[a.length-1].route.index&&(u=V({path:e.relativePath,caseSensitive:e.caseSensitive,end:!1},c)),!u)return null;Object.assign(r,u.params),s.push({params:r,pathname:J([o,u.pathname]),pathnameBase:$(J([o,u.pathnameBase])),route:h}),"/"!==u.pathnameBase&&(o=J([o,u.pathnameBase]))}return s}function V(e,t){"string"===typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,a]=G(e.path,e.caseSensitive,e.end),r=t.match(n);if(!r)return null;let o=r[0],s=o.replace(/(.)\/+$/,"$1"),i=r.slice(1);return{params:a.reduce(((e,t,n)=>{let{paramName:a,isOptional:r}=t;if("*"===a){let e=i[n]||"";s=o.slice(0,o.length-e.length).replace(/(.)\/+$/,"$1")}const l=i[n];return e[a]=r&&!l?void 0:(l||"").replace(/%2F/g,"/"),e}),{}),pathname:o,pathnameBase:s,pattern:e}}function G(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];k("*"===e||!e.endsWith("*")||e.endsWith("/*"),'Route path "'.concat(e,'" will be treated as if it were "').concat(e.replace(/\*$/,"/*"),'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "').concat(e.replace(/\*$/,"/*"),'".'));let a=[],r="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((e,t,n)=>(a.push({paramName:t,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));return e.endsWith("*")?(a.push({paramName:"*"}),r+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?r+="\\/*$":""!==e&&"/"!==e&&(r+="(?:(?=\\/|$))"),[new RegExp(r,t?void 0:"i"),a]}function j(e){try{return e.split("/").map((e=>decodeURIComponent(e).replace(/\//g,"%2F"))).join("/")}catch(t){return k(!1,'The URL path "'.concat(e,'" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (').concat(t,").")),e}}function H(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,a=e.charAt(n);return a&&"/"!==a?null:e.slice(n)||"/"}function K(e,t,n,a){return"Cannot include a '".concat(e,"' character in a manually specified `to.").concat(t,"` field [").concat(JSON.stringify(a),"].  Please separate it out to the `to.").concat(n,'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.')}function q(e){return e.filter(((e,t)=>0===t||e.route.path&&e.route.path.length>0))}function X(e){let t=q(e);return t.map(((e,n)=>n===t.length-1?e.pathname:e.pathnameBase))}function Y(e,t,n){let a,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];"string"===typeof e?a=N(e):(a=d({},e),w(!a.pathname||!a.pathname.includes("?"),K("?","pathname","search",a)),w(!a.pathname||!a.pathname.includes("#"),K("#","pathname","hash",a)),w(!a.search||!a.search.includes("#"),K("#","search","hash",a)));let o,s=""===e||""===a.pathname,i=s?"/":a.pathname;if(null==i)o=n;else{let e=t.length-1;if(!r&&i.startsWith("..")){let t=i.split("/");for(;".."===t[0];)t.shift(),e-=1;a.pathname=t.join("/")}o=e>=0?t[e]:"/"}let l=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"/",{pathname:n,search:a="",hash:r=""}="string"===typeof e?N(e):e,o=n?n.startsWith("/")?n:function(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach((e=>{".."===e?n.length>1&&n.pop():"."!==e&&n.push(e)})),n.length>1?n.join("/"):"/"}(n,t):t;return{pathname:o,search:Q(a),hash:Z(r)}}(a,o),c=i&&"/"!==i&&i.endsWith("/"),u=(s||"."===i)&&n.endsWith("/");return l.pathname.endsWith("/")||!c&&!u||(l.pathname+="/"),l}var J=e=>e.join("/").replace(/\/\/+/g,"/"),$=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),Q=e=>e&&"?"!==e?e.startsWith("?")?e:"?"+e:"",Z=e=>e&&"#"!==e?e.startsWith("#")?e:"#"+e:"";function ee(e){return null!=e&&"number"===typeof e.status&&"string"===typeof e.statusText&&"boolean"===typeof e.internal&&"data"in e}var te=["POST","PUT","PATCH","DELETE"],ne=(new Set(te),["GET",...te]);new Set(ne),Symbol("ResetLoaderData");var ae=o.createContext(null);ae.displayName="DataRouter";var re=o.createContext(null);re.displayName="DataRouterState";var oe=o.createContext({isTransitioning:!1});oe.displayName="ViewTransition";var se=o.createContext(new Map);se.displayName="Fetchers";var ie=o.createContext(null);ie.displayName="Await";var le=o.createContext(null);le.displayName="Navigation";var ce=o.createContext(null);ce.displayName="Location";var ue=o.createContext({outlet:null,matches:[],isDataRoute:!1});ue.displayName="Route";var he=o.createContext(null);he.displayName="RouteError";function de(){return null!=o.useContext(ce)}function pe(){return w(de(),"useLocation() may be used only in the context of a <Router> component."),o.useContext(ce).location}var fe="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function ge(e){o.useContext(le).static||o.useLayoutEffect(e)}function me(){let{isDataRoute:e}=o.useContext(ue);return e?function(){let{router:e}=Ce("useNavigate"),t=Ee("useNavigate"),n=o.useRef(!1);ge((()=>{n.current=!0}));let a=o.useCallback((async function(a){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};k(n.current,fe),n.current&&("number"===typeof a?e.navigate(a):await e.navigate(a,d({fromRouteId:t},r)))}),[e,t]);return a}():function(){w(de(),"useNavigate() may be used only in the context of a <Router> component.");let e=o.useContext(ae),{basename:t,navigator:n}=o.useContext(le),{matches:a}=o.useContext(ue),{pathname:r}=pe(),s=JSON.stringify(X(a)),i=o.useRef(!1);ge((()=>{i.current=!0}));let l=o.useCallback((function(a){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(k(i.current,fe),!i.current)return;if("number"===typeof a)return void n.go(a);let l=Y(a,JSON.parse(s),r,"path"===o.relative);null==e&&"/"!==t&&(l.pathname="/"===l.pathname?t:J([t,l.pathname])),(o.replace?n.replace:n.push)(l,o.state,o)}),[t,n,s,r,e]);return l}()}o.createContext(null);function be(e){let{relative:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{matches:n}=o.useContext(ue),{pathname:a}=pe(),r=JSON.stringify(X(n));return o.useMemo((()=>Y(e,JSON.parse(r),a,"path"===t)),[e,r,a,t])}function ye(e,t,n,a){w(de(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:r}=o.useContext(le),{matches:s}=o.useContext(ue),i=s[s.length-1],l=i?i.params:{},c=i?i.pathname:"/",u=i?i.pathnameBase:"/",h=i&&i.route;{let e=h&&h.path||"";Ae(c,!h||e.endsWith("*")||e.endsWith("*?"),'You rendered descendant <Routes> (or called `useRoutes()`) at "'.concat(c,'" (under <Route path="').concat(e,'">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won\'t match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="').concat(e,'"> to <Route path="').concat("/"===e?"*":"".concat(e,"/*"),'">.'))}let p,f=pe();if(t){var g;let e="string"===typeof t?N(t):t;w("/"===u||(null===(g=e.pathname)||void 0===g?void 0:g.startsWith(u)),'When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "'.concat(u,'" but pathname "').concat(e.pathname,'" was given in the `location` prop.')),p=e}else p=f;let m=p.pathname||"/",b=m;if("/"!==u){let e=u.replace(/^\//,"").split("/");b="/"+m.replace(/^\//,"").split("/").slice(e.length).join("/")}let y=R(e,{pathname:b});k(h||null!=y,'No routes matched location "'.concat(p.pathname).concat(p.search).concat(p.hash,'" ')),k(null==y||void 0!==y[y.length-1].route.element||void 0!==y[y.length-1].route.Component||void 0!==y[y.length-1].route.lazy,'Matched leaf route at location "'.concat(p.pathname).concat(p.search).concat(p.hash,'" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));let v=Se(y&&y.map((e=>Object.assign({},e,{params:Object.assign({},l,e.params),pathname:J([u,r.encodeLocation?r.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:"/"===e.pathnameBase?u:J([u,r.encodeLocation?r.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])}))),s,n,a);return t&&v?o.createElement(ce.Provider,{value:{location:d({pathname:"/",search:"",hash:"",state:null,key:"default"},p),navigationType:"POP"}},v):v}function ve(){let e=Te(),t=ee(e)?"".concat(e.status," ").concat(e.statusText):e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,a="rgba(200,200,200, 0.5)",r={padding:"0.5rem",backgroundColor:a},s={padding:"2px 4px",backgroundColor:a},i=null;return console.error("Error handled by React Router default ErrorBoundary:",e),i=o.createElement(o.Fragment,null,o.createElement("p",null,"\ud83d\udcbf Hey developer \ud83d\udc4b"),o.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",o.createElement("code",{style:s},"ErrorBoundary")," or"," ",o.createElement("code",{style:s},"errorElement")," prop on your route.")),o.createElement(o.Fragment,null,o.createElement("h2",null,"Unexpected Application Error!"),o.createElement("h3",{style:{fontStyle:"italic"}},t),n?o.createElement("pre",{style:r},n):null,i)}var xe=o.createElement(ve,null),we=class extends o.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:void 0!==e.error?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?o.createElement(ue.Provider,{value:this.props.routeContext},o.createElement(he.Provider,{value:this.state.error,children:this.props.component})):this.props.children}};function ke(e){let{routeContext:t,match:n,children:a}=e,r=o.useContext(ae);return r&&r.static&&r.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(r.staticContext._deepestRenderedBoundaryId=n.route.id),o.createElement(ue.Provider,{value:t},a)}function Se(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(null==e){if(!n)return null;if(n.errors)e=n.matches;else{if(0!==t.length||n.initialized||!(n.matches.length>0))return null;e=n.matches}}let a=e,r=null===n||void 0===n?void 0:n.errors;if(null!=r){let e=a.findIndex((e=>e.route.id&&void 0!==(null===r||void 0===r?void 0:r[e.route.id])));w(e>=0,"Could not find a matching route for errors on route IDs: ".concat(Object.keys(r).join(","))),a=a.slice(0,Math.min(a.length,e+1))}let s=!1,i=-1;if(n)for(let o=0;o<a.length;o++){let e=a[o];if((e.route.HydrateFallback||e.route.hydrateFallbackElement)&&(i=o),e.route.id){let{loaderData:t,errors:r}=n,o=e.route.loader&&!t.hasOwnProperty(e.route.id)&&(!r||void 0===r[e.route.id]);if(e.route.lazy||o){s=!0,a=i>=0?a.slice(0,i+1):[a[0]];break}}}return a.reduceRight(((e,l,c)=>{let u,h=!1,d=null,p=null;n&&(u=r&&l.route.id?r[l.route.id]:void 0,d=l.route.errorElement||xe,s&&(i<0&&0===c?(Ae("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),h=!0,p=null):i===c&&(h=!0,p=l.route.hydrateFallbackElement||null)));let f=t.concat(a.slice(0,c+1)),g=()=>{let t;return t=u?d:h?p:l.route.Component?o.createElement(l.route.Component,null):l.route.element?l.route.element:e,o.createElement(ke,{match:l,routeContext:{outlet:e,matches:f,isDataRoute:null!=n},children:t})};return n&&(l.route.ErrorBoundary||l.route.errorElement||0===c)?o.createElement(we,{location:n.location,revalidation:n.revalidation,component:d,error:u,children:g(),routeContext:{outlet:null,matches:f,isDataRoute:!0}}):g()}),null)}function Ie(e){return"".concat(e," must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.")}function Ce(e){let t=o.useContext(ae);return w(t,Ie(e)),t}function Ne(e){let t=o.useContext(re);return w(t,Ie(e)),t}function Ee(e){let t=function(e){let t=o.useContext(ue);return w(t,Ie(e)),t}(e),n=t.matches[t.matches.length-1];return w(n.route.id,"".concat(e,' can only be used on routes that contain a unique "id"')),n.route.id}function Te(){var e;let t=o.useContext(he),n=Ne("useRouteError"),a=Ee("useRouteError");return void 0!==t?t:null===(e=n.errors)||void 0===e?void 0:e[a]}var Re={};function Ae(e,t,n){t||Re[e]||(Re[e]=!0,k(!1,n))}o.memo((function(e){let{routes:t,future:n,state:a}=e;return ye(t,void 0,a,n)}));function Fe(e){w(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function De(e){let{basename:t="/",children:n=null,location:a,navigationType:r="POP",navigator:s,static:i=!1}=e;w(!de(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let l=t.replace(/^\/*/,"/"),c=o.useMemo((()=>({basename:l,navigator:s,static:i,future:{}})),[l,s,i]);"string"===typeof a&&(a=N(a));let{pathname:u="/",search:h="",hash:d="",state:p=null,key:f="default"}=a,g=o.useMemo((()=>{let e=H(u,l);return null==e?null:{location:{pathname:e,search:h,hash:d,state:p,key:f},navigationType:r}}),[l,u,h,d,p,f,r]);return k(null!=g,'<Router basename="'.concat(l,'"> is not able to match the URL "').concat(u).concat(h).concat(d,"\" because it does not start with the basename, so the <Router> won't render anything.")),null==g?null:o.createElement(le.Provider,{value:c},o.createElement(ce.Provider,{children:n,value:g}))}function _e(e){let{children:t,location:n}=e;return ye(Oe(t),n)}o.Component;function Oe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=[];return o.Children.forEach(e,((e,a)=>{if(!o.isValidElement(e))return;let r=[...t,a];if(e.type===o.Fragment)return void n.push.apply(n,Oe(e.props.children,r));w(e.type===Fe,"[".concat("string"===typeof e.type?e.type:e.type.name,"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>")),w(!e.props.index||!e.props.children,"An index route cannot have child routes.");let s={id:e.props.id||r.join("-"),caseSensitive:e.props.caseSensitive,element:e.props.element,Component:e.props.Component,index:e.props.index,path:e.props.path,loader:e.props.loader,action:e.props.action,hydrateFallbackElement:e.props.hydrateFallbackElement,HydrateFallback:e.props.HydrateFallback,errorElement:e.props.errorElement,ErrorBoundary:e.props.ErrorBoundary,hasErrorBoundary:!0===e.props.hasErrorBoundary||null!=e.props.ErrorBoundary||null!=e.props.errorElement,shouldRevalidate:e.props.shouldRevalidate,handle:e.props.handle,lazy:e.props.lazy};e.props.children&&(s.children=Oe(e.props.children,r)),n.push(s)})),n}var Le="get",ze="application/x-www-form-urlencoded";function Me(e){return null!=e&&"string"===typeof e.tagName}var Pe=null;var Be=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function We(e){return null==e||Be.has(e)?e:(k(!1,'"'.concat(e,'" is not a valid `encType` for `<Form>`/`<fetcher.Form>` and will default to "').concat(ze,'"')),null)}function Ue(e,t){let n,a,r,o,s;if(Me(i=e)&&"form"===i.tagName.toLowerCase()){let s=e.getAttribute("action");a=s?H(s,t):null,n=e.getAttribute("method")||Le,r=We(e.getAttribute("enctype"))||ze,o=new FormData(e)}else if(function(e){return Me(e)&&"button"===e.tagName.toLowerCase()}(e)||function(e){return Me(e)&&"input"===e.tagName.toLowerCase()}(e)&&("submit"===e.type||"image"===e.type)){let s=e.form;if(null==s)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let i=e.getAttribute("formaction")||s.getAttribute("action");if(a=i?H(i,t):null,n=e.getAttribute("formmethod")||s.getAttribute("method")||Le,r=We(e.getAttribute("formenctype"))||We(s.getAttribute("enctype"))||ze,o=new FormData(s,e),!function(){if(null===Pe)try{new FormData(document.createElement("form"),0),Pe=!1}catch(e){Pe=!0}return Pe}()){let{name:t,type:n,value:a}=e;if("image"===n){let e=t?"".concat(t,"."):"";o.append("".concat(e,"x"),"0"),o.append("".concat(e,"y"),"0")}else t&&o.append(t,a)}}else{if(Me(e))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');n=Le,a=null,r=ze,s=e}var i;return o&&"text/plain"===r&&(s=o,o=void 0),{action:a,method:n.toLowerCase(),encType:r,formData:o,body:s}}function Ve(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}async function Ge(e,t){if(e.id in t)return t[e.id];try{let n=await import(e.module);return t[e.id]=n,n}catch(n){return console.error("Error loading route module `".concat(e.module,"`, reloading page...")),console.error(n),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise((()=>{}))}}function je(e){return null!=e&&"string"===typeof e.page}function He(e){return null!=e&&(null==e.href?"preload"===e.rel&&"string"===typeof e.imageSrcSet&&"string"===typeof e.imageSizes:"string"===typeof e.rel&&"string"===typeof e.href)}function Ke(e,t,n,a,r,o){let s=(e,t)=>!n[t]||e.route.id!==n[t].route.id,i=(e,t)=>{var a;return n[t].pathname!==e.pathname||(null===(a=n[t].route.path)||void 0===a?void 0:a.endsWith("*"))&&n[t].params["*"]!==e.params["*"]};return"assets"===o?t.filter(((e,t)=>s(e,t)||i(e,t))):"data"===o?t.filter(((t,o)=>{let l=a.routes[t.route.id];if(!l||!l.hasLoader)return!1;if(s(t,o)||i(t,o))return!0;if(t.route.shouldRevalidate){var c;let a=t.route.shouldRevalidate({currentUrl:new URL(r.pathname+r.search+r.hash,window.origin),currentParams:(null===(c=n[0])||void 0===c?void 0:c.params)||{},nextUrl:new URL(e,window.origin),nextParams:t.params,defaultShouldRevalidate:!0});if("boolean"===typeof a)return a}return!0})):[]}function qe(e,t){let{includeHydrateFallback:n}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return a=e.map((e=>{let a=t.routes[e.route.id];if(!a)return[];let r=[a.module];return a.clientActionModule&&(r=r.concat(a.clientActionModule)),a.clientLoaderModule&&(r=r.concat(a.clientLoaderModule)),n&&a.hydrateFallbackModule&&(r=r.concat(a.hydrateFallbackModule)),a.imports&&(r=r.concat(a.imports)),r})).flat(1),[...new Set(a)];var a}function Xe(e,t){let n=new Set,a=new Set(t);return e.reduce(((e,r)=>{if(t&&!je(r)&&"script"===r.as&&r.href&&a.has(r.href))return e;let o=JSON.stringify(function(e){let t={},n=Object.keys(e).sort();for(let a of n)t[a]=e[a];return t}(r));return n.has(o)||(n.add(o),e.push({key:o,link:r})),e}),[])}function Ye(e){return{__html:e}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");"undefined"!==typeof window?window:"undefined"!==typeof globalThis&&globalThis;Symbol("SingleFetchRedirect");var Je=new Set([100,101,204,205]);function $e(e,t){let n="string"===typeof e?new URL(e,"undefined"===typeof window?"server://singlefetch/":window.location.origin):e;return"/"===n.pathname?n.pathname="_root.data":t&&"/"===H(n.pathname,t)?n.pathname="".concat(t.replace(/\/$/,""),"/_root.data"):n.pathname="".concat(n.pathname.replace(/\/$/,""),".data"),n}o.Component;function Qe(e){let{error:t,isOutsideRemixApp:n}=e;console.error(t);let a,r=o.createElement("script",{dangerouslySetInnerHTML:{__html:'\n        console.log(\n          "\ud83d\udcbf Hey developer \ud83d\udc4b. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information."\n        );\n      '}});if(ee(t))return o.createElement(Ze,{title:"Unhandled Thrown Response!"},o.createElement("h1",{style:{fontSize:"24px"}},t.status," ",t.statusText),r);if(t instanceof Error)0;else{let e=null==t?"Unknown Error":"object"===typeof t&&"toString"in t?t.toString():JSON.stringify(t);new Error(e)}return o.createElement(Ze,{title:"Application Error!",isOutsideRemixApp:n},o.createElement("h1",{style:{fontSize:"24px"}},"Application Error"),o.createElement("pre",{style:{padding:"2rem",background:"hsla(10, 50%, 50%, 0.1)",color:"red",overflow:"auto"}},a.stack),r)}function Ze(e){var t;let{title:n,renderScripts:a,isOutsideRemixApp:r,children:s}=e,{routeModules:i}=rt();return null!==i.root&&void 0!==t&&t.Layout&&!r?s:o.createElement("html",{lang:"en"},o.createElement("head",null,o.createElement("meta",{charSet:"utf-8"}),o.createElement("meta",{name:"viewport",content:"width=device-width,initial-scale=1,viewport-fit=cover"}),o.createElement("title",null,n)),o.createElement("body",null,o.createElement("main",{style:{fontFamily:"system-ui, sans-serif",padding:"2rem"}},s,a?o.createElement(ht,null):null)))}function et(e,t){return"lazy"===e.mode&&!0===t}function tt(){let e=o.useContext(ae);return Ve(e,"You must render this element inside a <DataRouterContext.Provider> element"),e}function nt(){let e=o.useContext(re);return Ve(e,"You must render this element inside a <DataRouterStateContext.Provider> element"),e}var at=o.createContext(void 0);function rt(){let e=o.useContext(at);return Ve(e,"You must render this element inside a <HydratedRouter> element"),e}function ot(e,t){return n=>{e&&e(n),n.defaultPrevented||t(n)}}function st(e,t,n){if(n&&!ut)return[e[0]];if(t){let n=e.findIndex((e=>void 0!==t[e.route.id]));return e.slice(0,n+1)}return e}function it(e){let{page:t}=e,n=i(e,f),{router:a}=tt(),r=o.useMemo((()=>R(a.routes,t,a.basename)),[a.routes,t,a.basename]);return r?o.createElement(ct,d({page:t,matches:r},n)):null}function lt(e){let{manifest:t,routeModules:n}=rt(),[a,r]=o.useState([]);return o.useEffect((()=>{let a=!1;return async function(e,t,n){let a=await Promise.all(e.map((async e=>{let a=t.routes[e.route.id];if(a){let e=await Ge(a,n);return e.links?e.links():[]}return[]})));return Xe(a.flat(1).filter(He).filter((e=>"stylesheet"===e.rel||"preload"===e.rel)).map((e=>"stylesheet"===e.rel?d(d({},e),{},{rel:"prefetch",as:"style"}):d(d({},e),{},{rel:"prefetch"}))))}(e,t,n).then((e=>{a||r(e)})),()=>{a=!0}}),[e,t,n]),a}function ct(e){let{page:t,matches:n}=e,a=i(e,g),r=pe(),{manifest:s,routeModules:l}=rt(),{basename:c}=tt(),{loaderData:u,matches:h}=nt(),p=o.useMemo((()=>Ke(t,n,h,s,r,"data")),[t,n,h,s,r]),f=o.useMemo((()=>Ke(t,n,h,s,r,"assets")),[t,n,h,s,r]),m=o.useMemo((()=>{if(t===r.pathname+r.search+r.hash)return[];let e=new Set,a=!1;if(n.forEach((t=>{var n;let r=s.routes[t.route.id];r&&r.hasLoader&&(!p.some((e=>e.route.id===t.route.id))&&t.route.id in u&&null!==(n=l[t.route.id])&&void 0!==n&&n.shouldRevalidate||r.hasClientLoader?a=!0:e.add(t.route.id))})),0===e.size)return[];let o=$e(t,c);return a&&e.size>0&&o.searchParams.set("_routes",n.filter((t=>e.has(t.route.id))).map((e=>e.route.id)).join(",")),[o.pathname+o.search]}),[c,u,r,s,p,n,t,l]),b=o.useMemo((()=>qe(f,s)),[f,s]),y=lt(f);return o.createElement(o.Fragment,null,m.map((e=>o.createElement("link",d({key:e,rel:"prefetch",as:"fetch",href:e},a)))),b.map((e=>o.createElement("link",d({key:e,rel:"modulepreload",href:e},a)))),y.map((e=>{let{key:t,link:n}=e;return o.createElement("link",d({key:t},n))})))}at.displayName="FrameworkContext";var ut=!1;function ht(e){let{manifest:t,serverHandoffString:n,isSpaMode:a,renderMeta:r,routeDiscovery:s,ssr:l}=rt(),{router:c,static:u,staticContext:h}=tt(),{matches:f}=nt(),g=et(s,l);r&&(r.didRenderScripts=!0);let m=st(f,null,a);o.useEffect((()=>{0}),[]);let b=o.useMemo((()=>{var a;let r=h?"window.__reactRouterContext = ".concat(n,";").concat("window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());"):" ",s=u?"".concat(null!==t.hmr&&void 0!==a&&a.runtime?"import ".concat(JSON.stringify(t.hmr.runtime),";"):"").concat(g?"":"import ".concat(JSON.stringify(t.url)),";\n").concat(m.map(((e,n)=>{let a="route".concat(n),r=t.routes[e.route.id];Ve(r,"Route ".concat(e.route.id," not found in manifest"));let{clientActionModule:o,clientLoaderModule:s,clientMiddlewareModule:i,hydrateFallbackModule:l,module:c}=r,u=[...o?[{module:o,varName:"".concat(a,"_clientAction")}]:[],...s?[{module:s,varName:"".concat(a,"_clientLoader")}]:[],...i?[{module:i,varName:"".concat(a,"_clientMiddleware")}]:[],...l?[{module:l,varName:"".concat(a,"_HydrateFallback")}]:[],{module:c,varName:"".concat(a,"_main")}];return 1===u.length?"import * as ".concat(a," from ").concat(JSON.stringify(c),";"):[u.map((e=>"import * as ".concat(e.varName,' from "').concat(e.module,'";'))).join("\n"),"const ".concat(a," = {").concat(u.map((e=>"...".concat(e.varName))).join(","),"};")].join("\n")})).join("\n"),"\n  ").concat(g?"window.__reactRouterManifest = ".concat(JSON.stringify(function(e,t){let{sri:n}=e,a=i(e,p),r=new Set(t.state.matches.map((e=>e.route.id))),o=t.state.location.pathname.split("/").filter(Boolean),s=["/"];for(o.pop();o.length>0;)s.push("/".concat(o.join("/"))),o.pop();s.forEach((e=>{let n=R(t.routes,e,t.basename);n&&n.forEach((e=>r.add(e.route.id)))}));let l=[...r].reduce(((e,t)=>Object.assign(e,{[t]:a.routes[t]})),{});return d(d({},a),{},{routes:l,sri:!!n||void 0})}(t,c),null,2),";"):"","\n  window.__reactRouterRouteModules = {").concat(m.map(((e,t)=>"".concat(JSON.stringify(e.route.id),":route").concat(t))).join(","),"};\n\nimport(").concat(JSON.stringify(t.entry.module),");"):" ";return o.createElement(o.Fragment,null,o.createElement("script",d(d({},e),{},{suppressHydrationWarning:!0,dangerouslySetInnerHTML:Ye(r),type:void 0})),o.createElement("script",d(d({},e),{},{suppressHydrationWarning:!0,dangerouslySetInnerHTML:Ye(s),type:"module",async:!0})))}),[]),y=ut?[]:function(e){return[...new Set(e)]}(t.entry.imports.concat(qe(m,t,{includeHydrateFallback:!0}))),v="object"===typeof t.sri?t.sri:{};return ut?null:o.createElement(o.Fragment,null,"object"===typeof t.sri?o.createElement("script",{"rr-importmap":"",type:"importmap",suppressHydrationWarning:!0,dangerouslySetInnerHTML:{__html:JSON.stringify({integrity:v})}}):null,g?null:o.createElement("link",{rel:"modulepreload",href:t.url,crossOrigin:e.crossOrigin,integrity:v[t.url],suppressHydrationWarning:!0}),o.createElement("link",{rel:"modulepreload",href:t.entry.module,crossOrigin:e.crossOrigin,integrity:v[t.entry.module],suppressHydrationWarning:!0}),y.map((t=>o.createElement("link",{key:t,rel:"modulepreload",href:t,crossOrigin:e.crossOrigin,integrity:v[t],suppressHydrationWarning:!0}))),b)}function dt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return e=>{t.forEach((t=>{"function"===typeof t?t(e):null!=t&&(t.current=e)}))}}var pt="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement;try{pt&&(window.__reactRouterVersion="7.6.2")}catch(IW){}function ft(e){let{basename:t,children:n,window:a}=e,r=o.useRef();null==r.current&&(r.current=x({window:a,v5Compat:!0}));let s=r.current,[i,l]=o.useState({action:s.action,location:s.location}),c=o.useCallback((e=>{o.startTransition((()=>l(e)))}),[l]);return o.useLayoutEffect((()=>s.listen(c)),[s,c]),o.createElement(De,{basename:t,children:n,location:i.location,navigationType:i.action,navigator:s})}var gt=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,mt=o.forwardRef((function(e,t){let n,{onClick:a,discover:r="render",prefetch:s="none",relative:l,reloadDocument:c,replace:u,state:h,target:p,to:f,preventScrollReset:g,viewTransition:b}=e,y=i(e,m),{basename:v}=o.useContext(le),x="string"===typeof f&&gt.test(f),S=!1;if("string"===typeof f&&x&&(n=f,pt))try{let e=new URL(window.location.href),t=f.startsWith("//")?new URL(e.protocol+f):new URL(f),n=H(t.pathname,v);t.origin===e.origin&&null!=n?f=n+t.search+t.hash:S=!0}catch(IW){k(!1,'<Link to="'.concat(f,'"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.'))}let I=function(e){let{relative:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};w(de(),"useHref() may be used only in the context of a <Router> component.");let{basename:n,navigator:a}=o.useContext(le),{hash:r,pathname:s,search:i}=be(e,{relative:t}),l=s;return"/"!==n&&(l="/"===s?n:J([n,s])),a.createHref({pathname:l,search:i,hash:r})}(f,{relative:l}),[N,E,T]=function(e,t){let n=o.useContext(at),[a,r]=o.useState(!1),[s,i]=o.useState(!1),{onFocus:l,onBlur:c,onMouseEnter:u,onMouseLeave:h,onTouchStart:d}=t,p=o.useRef(null);o.useEffect((()=>{if("render"===e&&i(!0),"viewport"===e){let e=new IntersectionObserver((e=>{e.forEach((e=>{i(e.isIntersecting)}))}),{threshold:.5});return p.current&&e.observe(p.current),()=>{e.disconnect()}}}),[e]),o.useEffect((()=>{if(a){let e=setTimeout((()=>{i(!0)}),100);return()=>{clearTimeout(e)}}}),[a]);let f=()=>{r(!0)},g=()=>{r(!1),i(!1)};return n?"intent"!==e?[s,p,{}]:[s,p,{onFocus:ot(l,f),onBlur:ot(c,g),onMouseEnter:ot(u,f),onMouseLeave:ot(h,g),onTouchStart:ot(d,f)}]:[!1,p,{}]}(s,y),R=function(e){let{target:t,replace:n,state:a,preventScrollReset:r,relative:s,viewTransition:i}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},l=me(),c=pe(),u=be(e,{relative:s});return o.useCallback((o=>{if(function(e,t){return 0===e.button&&(!t||"_self"===t)&&!function(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}(e)}(o,t)){o.preventDefault();let t=void 0!==n?n:C(c)===C(u);l(e,{replace:t,state:a,preventScrollReset:r,relative:s,viewTransition:i})}}),[c,l,u,n,a,t,e,r,s,i])}(f,{replace:u,state:h,target:p,preventScrollReset:g,relative:l,viewTransition:b});let A=o.createElement("a",d(d(d({},y),T),{},{href:n||I,onClick:S||c?a:function(e){a&&a(e),e.defaultPrevented||R(e)},ref:dt(t,E),target:p,"data-discover":x||"render"!==r?void 0:"true"}));return N&&!x?o.createElement(o.Fragment,null,A,o.createElement(it,{page:I})):A}));mt.displayName="Link";var bt=o.forwardRef((function(e,t){let{"aria-current":n="page",caseSensitive:a=!1,className:r="",end:s=!1,style:l,to:c,viewTransition:u,children:h}=e,p=i(e,b),f=be(c,{relative:p.relative}),g=pe(),m=o.useContext(re),{navigator:y,basename:v}=o.useContext(le),x=null!=m&&function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=o.useContext(oe);w(null!=n,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:a}=xt("useViewTransitionState"),r=be(e,{relative:t.relative});if(!n.isTransitioning)return!1;let s=H(n.currentLocation.pathname,a)||n.currentLocation.pathname,i=H(n.nextLocation.pathname,a)||n.nextLocation.pathname;return null!=V(r.pathname,i)||null!=V(r.pathname,s)}(f)&&!0===u,k=y.encodeLocation?y.encodeLocation(f).pathname:f.pathname,S=g.pathname,I=m&&m.navigation&&m.navigation.location?m.navigation.location.pathname:null;a||(S=S.toLowerCase(),I=I?I.toLowerCase():null,k=k.toLowerCase()),I&&v&&(I=H(I,v)||I);const C="/"!==k&&k.endsWith("/")?k.length-1:k.length;let N,E=S===k||!s&&S.startsWith(k)&&"/"===S.charAt(C),T=null!=I&&(I===k||!s&&I.startsWith(k)&&"/"===I.charAt(k.length)),R={isActive:E,isPending:T,isTransitioning:x},A=E?n:void 0;N="function"===typeof r?r(R):[r,E?"active":null,T?"pending":null,x?"transitioning":null].filter(Boolean).join(" ");let F="function"===typeof l?l(R):l;return o.createElement(mt,d(d({},p),{},{"aria-current":A,className:N,ref:t,style:F,to:c,viewTransition:u}),"function"===typeof h?h(R):h)}));bt.displayName="NavLink";var yt=o.forwardRef(((e,t)=>{let{discover:n="render",fetcherKey:a,navigate:r,reloadDocument:s,replace:l,state:c,method:u=Le,action:h,onSubmit:p,relative:f,preventScrollReset:g,viewTransition:m}=e,b=i(e,y),v=St(),x=function(e){let{relative:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{basename:n}=o.useContext(le),a=o.useContext(ue);w(a,"useFormAction must be used inside a RouteContext");let[r]=a.matches.slice(-1),s=d({},be(e||".",{relative:t})),i=pe();if(null==e){s.search=i.search;let e=new URLSearchParams(s.search),t=e.getAll("index");if(t.some((e=>""===e))){e.delete("index"),t.filter((e=>e)).forEach((t=>e.append("index",t)));let n=e.toString();s.search=n?"?".concat(n):""}}e&&"."!==e||!r.route.index||(s.search=s.search?s.search.replace(/^\?/,"?index&"):"?index");"/"!==n&&(s.pathname="/"===s.pathname?n:J([n,s.pathname]));return C(s)}(h,{relative:f}),k="get"===u.toLowerCase()?"get":"post",S="string"===typeof h&&gt.test(h);return o.createElement("form",d(d({ref:t,method:k,action:x,onSubmit:s?p:e=>{if(p&&p(e),e.defaultPrevented)return;e.preventDefault();let t=e.nativeEvent.submitter,n=(null===t||void 0===t?void 0:t.getAttribute("formmethod"))||u;v(t||e.currentTarget,{fetcherKey:a,method:n,navigate:r,replace:l,state:c,relative:f,preventScrollReset:g,viewTransition:m})}},b),{},{"data-discover":S||"render"!==n?void 0:"true"}))}));function vt(e){return"".concat(e," must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.")}function xt(e){let t=o.useContext(ae);return w(t,vt(e)),t}yt.displayName="Form";var wt=0,kt=()=>"__".concat(String(++wt),"__");function St(){let{router:e}=xt("useSubmit"),{basename:t}=o.useContext(le),n=Ee("useRouteId");return o.useCallback((async function(a){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{action:o,method:s,encType:i,formData:l,body:c}=Ue(a,t);if(!1===r.navigate){let t=r.fetcherKey||kt();await e.fetch(t,n,r.action||o,{preventScrollReset:r.preventScrollReset,formData:l,body:c,formMethod:r.method||s,formEncType:r.encType||i,flushSync:r.flushSync})}else await e.navigate(r.action||o,{preventScrollReset:r.preventScrollReset,formData:l,body:c,formMethod:r.method||s,formEncType:r.encType||i,replace:r.replace,state:r.state,fromRouteId:n,flushSync:r.flushSync,viewTransition:r.viewTransition})}),[e,t,n])}class It{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Ct{refCount(e){return Nt("refCount")}incRef(e){return Nt("incRef")}timerAvailable(){return!0}time(e){return Nt("time")}read(e){return Nt("read")}readSync(e){return Nt("readSync")}readToGPU(e,t){return Nt("readToGPU")}numDataIds(){return Nt("numDataIds")}disposeData(e,t){return Nt("disposeData")}write(e,t,n){return Nt("write")}move(e,t,n,a,r){return Nt("move")}createTensorFromGPUData(e,t,n){return Nt("createTensorFromGPUData")}memory(){return Nt("memory")}floatPrecision(){return Nt("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Nt("dispose")}}function Nt(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function Et(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,At(e,t,n)}function Tt(e,t,n){return Math.max(e,Math.min(t,n))}function Rt(e){return e%2===0?e:e+1}function At(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function Ft(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function Dt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Ft(Lt(e,t),(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}function _t(e){Ft(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Ot(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Lt(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function zt(e){return e%1===0}function Mt(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Pt(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Bt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return new Promise(((r,o)=>{let s=0;const i=()=>{if(e())return void r();s++;const l=t(s);null!=n&&s>=n?o():null!=a?a(i,l):setTimeout(i,l)};i()}))}function Wt(e,t){let n=1,a=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(-1===e[o]){if(-1!==a)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(a," and dim ").concat(o));a=o}else if(e[o]<0)throw Error("Shapes can not be < 0. Found ".concat(e[o]," at dim ").concat(o));if(-1===a){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const r=e.slice();return r[a]=t/n,r}function Ut(e,t){const n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),Ft(e.every((e=>e>=-n&&e<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e))),Ft(e.every((e=>zt(e))),(()=>"All values in axis param must be integers but "+"got axis ".concat(e))),e.map((e=>e<0?n+e:e))}function Vt(e,t){const n=[],a=[],r=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||r?null:Ut(t,e).sort();let s=0;for(let i=0;i<e.length;++i){if(null!=o){if(o[s]===i&&1!==e[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(e[i],"' is not 1"));(null==o[s]||o[s]>i)&&1===e[i]&&(n.push(e[i]),a.push(i)),o[s]<=i&&s++}1!==e[i]&&(n.push(e[i]),a.push(i))}return{newShape:n,keptDims:a}}function Gt(e,t){return jt(e,t)}function jt(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function Ht(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function Kt(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function qt(e){return"string"===typeof e||e instanceof String}function Xt(e){return"number"===typeof e}function Yt(e){return Array.isArray(e)?Yt(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Xt(e)?"float32":qt(e)?"string":"boolean"===typeof e?"bool":"float32"}function Jt(e){return!!(e&&e.constructor&&e.call&&e.apply)}function $t(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Qt(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function Zt(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=new Array;if(1===t.length){const o=t[0]*(a?2:1);for(let t=0;t<o;t++)r[t]=n[e+t]}else{const o=t[0],s=t.slice(1),i=s.reduce(((e,t)=>e*t))*(a?2:1);for(let t=0;t<o;t++)r[t]=Zt(e+t*i,s,n,a)}return r}function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const a=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return Zt(0,e,t,n)}function tn(e,t){const n=nn(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function nn(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function an(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return en(e,new Float32Array(n));if("int32"===t)return en(e,new Int32Array(n));if("bool"===t)return en(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function rn(e){e.forEach((t=>{Ft(Number.isInteger(t)&&t>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"].")))}))}function on(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function sn(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function ln(e){return e&&e.then&&"function"===typeof e.then}const cn="tfjsflags";class un{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=hn,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(dn().getBool("IS_TEST")||dn().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];dn().getBool("IS_TEST")||dn().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(ln(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(cn in e){e[cn].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:t}(0,n)}))}}}function hn(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,a[0],a[1]),a.join("=")})),t}function dn(){return fn}let pn,fn=null;function gn(){if(null==pn){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}pn=e}return pn}function mn(e,t){const n=function(){const e=gn();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}const bn="Abs",yn="Acos",vn="Acosh",xn="Add",wn="AddN",kn="All",Sn="Any",In="ArgMax",Cn="ArgMin",Nn="Asin",En="Asinh",Tn="Atan",Rn="Atanh",An="Atan2",Fn="AvgPool",Dn="AvgPoolGrad",_n="AvgPool3D",On="AvgPool3DGrad",Ln="BatchMatMul",zn="BatchToSpaceND",Mn="Bincount",Pn="BitwiseAnd",Bn="BroadcastArgs",Wn="Cast",Un="Ceil",Vn="ClipByValue",Gn="Complex",jn="ComplexAbs",Hn="Concat",Kn="Conv2D",qn="Conv2DBackpropFilter",Xn="Conv2DBackpropInput",Yn="Conv3D",Jn="Conv3DBackpropFilterV2",$n="Conv3DBackpropInputV2",Qn="Cos",Zn="Cosh",ea="Cumprod",ta="Cumsum",na="CropAndResize",aa="DenseBincount",ra="DepthToSpace",oa="DepthwiseConv2dNative",sa="DepthwiseConv2dNativeBackpropFilter",ia="DepthwiseConv2dNativeBackpropInput",la="Diag",ca="Dilation2D",ua="Dilation2DBackpropInput",ha="Dilation2DBackpropFilter",da="Draw",pa="RealDiv",fa="Einsum",ga="Elu",ma="EluGrad",ba="Erf",ya="Equal",va="Exp",xa="ExpandDims",wa="Expm1",ka="FFT",Sa="Fill",Ia="FlipLeftRight",Ca="Floor",Na="FloorDiv",Ea="FusedBatchNorm",Ta="GatherV2",Ra="GatherNd",Aa="Greater",Fa="GreaterEqual",Da="Identity",_a="IFFT",Oa="Imag",La="IsFinite",za="IsInf",Ma="IsNan",Pa="LeakyRelu",Ba="Less",Wa="LessEqual",Ua="LinSpace",Va="Log",Ga="Log1p",ja="LogicalAnd",Ha="LogicalNot",Ka="LogicalOr",qa="LRN",Xa="LRNGrad",Ya="Max",Ja="Maximum",$a="MaxPool",Qa="MaxPoolGrad",Za="MaxPool3D",er="MaxPool3DGrad",tr="MaxPoolWithArgmax",nr="Mean",ar="Min",rr="Minimum",or="MirrorPad",sr="Mod",ir="Multinomial",lr="Multiply",cr="Neg",ur="NotEqual",hr="NonMaxSuppressionV3",dr="NonMaxSuppressionV4",pr="NonMaxSuppressionV5",fr="OnesLike",gr="OneHot",mr="Pack",br="PadV2",yr="Pow",vr="Prelu",xr="Prod",wr="RaggedGather",kr="RaggedRange",Sr="RaggedTensorToTensor",Ir="Range",Cr="Real",Nr="Reciprocal",Er="Relu",Tr="Reshape",Rr="ResizeNearestNeighbor",Ar="ResizeNearestNeighborGrad",Fr="ResizeBilinear",Dr="ResizeBilinearGrad",_r="Relu6",Or="Reverse",Lr="Round",zr="Rsqrt",Mr="ScatterNd",Pr="TensorScatterUpdate",Br="SearchSorted",Wr="Select",Ur="Selu",Vr="Slice",Gr="Sin",jr="Sinh",Hr="Sign",Kr="Sigmoid",qr="Softplus",Xr="Sqrt",Yr="Sum",Jr="SpaceToBatchND",$r="SplitV",Qr="Softmax",Zr="SparseFillEmptyRows",eo="SparseReshape",to="SparseSegmentMean",no="SparseSegmentSum",ao="SparseToDense",ro="SquaredDifference",oo="Square",so="StaticRegexReplace",io="StridedSlice",lo="StringNGrams",co="StringSplit",uo="StringToHashBucketFast",ho="Sub",po="Tan",fo="Tanh",go="Tile",mo="TopK",bo="Transform",yo="Transpose",vo="Unique",xo="Unpack",wo="UnsortedSegmentSum",ko="ZerosLike",So="Step",Io="FromPixels",Co="RotateWithOffset",No="_FusedMatMul",Eo="FusedConv2D",To="FusedDepthwiseConv2D";function Ro(){dn().getBool("IS_TEST")||dn().getBool("PROD")||console.warn(...arguments)}function Ao(){dn().getBool("IS_TEST")||dn().getBool("PROD")||console.log(...arguments)}const Fo=mn("kernelRegistry",(()=>new Map)),Do=mn("gradRegistry",(()=>new Map));function _o(e,t){const n=Po(e,t);return Fo.get(n)}function Oo(e){return Do.get(e)}function Lo(e){const t=Fo.entries(),n=[];for(;;){const{done:a,value:r}=t.next();if(a)break;const[o,s]=r,[i]=o.split("_");i===e&&n.push(s)}return n}function zo(e){const{kernelName:t,backendName:n}=e,a=Po(t,n);Fo.has(a)&&Ro("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),Fo.set(a,e)}function Mo(e){const{kernelName:t}=e;Do.has(t)&&dn().getBool("DEBUG")&&Ro("Overriding the gradient for '".concat(t,"'")),Do.set(t,e)}function Po(e,t){return"".concat(t,"_").concat(e)}function Bo(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Wo=n(353);const Uo=n.n(Wo)()||Wo;function Vo(e){return Uo.fromString(e,!0,16)}const Go=Vo("c3a5c85c97cb3127"),jo=Vo("b492b66fbe98f273"),Ho=Vo("9ae16a3b2f90404f");function Ko(e){return e.xor(e.shru(47))}function qo(e,t,n){const a=e.slice(t,t+n);return Uo.fromBytes(Array.from(a),!0,!0)}function Xo(e,t){return qo(e,t,8)}function Yo(e,t){return qo(e,t,4)}function Jo(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function $o(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Vo("9ddfea08eb382d69"),a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function Qo(e,t,n,a){return function(e,t,n,a,r,o){r=r.add(e),o=Jo(o.add(r).add(a),21);const s=r;return r=(r=r.add(t)).add(n),o=o.add(Jo(r,44)),[r.add(a),o.add(s)]}(Xo(e,t),Xo(e,t+8),Xo(e,t+16),Xo(e,t+24),n,a)}function Zo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Uo.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=Ho.add(2*t),a=Xo(e,0).add(Ho),r=Xo(e,t-8);return $o(Jo(r,37).mul(n).add(a),Jo(a,25).add(r).mul(n),n)}if(t>=4){const n=Ho.add(2*t);return $o(Yo(e,0).shl(3).add(t),Yo(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return Ko(Ho.mul(n).xor(Go.mul(a))).mul(Ho)}return Ho}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Ho.add(2*t),a=Xo(e,0).mul(jo),r=Xo(e,8),o=Xo(e,t-8).mul(n),s=Xo(e,t-16).mul(Ho);return $o(Jo(a.add(r),43).add(Jo(o,30)).add(s),a.add(Jo(r.add(Ho),18)).add(o),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Ho.add(2*t),a=Xo(e,0).mul(Ho),r=Xo(e,8),o=Xo(e,t-8).mul(n),s=Xo(e,t-16).mul(Ho),i=Jo(a.add(r),43).add(Jo(o,30)).add(s),l=$o(i,a.add(Jo(r.add(Ho),18)).add(o),n),c=Xo(e,16).mul(n),u=Xo(e,24),h=i.add(Xo(e,t-32)).mul(n),d=l.add(Xo(e,t-24)).mul(n);return $o(Jo(c.add(u),43).add(Jo(h,30)).add(d),c.add(Jo(u.add(a),18)).add(h),n)}(e,t);let a=n,r=n.mul(jo).add(113),o=Ko(r.mul(Ho).add(113)).mul(Ho),s=[Uo.UZERO,Uo.UZERO],i=[Uo.UZERO,Uo.UZERO];a=a.mul(Ho).add(Xo(e,0));let l=0;const c=64*(t-1>>6),u=c+(t-1&63)-63;do{a=Jo(a.add(r).add(s[0]).add(Xo(e,l+8)),37).mul(jo),r=Jo(r.add(s[1]).add(Xo(e,l+48)),42).mul(jo),a=a.xor(i[1]),r=r.add(s[0]).add(Xo(e,l+40)),o=Jo(o.add(i[0]),33).mul(jo),s=Qo(e,l,s[1].mul(jo),a.add(i[0])),i=Qo(e,l+32,o.add(i[1]),r.add(Xo(e,l+16))),[o,a]=[a,o],l+=64}while(l!==c);const h=jo.add(o.and(255).shl(1));return l=u,i[0]=i[0].add(t-1&63),s[0]=s[0].add(i[0]),i[0]=i[0].add(s[0]),a=Jo(a.add(r).add(s[0]).add(Xo(e,l+8)),37).mul(h),r=Jo(r.add(s[1]).add(Xo(e,l+48)),42).mul(h),a=a.xor(i[1].mul(9)),r=r.add(s[0].mul(9).add(Xo(e,l+40))),o=Jo(o.add(i[0]),33).mul(h),s=Qo(e,l,s[1].mul(h),a.add(i[0])),i=Qo(e,l+32,o.add(i[1]),r.add(Xo(e,l+16))),[o,a]=[a,o],$o($o(s[0],i[0],h).add(Ko(r).mul(Go)).add(o),$o(s[1],i[1],h).add(a),h)}function es(e,t){return"string"===t?as(e):ts([e],t)}function ts(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ss(e)),dn().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(a,"."))}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function ns(){return dn().platform.now()}function as(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",dn().platform.encode(e,t)}function rs(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",dn().platform.decode(e,t)}function os(e){return null!=dn().platform.isTypedArray?dn().platform.isTypedArray(e):Bo(e)}function ss(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||ln(e)||null==e||os(e)&&n)t.push(e);else if(Array.isArray(e)||os(e))for(let a=0;a<e.length;++a)ss(e[a],t,n);else{let a=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(a=Math.max(a,Number(t)));for(let r=0;r<=a;r++)ss(e[r],t,n)}return t}class is{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new cs)}profileKernel(e,t,n){let a;const r=()=>{a=n()};let o;const s=ns();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(r);else{r();for(const e of a)e.dataSync();o=Promise.resolve({kernelMs:ns()-s})}if(dn().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<a.length;i++){const t=a[i];t.data().then((n=>{ls(n,t.dtype,e)}))}return{kernelName:e,outputs:a,inputs:t,timeMs:o.then((e=>e.kernelMs)),extraInfo:o.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:o}=e;n.forEach((e=>{Promise.all([e.data(),a,o]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])}))}))}}function ls(e,t,n){if("float32"!==t)return!1;for(let a=0;a<e.length;a++){const t=e[a];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class cs{logKernelProfile(e,t,n,a,r,o){const s="number"===typeof a?Pt("".concat(a,"ms"),9):a.error,i=Pt(e,25),l=t.rank,c=t.size,u=Pt(t.shape.toString(),14);let h="";for(const d in r){const e=r[d];if(null!=e){const n=e.shape||t.shape,a=n.length;h+="".concat(d,": ").concat(a,"D ").concat(a>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(s,"\t%c").concat(l,"D ").concat(u,"\t%c").concat(c,"\t%c").concat(h,"\t%c").concat(o),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function us(e,t,n,a){const r=Qt(t),o=function(e,t,n,a){const r=Ot(t),o=a[a.length-1],s=new Array(o).fill(0),i=t.length,l="complex64"===n?fs(e):e;if(i>1)for(let c=0;c<r/o;c++){const e=c*o;for(let t=0;t<o;t++)s[t]=Math.max(s[t],hs(l[e+t],0,n).length)}return s}(e,t,n,r),s=t.length,i=ps(e,t,n,r,o),l=["Tensor"];return a&&(l.push("  dtype: ".concat(n)),l.push("  rank: ".concat(s)),l.push("  shape: [".concat(t,"]")),l.push("  values:")),l.push(i.map((e=>"    "+e)).join("\n")),l.join("\n")}function hs(e,t,n){let a;return a=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(7))," + ")+"".concat(parseFloat(e[1].toFixed(7)),"j"):qt(e)?"'".concat(e,"'"):"bool"===n?ds(e):parseFloat(e.toFixed(7)).toString(),Pt(a,t)}function ds(e){return 0===e?"false":"true"}function ps(e,t,n,a,r){let o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const s="complex64"===n?2:1,i=t[0],l=t.length;if(0===l){if("complex64"===n){return[hs(fs(e)[0],0,n)]}return"bool"===n?[ds(e[0])]:[e[0].toString()]}if(1===l){if(i>20){const t=3*s;let a=Array.from(e.slice(0,t)),o=Array.from(e.slice((i-3)*s,i*s));return"complex64"===n&&(a=fs(a),o=fs(o)),["["+a.map(((e,t)=>hs(e,r[t],n))).join(", ")+", ..., "+o.map(((e,t)=>hs(e,r[i-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?fs(e):Array.from(e)).map(((e,t)=>hs(e,r[t],n))).join(", ")+"]"]}const c=t.slice(1),u=a.slice(1),h=a[0]*s,d=[];if(i>20){for(let t=0;t<3;t++){const a=t*h,o=a+h;d.push(...ps(e.slice(a,o),c,n,u,r,!1))}d.push("...");for(let t=i-3;t<i;t++){const a=t*h,o=a+h;d.push(...ps(e.slice(a,o),c,n,u,r,t===i-1))}}else for(let g=0;g<i;g++){const t=g*h,a=t+h;d.push(...ps(e.slice(t,a),c,n,u,r,g===i-1))}const p=2===l?",":"";d[0]="["+(i>0?d[0]+p:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=",\n";for(let g=2;g<l;g++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":f),d}function fs(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class gs{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Ot(e),null!=n){const e=n.length;Ft(e===this.size,(()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||jt(t,this.size),this.strides=Qt(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];0===n.length&&(n=[0]),Ft(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const r=this.locToIndex(n);this.values[r]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let a=0;for(const o of t){if(o<0||o>=this.shape[a]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}a++}let r=t[t.length-1];for(let o=0;o<t.length-1;++o)r+=this.strides[o]*t[o];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ms().makeTensor(this.values,this.shape,this.dtype)}}let ms=null,bs=null,ys=null;class vs{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ot(e),this.strides=Qt(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return bs.buffer(this.shape,this.dtype,e)}bufferSync(){return bs.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return en(this.shape,e,"complex64"===this.dtype)}arraySync(){return en(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=ms().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>rs(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ms().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=ms().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>rs(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await ms().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ms().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return bs.print(this,e)}clone(){return this.throwIfDisposed(),bs.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return us(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),bs.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),ms().makeVariable(this,e,t,n)}}function xs(){return mn("Tensor",(()=>vs))}Object.defineProperty(vs,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),xs();class ws extends vs{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!Lt(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));ms().disposeTensor(this),this.dataId=e.dataId,ms().incRef(this,null)}dispose(){ms().disposeVariable(this),this.isDisposedInternal=!0}}var ks,Ss,Is,Cs,Ns;Object.defineProperty(ws,Symbol.hasInstance,{value:e=>e instanceof vs&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(ks||(ks={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Ss||(Ss={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Is||(Is={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Cs||(Cs={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Ns||(Ns={}));const Es={float32:Cs,int32:Ss,bool:Is,complex64:Ns};function Ts(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return Es[e][t]}function Rs(e){return Ts(e,"int32")}function As(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function Fs(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Ds(e,t){if(e.dtype===t.dtype)return[e,t];const n=Ts(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function _s(e,t){return t.some((t=>t.id===e.id))}function Os(e){const t=[];return Ls(e,t,new Set),t}function Ls(e,t,n){if(null==e)return;if(e instanceof vs)return void t.push(e);if(a=e,!Array.isArray(a)&&"object"!==typeof a)return;var a;const r=e;for(const o in r){const e=r[o];n.has(e)||(n.add(e),Ls(e,t,n))}}function zs(e){return null!=e.kernelName}class Ms{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Ps{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ms}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(Ro("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new is(this.backendInstance),!0}setupRegisteredKernels(){Lo(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Lo(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof Ct||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,Ro("Initialization of backend ".concat(e," failed")),Ro(n.stack||n.message)),!1)));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(n){return Ro("Initialization of backend ".concat(e," failed")),Ro(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:r}=this.initializeBackend(n);if(r||a)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,r=this.readSync(t),o=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun((()=>this.startScope(a)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(a){throw t(),a}}nextTensorId(){return Ps.nextTensorId++}nextVariableId(){return Ps.nextVariableId++}clone(e){const t=Ws.runKernel(Da,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Ws.runKernel(Wn,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=_o(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let r=0;n.forEach((e=>{r+="complex64"===e.dtype?3:1}));const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],s=a-t-r-o;if(s>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(s," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),r=this.state.numBytes,o=this.state.numTensors;let s,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=zs(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(zs(e)){const{kernelName:t,inputs:r,attrs:o}=e;null==this.backendName&&this.backend;const l=_o(t,this.backendName);Ft(null!=l,(()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'"))),s=()=>{const e=this.backend.numDataIds();i=l.kernelFunc({inputs:r,attrs:o,backend:this.backend});const s=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,s);const c=s.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){const e=this.getTensorsForGradient(t,r,c);n=this.saveTensorsForBackwardMode(e)}return c}}else{const{forwardFunc:t}=e,r=e=>{a&&(n=e.map((e=>this.keep(this.clone(e)))))};s=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,r)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:c,attrs:u}=e,h=zs(e)?null:e.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,c,(()=>s())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=s()})),a&&this.addTapeNode(l,c,t,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map((e=>null!=c[e]?c[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const a=Oo(e);if(null!=a){const e=a.inputsToSave||[],r=a.outputsToSave||[];let o;a.saveAllInputs?(Ft(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),o=Object.keys(t).map((e=>t[e]))):o=e.map((e=>t[e]));const s=n.filter(((e,t)=>r[t]));return o.concat(s)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let r=e;"string"===n&&qt(e[0])&&(r=e.map((e=>as(e))));const o=a.write(r,t,n),s=new vs(t,n,o,this.nextTensorId());if(this.trackTensor(s,a),"string"===n){const e=this.state.tensorInfo.get(o),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return s}makeTensorFromDataId(e,t,n,a){const r={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(r,a)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:a,dtype:r}=e,o=new vs(a,r,n,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const r=new ws(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error("Variable with name ".concat(r.name," was already registered"));return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Kt(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof ws||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Kt(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,r,o){const s={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},i=Oo(e);null!=i&&(a=i.gradFunc),null!=a&&(s.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],a=nn(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e})),a(e.length>1?e:e[0],r,o))),this.state.activeTape.push(s)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Os(e),n=new Set(t.map((e=>e.id)));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||n.has(e.id)||e.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==a.id||this.track(e)}))}gradients(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Ft(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const r=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Ft(r instanceof vs,(()=>"The result y returned by f() must be a tensor."));const o=function(e,t,n){const a={},r={};for(let l=0;l<t.length;l++)a[t[l].id]=!0;for(let l=0;l<e.length;l++){const n=e[l],o=n.inputs;for(const e in o){const s=o[e];let i=!1;for(let e=0;e<t.length;e++)if(a[s.id]){n.outputs.forEach((e=>a[e.id]=!0)),i=!0,r[n.id]=!0;break}if(i)break}}const o={};o[n.id]=!0;const s={};for(let l=e.length-1;l>=0;l--){const t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(o[t.outputs[e].id]){for(const e in n)o[n[e].id]=!0,s[t.id]=!0;break}}const i=[];for(let l=0;l<e.length;l++){const t=e[l];if(r[t.id]&&s[t.id]){const e={};for(const r in t.inputs){const n=t.inputs[r];a[n.id]&&(e[r]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,i.push(n)}}return i}(this.state.activeTape,t,r);if(!a&&0===o.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[r.id]=null==n?function(e){const t=tn(Ot(e),"float32");return Ws.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,a){for(let r=t.length-1;r>=0;r--){const o=t[r],s=[];if(o.outputs.forEach((t=>{const n=e[t.id];null!=n?s.push(n):s.push(null)})),null==o.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(o.kernelName,"."));const i=o.gradient(s);for(const t in o.inputs){if(!(t in i))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const r=n((()=>i[t]()));if("float32"!==r.dtype)throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(r.dtype,"'"));const s=o.inputs[t];if(!Lt(r.shape,s.shape))throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(r.shape,"', which does not match ")+"the shape of the input '".concat(s.shape,"'"));if(null==e[s.id])e[s.id]=r;else{const t=e[s.id];e[s.id]=a(t,r),t.dispose()}}}}(e,o,(e=>this.tidy(e)),Us);const a=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:r,grads:a}}))}customGrad(e){var t=this;return Ft(Jt(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,a=new Array(n),r=0;r<n;r++)a[r]=arguments[r];let o;Ft(a.every((e=>e instanceof vs)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const s={};a.forEach(((e,t)=>{s[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(o=e(...a,n),Ft(o.value instanceof vs,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Ft(Jt(o.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),o.value),backwardsFunc:(e,t)=>{const n=o.gradFunc(e,t),r=Array.isArray(n)?n:[n];Ft(r.length===a.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Ft(r.every((e=>e instanceof vs)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const s={};return r.forEach(((e,t)=>{s[t]=()=>e})),s},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=ns(),n=await this.backend.time(e);return n.wallMs=ns()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ms;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Bs(){const e=gn();if(null==e._tfengine){const t=new un(e);e._tfengine=new Ps(t)}var t;return t=e._tfengine.ENV,fn=t,ms=()=>e._tfengine,e._tfengine}Ps.nextTensorId=0,Ps.nextVariableId=0;const Ws=Bs();function Us(e,t){const n={a:e,b:t};return Ws.runKernel(xn,n)}let Vs;function Gs(e){if(void 0!==Vs)return Vs;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function js(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const Hs=dn();function Ks(e,t){let n=e;if(os(e))return"string"===t?[]:[e.length];if(As(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(Fs(e))return[e.buffer.size/(null==t?4:Kt(t))];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||os(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&dn().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&qs(e,a,[]),a}function qs(e,t,n){if(n=n||[],!Array.isArray(e)&&!os(e))return void Ft(0===t.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(t[0]," elements")));Ft(t.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(e.length," elements"))),Ft(e.length===t[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(t[0]," ")+"elements, but has ".concat(e.length," elements")));const a=t.slice(1);for(let r=0;r<e.length;++r)qs(e[r],a,n.concat(r))}function Xs(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(a,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function Ys(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof xs())return Xs(a,e.dtype,t,n),e;let r=Yt(e);if("string"!==r&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),Xs(a,r,t,n),null==e||!os(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const a=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(a,"'"))}const o=Ks(e,r);os(e)||Array.isArray(e)||(e=[e]);const s="string"!==r?ts(e,r):ss(e,[],!0);return Ws.makeTensor(s,o,r)}function Js(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return e.map(((e,r)=>Ys(e,"".concat(t,"[").concat(r,"]"),n,a)))}Hs.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Hs.registerFlag("IS_BROWSER",(()=>js())),Hs.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Hs.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Hs.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Hs.registerFlag("PROD",(()=>!1)),Hs.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Hs.getBool("DEBUG"))),Hs.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Hs.registerFlag("IS_TEST",(()=>!1)),Hs.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Hs.getBool("DEBUG"))),Hs.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Hs.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Hs.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function $s(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=function(){Ws.startScope(n);try{const e=a(...arguments);return ln(e)&&console.error("Cannot return a Promise inside of tidy."),Ws.endScope(e),e}catch(e){throw Ws.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}const Qs=$s({complex_:function(e,t){const n=Ys(e,"real","complex"),a=Ys(t,"imag","complex");Dt(n.shape,a.shape,"real and imag shapes, ".concat(n.shape," and ").concat(a.shape,", ")+"must match in call to tf.complex().");const r={real:n,imag:a};return Ws.runKernel(Gn,r)}});function Zs(e,t,n,a){if(null==a)a=Yt(e);else if("complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Fs(e)||As(e)){if("float32"!==a&&"int32"!==a)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(a,"."));return Ws.backend.createTensorFromGPUData(e,t||n,a)}if(!os(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){rn(t);const e=Ot(t),a=Ot(n);Ft(e===a,(()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(a)));for(let r=0;r<n.length;++r){const e=n[r],a=r!==n.length-1||e!==Ot(t.slice(r));Ft(n[r]===t[r]||!a,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). ")))}}return os(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?ts(e,a):ss(e,[],!0),Ws.makeTensor(e,t,a)}function ei(e,t,n){return Zs(e,t,Ks(e,n),n)}const ti={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class ni{static join(e){return new ni(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>os(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const a=e[n];n!==e.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=t+a.byteLength;this.shards.push({buffer:a,start:t,end:r}),t=r}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error("Could not find start shard for byte ".concat(e));const a=new ArrayBuffer(t-e),r=new Uint8Array(a);let o=0;for(let s=n;s<this.shards.length;s++){const n=this.shards[s],a=e+o-n.start,i=o,l=Math.min(t,n.end)-n.start,c=new Uint8Array(n.buffer,a,l-a);if(r.set(c,i),o+=c.length,t<n.end)break}return a}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,a=e.length;for(;n<=a;){const r=Math.floor((a-n)/2)+n,o=t(e[r]);if(0===o)return r;o<0?a=r:n=r+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function ai(){return Ws}function ri(){return Ws.memory()}function oi(e,t){return Ws.tidy(e,t)}function si(e){Os(e).forEach((e=>e.dispose()))}function ii(e){return Ws.keep(e)}function li(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Ws.registerBackend(e,t,n)}function ci(){return Ws.backend}ys=function(e){dn().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};async function ui(e,t){const n=[],a=[],r=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let o=0;o<r.length;++o){const s=r[o],i=Array.isArray(e)?e[o].tensor:e[s];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(s,"': ").concat(i.dtype));const l={name:s,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const e=new Promise((async e=>{const t=await i.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+4*t.length,a=new Uint8Array(n);let r=0;for(let o=0;o<t.length;o++){const e=t[o],n=new Uint8Array(new Uint32Array([e.length]).buffer);a.set(n,r),r+=4,a.set(e,r),r+=e.length}e(a)}));a.push(e)}else a.push(i.data());null!=t&&(l.group=t),n.push(l)}return{data:fi(await Promise.all(a)),specs:n}}function hi(e,t){const n=new ni(e),a={};let r=0;for(const o of t){const e=di(o,((e,t)=>n.slice(r+e,r+t)));a[o.name]=pi(o,n.slice(r,r+e)),r+=e}return a}function di(e,t){const n=Ot(e.shape);let a;if("quantization"in e){const t=e.quantization;a=ti[t.dtype]}else{if("string"===e.dtype){let e=0;for(let a=0;a<n;a++)e+=4+new Uint32Array(t(e,e+4))[0];return e}a=ti[e.dtype]}return n*a}function pi(e,t){const n=e.name,a=e.dtype,r=e.shape,o=Ot(r);let s,i=0;if("quantization"in e){const r=e.quantization;if("uint8"===r.dtype||"uint16"===r.dtype){if(!("min"in r)||!("scale"in r))throw new Error("Weight ".concat(e.name," with quantization ").concat(r.dtype," ")+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==r.dtype)throw new Error("Weight ".concat(e.name," has unknown ")+"quantization dtype ".concat(r.dtype,". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==a)throw new Error("Weight ".concat(e.name," is quantized with ").concat(r.dtype," ")+"which only supports weights of type float32 not ".concat(a,"."))}const l=ti[r.dtype],c="uint8"===r.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===a)if("uint8"===r.dtype||"uint16"===r.dtype){s=new Float32Array(c.length);for(let e=0;e<c.length;e++){const t=c[e];s[e]=t*r.scale+r.min}}else{if("float16"!==r.dtype)throw new Error("Unsupported quantization type ".concat(r.dtype," ")+"for weight type float32.");{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return a=>{const r=new ArrayBuffer(4*a.length),o=new Uint32Array(r);for(let s=0;s<a.length;s++){const r=a[s],i=e[n[r>>10]+(1023&r)]+t[r>>10];o[s]=i}return new Float32Array(r)}}();s=e(c)}}else{if("int32"!==a)throw new Error("Unsupported dtype in weight '".concat(n,"': ").concat(a));if("uint8"!==r.dtype&&"uint16"!==r.dtype)throw new Error("Unsupported quantization type ".concat(r.dtype," ")+"for weight type int32.");s=new Int32Array(c.length);for(let e=0;e<c.length;e++){const t=c[e];s[e]=Math.round(t*r.scale+r.min)}}i+=o*l}else if("string"===a){const n=Ot(e.shape);s=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(i,i+4))[0];i+=4;const n=new Uint8Array(t.slice(i,i+e));s.push(n),i+=e}}else{const e=ti[a];if("float32"===a)s=new Float32Array(t);else if("int32"===a)s=new Int32Array(t);else{if("bool"!==a){if("complex64"===a){s=new Float32Array(t);const e=new Float32Array(s.length/2),n=new Float32Array(s.length/2);for(let t=0;t<e.length;t++)e[t]=s[2*t],n[t]=s[2*t+1];const a=ei(e,r,"float32"),o=ei(n,r,"float32"),i=Qs(a,o);return a.dispose(),o.dispose(),i}throw new Error("Unsupported dtype in weight '".concat(n,"': ").concat(a))}s=new Uint8Array(t)}i+=o*e}return ei(s,r,a)}function fi(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))}));const a=new Uint8Array(t);let r=0;return n.forEach((e=>{a.set(new Uint8Array(e.buffer),r),r+=e.byteLength})),a.buffer}const gi="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function mi(e){return gi?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function bi(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function yi(e,t){let n,a;return null!=e.weightsManifest&&([n,a]=await t(e.weightsManifest)),function(e,t,n){const a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(a.initializerSignature=e.initializerSignature),a}(e,n,a)}function vi(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:mi(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:mi(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new ni(e.weightData).byteLength}}function xi(e){const t=[];for(const n of e)t.push(...n.weights);return t}class wi{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==wi.instance&&(wi.instance=new wi),wi.instance}static registerSaveRouter(e){wi.getInstance().saveRouters.push(e)}static registerLoadRouter(e){wi.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return wi.getHandlers(e,"save")}static getLoadHandlers(e,t){return wi.getHandlers(e,"load",t)}static getHandlers(e,t,n){const a=[];return("load"===t?wi.getInstance().loadRouters:wi.getInstance().saveRouters).forEach((t=>{const r=t(e,n);null!==r&&a.push(r)})),a}}const ki="tensorflowjs",Si="models_store",Ii="model_info_store";function Ci(){if(!dn().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Ni(e){const t=e.result;t.createObjectStore(Si,{keyPath:"modelPath"}),t.createObjectStore(Ii,{keyPath:"modelPath"})}class Ei{constructor(e){if(this.indexedDB=Ci(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const a=this.indexedDB.open(ki,1);a.onupgradeneeded=()=>Ni(a),a.onsuccess=()=>{const r=a.result;if(null==t){const t=r.transaction(Si,"readonly"),a=t.objectStore(Si).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(a.result.modelArtifacts)},a.onerror=e=>(r.close(),n(a.error)),t.oncomplete=()=>r.close()}else{t.weightData=ni.join(t.weightData);const a=vi(t),s=r.transaction(Ii,"readwrite");let i,l,c=s.objectStore(Ii);try{i=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(o){return n(o)}i.onsuccess=()=>{l=r.transaction(Si,"readwrite");const i=l.objectStore(Si);let u;try{u=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(o){return n(o)}u.onsuccess=()=>e({modelArtifactsInfo:a}),u.onerror=e=>{c=s.objectStore(Ii);const t=c.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(u.error)),t.onerror=e=>(r.close(),n(u.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}}},a.onerror=e=>n(a.error)}))}}Ei.URL_SCHEME="indexeddb://";const Ti=e=>{return dn().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ei.URL_SCHEME)?(t=e.slice(Ei.URL_SCHEME.length),new Ei(t)):null;var t};wi.registerSaveRouter(Ti),wi.registerLoadRouter(Ti);class Ri{constructor(){this.indexedDB=Ci()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(ki,1);n.onupgradeneeded=()=>Ni(n),n.onsuccess=()=>{const a=n.result,r=a.transaction(Ii,"readonly"),o=r.objectStore(Ii).getAll();o.onsuccess=()=>{const t={};for(const e of o.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},o.onerror=e=>(a.close(),t(o.error)),r.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(Ei.URL_SCHEME)?t.slice(Ei.URL_SCHEME.length):t,new Promise(((t,n)=>{const a=this.indexedDB.open(ki,1);a.onupgradeneeded=()=>Ni(a),a.onsuccess=()=>{const r=a.result,o=r.transaction(Ii,"readwrite"),s=o.objectStore(Ii),i=s.get(e);let l;i.onsuccess=()=>{if(null==i.result)return r.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const a=s.delete(e),o=()=>{l=r.transaction(Si,"readwrite");const a=l.objectStore(Si).delete(e);a.onsuccess=()=>t(i.result.modelArtifactsInfo),a.onerror=e=>n(i.error)};a.onsuccess=o,a.onerror=e=>(o(),r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),o.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}},a.onerror=e=>n(a.error)}))}}const Ai="/",Fi="tensorflowjs_models",Di="info",_i="model_topology",Oi="weight_specs",Li="weight_data",zi="model_metadata";function Mi(e){return{info:[Fi,e,Di].join(Ai),topology:[Fi,e,_i].join(Ai),weightSpecs:[Fi,e,Oi].join(Ai),weightData:[Fi,e,Li].join(Ai),modelMetadata:[Fi,e,zi].join(Ai)}}function Pi(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Bi(e){const t=e.split(Ai);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(Ai)}class Wi{constructor(e){if(!dn().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Mi(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),a=JSON.stringify(e.weightSpecs),r=vi(e),o=ni.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,a),this.LS.setItem(this.keys.weightData,function(e){if(gi)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}(o));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:r}}catch(t){throw Pi(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(r.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(r.weightSpecsBytes,", ")+"weightDataBytes=".concat(r.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=a;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(null==o)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if(gi){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}(o),t}}Wi.URL_SCHEME="localstorage://";const Ui=e=>{return dn().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Wi.URL_SCHEME)?(t=e.slice(Wi.URL_SCHEME.length),new Wi(t)):null;var t};wi.registerSaveRouter(Ui),wi.registerLoadRouter(Ui);class Vi{constructor(){Ft(dn().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Ft("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Fi+Ai,n=Ai+Di;for(let a=0;a<this.LS.length;++a){const r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){e[Bi(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){var t;const n=Mi(e=(t=e).startsWith(Wi.URL_SCHEME)?t.slice(Wi.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const a=JSON.parse(this.LS.getItem(n.info));return Pi(n),a}}const Gi="://";class ji{constructor(){this.managers={}}static getInstance(){return null==ji.instance&&(ji.instance=new ji),ji.instance}static registerManager(e,t){Ft(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Gi)&&(e=e.slice(0,e.indexOf(Gi))),Ft(e.length>0,(()=>"scheme must not be an empty string."));const n=ji.getInstance();Ft(null==n.managers[e],(()=>"A model store manager is already registered for scheme '".concat(e,"'."))),n.managers[e]=t}static getManager(e){const t=ji.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(ji.getInstance().managers)}}class Hi{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&dn().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return Bo(e)}}if(dn().get("IS_BROWSER")){dn().setPlatform("browser",new Hi);try{ji.registerManager(Wi.URL_SCHEME,new Vi)}catch(CW){}try{ji.registerManager(Ei.URL_SCHEME,new Ri)}catch(CW){}}const Ki=()=>n(817);let qi;class Xi{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=dn().global.fetch?dn().global.fetch(e,t):(null==qi&&(qi=Ki()),qi(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function Yi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",rn(e),new gs(e,t,n)}dn().get("IS_NODE")&&!dn().get("IS_BROWSER")&&dn().setPlatform("node",new Xi);const Ji=$s({cast_:function(e,t){const n=Ys(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const a={x:n},r={dtype:t};return Ws.runKernel(Wn,a,r)}});const $i=$s({clone_:function(e){const t={x:Ys(e,"x","clone","string_or_numeric")};return Ws.runKernel(Da,t)}});Bs();bs={buffer:Yi,cast:Ji,clone:$i,print:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}};const Qi=$s({add_:function(e,t){let n=Ys(e,"a","add"),a=Ys(t,"b","add");[n,a]=Ds(n,a);const r={a:n,b:a};return Ws.runKernel(xn,r)}});const Zi=$s({floorDiv_:function(e,t){let n=Ys(e,"a","floorDiv"),a=Ys(t,"b","floorDiv");[n,a]=Ds(n,a);const r={a:n,b:a};return Ws.runKernel(Na,r)}});const el=$s({div_:function(e,t){let n=Ys(e,"a","div"),a=Ys(t,"b","div");if([n,a]=Ds(n,a),"int32"===n.dtype&&"int32"===a.dtype)return Zi(n,a);const r={a:n,b:a};return Ws.runKernel(pa,r,{})}});const tl=$s({mul_:function(e,t){let n=Ys(e,"a","mul"),a=Ys(t,"b","mul");[n,a]=Ds(n,a);const r={a:n,b:a};return Ws.runKernel(lr,r)}});const nl=$s({sqrt_:function(e){const t={x:Ys(e,"x","sqrt","float32")};return Ws.runKernel(Xr,t)}});const al=$s({square_:function(e){const t=Ys(e,"x","square");return Ws.runKernel("Square",{x:t},{})}});const rl=$s({zerosLike_:function(e){const t={x:Ys(e,"x","zerosLike")};return Ws.runKernel(ko,t)}});function ol(e){return Ws.customGrad(e)}function sl(e,t){if((os(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&os(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Zs(e,[],[],t)}const il=new Map,ll=new Map;class cl{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class ul{constructor(){this.classNameMap={}}static getMap(){return null==ul.instance&&(ul.instance=new ul),ul.instance}static register(e){ul.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function hl(e,t,n){Ft(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Ft("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Ft(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const a=t+">"+n;return ul.register(e),il.set(a,e),ll.set(e,a),e}class dl extends cl{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:a,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:r[e.name]})));this.applyGradients(e)}else this.applyGradients(r);return si(r),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Ft(Jt(e),(()=>"The f passed in variableGrads(f) must be a function")),Ft(null==t||Array.isArray(t)&&t.every((e=>e instanceof ws)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in Ws.registeredVariables)t.push(Ws.registeredVariables[e])}const a=n?t.filter((e=>!e.trainable)):null,r=t.length;t=t.filter((e=>e.trainable)),Ft(t.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(r," variables is ")+"trainable."));const{value:o,grads:s}=Ws.gradients(e,t,null,!0);Ft(s.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Ft(0===o.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(o.rank," tensor")));const i={};return t.forEach(((e,t)=>{null!=s[t]&&(i[e.name]=s[t])})),null!=a&&a.forEach((e=>i[e.name]=null)),{value:o,grads:i}}(e,t)}dispose(){null!=this.iterations_&&si(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:sl(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(dl,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class pl extends dl{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Ws.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Ws.registeredVariables[t],r=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:oi((()=>rl(a).variable(r)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:oi((()=>rl(a).variable(r)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const s=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;oi((()=>{const e=Qi(tl(s,this.rho),tl(al(o),1-this.rho)),t=tl(el(nl(Qi(i,this.epsilon)),nl(Qi(s,this.epsilon))),o),n=Qi(tl(i,this.rho),tl(al(t),1-this.rho));s.assign(e),i.assign(n);const r=Qi(tl(t,-this.learningRate),a);a.assign(r)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(si(this.accumulatedGrads.map((e=>e.variable))),si(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function fl(e,t,n){rn(e);const a={shape:e,value:t,dtype:n=n||Yt(t)};return Ws.runKernel(Sa,{},a)}class gl extends dl{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Ws.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:oi((()=>fl(a.shape,this.initialAccumulatorValue).variable(e)))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const o=this.accumulatedGrads[n].variable;oi((()=>{const e=Qi(o,al(r));o.assign(e);const t=Qi(tl(el(r,nl(Qi(e,Ws.backend.epsilon()))),-this.learningRate),a);a.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&si(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const ml=$s({pow_:function(e,t){let n=Ys(e,"base","pow"),a=Ys(t,"exp","pow");[n,a]=Ds(n,a);const r={a:n,b:a};return Ws.runKernel(yr,r)}});const bl=$s({sub_:function(e,t){let n=Ys(e,"a","sub"),a=Ys(t,"b","sub");[n,a]=Ds(n,a);const r={a:n,b:a};return Ws.runKernel(ho,r)}});class yl extends dl{static get className(){return"Adam"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],oi((()=>{this.accBeta1=sl(t).variable(),this.accBeta2=sl(n).variable()})),null==a&&(this.epsilon=Ws.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);oi((()=>{const n=bl(1,this.accBeta1),a=bl(1,this.accBeta2);t.forEach(((t,r)=>{const o=Ws.registeredVariables[t],s=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:oi((()=>rl(o).variable(s)))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:"".concat(t,"/v"),variable:oi((()=>rl(o).variable(s)))});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const l=this.accumulatedFirstMoment[r].variable,c=this.accumulatedSecondMoment[r].variable,u=Qi(tl(l,this.beta1),tl(i,1-this.beta1)),h=Qi(tl(c,this.beta2),tl(al(i),1-this.beta2)),d=el(u,n),p=el(h,a);l.assign(u),c.assign(h);const f=Qi(tl(el(d,Qi(nl(p),this.epsilon)),-this.learningRate),o);o.assign(f)})),this.accBeta1.assign(tl(this.accBeta1,this.beta1)),this.accBeta2.assign(tl(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&si(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&si(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),oi((()=>{this.accBeta1.assign(ml(this.beta1,this.iterations_+1)),this.accBeta2.assign(ml(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const vl=$s({abs_:function(e){const t=Ys(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Ws.runKernel(jn,e)}{const e={x:t};return Ws.runKernel(bn,e)}}});function xl(e,t){const n=e.length,a=[];for(let r=0;r<n;r++){const o=n-1-r,s=e[o]||1;(t[t.length-1-r]||1)>1&&1===s&&a.unshift(o)}return a}function wl(e,t){const n=[];for(let a=0;a<t.length;a++){const r=e[e.length-a-1],o=t.length-a-1,s=t[o];(null==r||1===r&&s>1)&&n.unshift(o)}return n}function kl(e,t){const n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let o=e[e.length-r-1];null==o&&(o=1);let s=t[t.length-r-1];if(null==s&&(s=1),1===o)a[n-r-1]=s;else if(1===s)a[n-r-1]=o;else{if(o!==s){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}a[n-r-1]=o}}return a}const Sl=$s({maximum_:function(e,t){let n=Ys(e,"a","maximum"),a=Ys(t,"b","maximum");[n,a]=Ds(n,a),"bool"===n.dtype&&(n=Ji(n,"int32"),a=Ji(a,"int32")),kl(n.shape,a.shape);const r={a:n,b:a};return Ws.runKernel(Ja,r)}});class Il extends dl{static get className(){return"Adamax"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],oi((()=>{this.iteration=sl(0).variable(),this.accBeta1=sl(t).variable()})),null==a&&(this.epsilon=Ws.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);oi((()=>{const n=bl(1,this.accBeta1),a=el(-this.learningRate,Qi(tl(this.iteration,this.decay),1));t.forEach(((t,r)=>{const o=Ws.registeredVariables[t],s=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:rl(o).variable(s)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:"".concat(t,"/v"),variable:rl(o).variable(s)});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const l=this.accumulatedFirstMoment[r].variable,c=this.accumulatedWeightedInfNorm[r].variable,u=Qi(tl(l,this.beta1),tl(i,1-this.beta1)),h=tl(c,this.beta2),d=vl(i),p=Sl(h,d);l.assign(u),c.assign(p);const f=Qi(tl(el(a,n),el(u,Qi(p,this.epsilon))),o);o.assign(f)})),this.iteration.assign(Qi(this.iteration,1)),this.accBeta1.assign(tl(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&si(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&si(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Cl extends dl{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const r=Ws.registeredVariables[t];oi((()=>{const e=Qi(tl(this.c,a),r);r.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=ii(sl(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class Nl extends Cl{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=sl(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Ws.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:oi((()=>rl(a).variable(e)))}}const r=this.accumulations[n].variable,o=Array.isArray(e)?e[n].tensor:e[t];null!=o&&oi((()=>{let e;const t=Qi(tl(this.m,r),o);e=this.useNesterov?Qi(tl(this.c,Qi(o,tl(t,this.m))),a):Qi(tl(this.c,t),a),r.assign(t),a.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&si(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class El extends dl{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==a&&(this.epsilon=Ws.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Ws.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:oi((()=>rl(a).variable(r)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:oi((()=>rl(a).variable(r)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:oi((()=>rl(a).variable(r)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const s=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;oi((()=>{const e=Qi(tl(s,this.decay),tl(al(o),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=Qi(tl(t,this.decay),tl(o,1-this.decay)),l=el(tl(o,this.learningRate),nl(bl(e,Qi(al(r),this.epsilon)))),c=Qi(tl(i,this.momentum),l);s.assign(e),t.assign(r),i.assign(c);const u=bl(a,c);a.assign(u)}else{const e=Qi(tl(s,this.decay),tl(al(o),1-this.decay)),t=Qi(tl(i,this.momentum),el(tl(o,this.learningRate),nl(Qi(e,this.epsilon))));s.assign(e),i.assign(t);const n=bl(a,t);a.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&si(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&si(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&si(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Tl=[pl,gl,yl,Il,Nl,El,Cl];function Rl(e){return new Promise((e=>setTimeout(e))).then(e)}class Al{constructor(e){if(!dn().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Al.URL_SCHEME)&&(e=e.slice(Al.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=ni.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=bi(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=a,await Rl((()=>r.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Rl((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:vi(e)}}}}Al.URL_SCHEME="downloads://";function Fl(e,t,n,a){!function(e){Ft(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Ft(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e))),Ft(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t))),Ft(t>=e,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t)))}(n=null==n?0:n,a=null==a?1:a);let r=0;return Promise.all(e.map((o=>(o.then((o=>{const s=n+ ++r/e.length*(a-n);return t(s),o})),o))))}async function Dl(e,t){null==t&&(t={});const n=null==t.fetchFunc?dn().platform.fetch:t.fetchFunc,a=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),r=(null==t.onProgress?await Promise.all(a):await Fl(a,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(r):await Fl(r,t.onProgress,.5,1)}wi.registerSaveRouter((e=>dn().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Al.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new Al(e)}(e.slice(Al.URL_SCHEME.length)):null));class _l{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Ft("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=dn().platform.fetch,Ft(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Ft(2===e.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,")."))),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=bi(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=ni.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:vi(e),responses:[a]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(a.status,"."))}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(IW){let t="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,a=t.weightsManifest;if(null==n&&null==a)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return yi(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=xi(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const a=null==t.fetchFunc?dn().platform.fetch:t.fetchFunc;let r,o=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var s;o<e.length;){if(!r){const n=(await a(e[o],t.requestInit,{isBinary:!0})).body;r=n.getReader()}const{done:i,value:l}=await r.read();if(!i)return void n.enqueue(l);o++,r=void 0,null===(s=t.onProgress)||void 0===s||s.call(t,o/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}(t),r=this.weightPathPrefix||n,o=[],s=[];for(const i of e)for(const e of i.paths)null!=this.weightUrlConverter?s.push(this.weightUrlConverter(e)):o.push(r+e+a);return this.weightUrlConverter&&o.push(...await Promise.all(s)),o}async loadWeights(e){const t=await this.getWeightUrls(e);return[xi(e),await Dl(t,this.loadOptions)]}}function Ol(e){return null!=e.match(_l.URL_SCHEME_REGEX)}_l.URL_SCHEME_REGEX=/^https?:\/\//;const Ll=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Ol(e))):Ol(e),n)return zl(e,t)}return null};function zl(e,t){return new _l(e,t)}wi.registerSaveRouter(Ll),wi.registerLoadRouter(Ll);let Ml;function Pl(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,o=!1,s=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)a=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)r=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)o=!0;else if(null!=e.getContext)s=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+"but was ".concat(e.constructor.name));i=!0}if(null!=_o(Io,Ws.backendName)){const n={pixels:e},a={numChannels:t};return Ws.runKernel(Io,n,a)}const[l,c]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height];let u,h;if(s)u=e.getContext("2d").getImageData(0,0,l,c).data;else if(a||n)u=e.data;else if(o||r||i){if(null==Ml)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Ml=new OffscreenCanvas(1,1).getContext("2d")}else Ml=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ml.canvas.width=l,Ml.canvas.height=c,Ml.drawImage(e,0,0,l,c),u=Ml.getImageData(0,0,l,c).data}if(4===t)h=new Int32Array(u);else{const e=l*c;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=u[4*n+e]}return function(e,t,n){if(_t(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const a=Ks(e,n);if(3!==a.length&&1!==a.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Zs(e,t,a,n)}(h,[c,l,t],"int32")}const Bl=$s({fromPixels_:Pl}),Wl=-2,Ul=-1;function Vl(e,t,n){const a=e.shape.length;Ft(a===t.length,(()=>"Error in slice".concat(a,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(a,")."))),Ft(a===n.length,(()=>"Error in slice".concat(a,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(a,").")));for(let r=0;r<a;++r)Ft(t[r]+n[r]<=e.shape[r],(()=>"Error in slice".concat(a,"D: begin[").concat(r,"] + size[").concat(r,"] ")+"(".concat(t[r]+n[r],") would overflow input.shape[").concat(r,"] (").concat(e.shape[r],")")))}function Gl(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function jl(e,t,n){const a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function Hl(e,t,n,a){const r=[...e];for(let o=r.length;o<a.length;o++)r.push(1);for(let o=0;o<n;o++)0===o?r[t]=1:(r.splice(t,0,1),r.pop());return r}function Kl(e,t,n){return n<=e?n:n-(t-1)}function ql(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function Xl(e,t,n,a,r,o,s,i,l){const c=e.length;let u=new Array(c),h=new Array(c),d=new Array(c);if(t.length&&n>0){const l=t[0],c=n+1;u=Yl(s,l,c,a,e),h=Jl(i,l,c,r,e),d=Hl(o,l,c,e)}else for(let p=0;p<c;p++)u[p]=Ql(s,a,o,e,p,l),h[p]=Zl(i,r,o,e,p,l),d[p]=$l(o,p,l);return{begin:u,end:h,strides:d}}function Yl(e,t,n,a,r){const o=[...r],s=ql(n,t);for(let i=0;i<o.length;i++)if(s.indexOf(i)>-1)o[i]=0;else{const r=Kl(t,n,i);let s=a[r];e&1<<r&&(s=0),o[i]=s}return o}function Jl(e,t,n,a,r){const o=[...r],s=ql(n,t);for(let i=0;i<o.length;i++)if(s.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{const r=Kl(t,n,i);let s=a[r];e&1<<r&&(s=Number.MAX_SAFE_INTEGER),o[i]=s}for(let i=0;i<o.length;i++){const e=r[i];o[i]<0&&(o[i]+=e),o[i]=Tt(0,o[i],r[i])}return o}function $l(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function Ql(e,t,n,a,r,o){let s=t[r];const i=n[r]||1;(e&1<<r||o&1<<r||null==s)&&(s=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=a[r];return s<0&&(s+=l),s=Tt(0,s,l-1),s}function Zl(e,t,n,a,r,o){let s=t[r];const i=n[r]||1;(e&1<<r||o&1<<r||null==s)&&(s=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=a[r];return s<0&&(s+=l),s=i>0?Tt(0,s,l):Tt(-1,s,l-1),s}function ec(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function tc(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function nc(e,t,n){let a;const r=e.shape.length;let o;return a="number"===typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),a.forEach((e=>{Ft(-1!==e,(()=>"slice() does not support negative begin indexing."))})),o=null==n?new Array(r).fill(-1):"number"===typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,o=o.map(((t,n)=>t>=0?t:(Ft(-1===t,(()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,"."))),e.shape[n]-a[n]))),[a,o]}function ac(e,t,n,a,r,o,s,i,l){let c;if(null==a?(c=new Array(t.length),c.fill(1)):c=a,null!=s&&0!==(s&s-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:r,endMask:o,ellipsisMask:s,newAxisMask:i,shrinkAxisMask:l};for(let v=0;v<h.dims;v++)u&&0!==(1<<v&i)&&h.numAddAxisAfterEllipsis++,1<<v&s&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(Wl),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(Ul),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}(h,d);let p=!0,f=!0,g=!0;const m=[],b=[];for(let v=0;v<e.length;++v){if(0===d.strides[v])throw Error("strides[".concat(v,"] must be non-zero"));const t=!!(d.shrinkAxisMask&1<<v),n=e[v];if(-1===n){m.push(t?1:-1);continue}const a=[d.beginMask&1<<v,d.endMask&1<<v],r=[d.strides[v]>0?0:-1,d.strides[v]>0?n:n-1];if(t&&d.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===d.strides[v];const o=!!(d.beginMask&1<<v&&d.endMask&1<<v);if(d.beginValid&&d.endValid){if(t){const e=d.begin[v]<0?n+d.begin[v]:d.begin[v];if(d.begin[v]=e,d.end[v]=d.begin[v]+1,e<0||e>=n)throw Error("slice index ".concat(d.begin[v]," of dimension ").concat(v," out of bounds."))}else d.begin[v]=rc(d.begin[v],0,d.strides[v],n,a,r),d.end[v]=rc(d.end[v],1,d.strides[v],n,a,r);const e=1===d.strides[v]&&0===d.begin[v]&&d.end[v]===n;p=p&&e,f=f&&(0===v&&1===d.strides[v]||e)}else p=p&&1===d.strides[v]&&o,f=f&&(0===v&&1===d.strides[v]||o);let s,i=!1;if(d.beginValid&&d.endValid?(s=d.end[v]-d.begin[v],i=!0):t?(s=1,i=!0):o&&n>=0&&(s=d.strides[v]<0?-n:n,i=!0),i){let e;e=0===s||s<0!==d.strides[v]<0?0:Math.trunc(s/d.strides[v])+(s%d.strides[v]!==0?1:0),m.push(e)}else m.push(-1)}for(let v=0;v<d.finalShapeGatherIndices.length;++v){const e=d.finalShapeGatherIndices[v];e>=0?b.push(m[e]):e===Wl&&b.push(1)}const y=b.filter(((e,t)=>d.finalShapeGatherIndices[t]!==Wl));return{finalShapeSparse:y,finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function rc(e,t,n,a,r,o){if(r[t])return n>0?o[t]:o[t+1&1];{const t=e<0?a+e:e;return t<o[0]?o[0]:t>o[1]?o[1]:t}}const oc=$s({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Ys(e,"x","all","bool")},r={axis:t,keepDims:n};return Ws.runKernel(kn,a,r)}});const sc=$s({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Ys(e,"x","any","bool")},r={axis:t,keepDims:n};return Ws.runKernel(Sn,a,r)}});const ic=$s({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Ys(e,"x","argMax")},a={axis:t};return Ws.runKernel(In,n,a)}});function lc(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5?arguments[5]:void 0;return hc(e,[...t,e[3]],n,o,a,null,null,wc(r))}function cc(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[i,l]=fc(t);let c;if("channelsLast"===s)c=[i,l,e[3],e[3]];else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat ".concat(s));c=[i,l,e[1],e[1]]}return hc(e,c,n,a,r,o,!1,s)}function uc(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[i,l,c]=gc(t);let u,h;if("NDHWC"===s)h="channelsLast",u=[i,l,c,e[4],e[4]];else{if("NCDHW"!==s)throw new Error("Unknown dataFormat ".concat(s));h="channelsFirst",u=[i,l,c,e[1],e[1]]}return dc(e,u,n,a,r,!1,h,o)}function hc(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,c,u,h]=[-1,-1,-1,-1];if("channelsLast"===i)[l,c,u,h]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[l,h,c,u]=e}const[d,p,,f]=t,[g,m]=fc(n),[b,y]=fc(a),v=mc(d,b),x=mc(p,y),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,a,r,o,s,i,l){let c,u,h;if("number"===typeof e){c={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,a,r){null==a&&(a=pc(e,t,n));const o=e[0],s=e[1],i=bc((o-t+2*a)/n+1,r),l=bc((s-t+2*a)/n+1,r);return[i,l]}([t,n],o,a,e,i);u=r[0],h=r[1]}else if("same"===e){u=Math.ceil(t/a),h=Math.ceil(n/r);const e=Math.max(0,(u-1)*a+o-t),i=Math.max(0,(h-1)*r+s-n),l=Math.floor(e/2),d=e-l,p=Math.floor(i/2);c={top:l,bottom:d,left:p,right:i-p,type:"SAME"}}else if("valid"===e)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-o+1)/a),h=Math.ceil((n-s+1)/r);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const d="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],g="channelsLast"===l?e[2][1]:e[3][1];c={top:d,bottom:p,left:f,right:g,type:0===d&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},u=bc((t-o+d+p)/a+1,i),h=bc((n-s+f+g)/r+1,i)}}return{padInfo:c,outHeight:u,outWidth:h}}(r,c,u,g,m,v,x,o,i),I=s?f*h:f;let C;return"channelsFirst"===i?C=[l,I,k,S]:"channelsLast"===i&&(C=[l,k,S,I]),{batchSize:l,dataFormat:i,inHeight:c,inWidth:u,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:w,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:b,dilationWidth:y,inShape:e,outShape:C,filterShape:t}}function dc(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",i=arguments.length>7?arguments[7]:void 0,[l,c,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===s)[l,c,u,h,d]=e;else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat ".concat(s));[l,d,c,u,h]=e}const[p,f,g,,m]=t,[b,y,v]=gc(n),[x,w,k]=gc(a),S=mc(p,x),I=mc(f,w),C=mc(g,k),{padInfo:N,outDepth:E,outHeight:T,outWidth:R}=function(e,t,n,a,r,o,s,i,l,c,u){let h,d,p,f;"valid"===e&&(e=0);if("number"===typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const g=function(e,t,n,a,r,o){null==r&&(r=pc(e,t[0],a[0]));const s=[0,0,0,n];for(let i=0;i<3;i++)e[i]+2*r>=t[i]&&(s[i]=bc((e[i]-t[i]+2*r)/a[i]+1,o));return s}([t,n,a,1],[i,l,c],1,[r,o,s],e,u);d=g[0],p=g[1],f=g[2]}else{if("same"!==e)throw Error("Unknown padding parameter: ".concat(e));{d=Math.ceil(t/r),p=Math.ceil(n/o),f=Math.ceil(a/s);const e=(d-1)*r+i-t,u=(p-1)*o+l-n,g=(f-1)*s+c-a,m=Math.floor(e/2),b=e-m,y=Math.floor(u/2),v=u-y,x=Math.floor(g/2);h={top:y,bottom:v,left:x,right:g-x,front:m,back:b,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(r,c,u,h,b,y,v,S,I,C,i),A=o?m*d:m;let F;return"channelsFirst"===s?F=[l,A,E,T,R]:"channelsLast"===s&&(F=[l,E,T,R,A]),{batchSize:l,dataFormat:s,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:E,outHeight:T,outWidth:R,outChannels:A,padInfo:N,strideDepth:b,strideHeight:y,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:C,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:F,filterShape:t}}function pc(e,t,n){const a=mc(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+a)/2)}function fc(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function gc(e){return"number"===typeof e?[e,e,e]:e}function mc(e,t){return t<=1?e:e+(e-1)*(t-1)}function bc(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function yc(e){const[t,n,a]=fc(e);return 1===t&&1===n&&1===a}function vc(e,t){return yc(e)||yc(t)}function xc(e){return fc(e).every((e=>e>0))}function wc(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function kc(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)Ft(zt(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach((t=>{t.forEach((t=>{Ft(zt(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")))}))}))}}}const Sc=$s({reshape_:function(e,t){const n={x:Ys(e,"x","reshape","string_or_numeric")},a={shape:t};return Ws.runKernel(Tr,n,a)}});const Ic=$s({avgPool_:function(e,t,n,a,r){const o=Ys(e,"x","avgPool","float32");Ft(vc(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let s=o,i=!1;3===o.rank&&(i=!0,s=Sc(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Ft(4===s.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(s.rank,"."))),kc("avgPool",a,r);const l={x:s},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r};let u=Ws.runKernel(Fn,l,c);return u=Ji(u,o.dtype),i?Sc(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Cc=$s({avgPool3d_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const s=Ys(e,"x","avgPool3d","float32");let i=s,l=!1;4===s.rank&&(l=!0,i=Sc(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),Ft(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),Ft("NDHWC"===o,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),Ft("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'"))),kc("avgPool3d",a,r);const c={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:o};let h=Ws.runKernel(_n,c,u);return h=Ji(h,i.dtype),l?Sc(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Nc=$s({batchNorm_:function(e,t,n,a,r,o){null==o&&(o=.001);const s=Ys(e,"x","batchNorm"),i=Ys(t,"mean","batchNorm"),l=Ys(n,"variance","batchNorm");let c,u;null!=r&&(c=Ys(r,"scale","batchNorm")),null!=a&&(u=Ys(a,"offset","batchNorm")),Ft(i.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Ft(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Ft(null==c||i.rank===c.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(e){let t;return t=0===e.rank||1===e.rank?Sc(e,[1,1,1,e.size]):2===e.rank?Sc(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Sc(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(s),scale:c,offset:u,mean:i,variance:l},d={varianceEpsilon:o},p=Ws.runKernel(Ea,h,d);return Sc(p,s.shape)}});const Ec=$s({batchNorm2d_:function(e,t,n,a,r,o){const s=Ys(e,"x","batchNorm"),i=Ys(t,"mean","batchNorm"),l=Ys(n,"variance","batchNorm");let c,u;return null!=r&&(c=Ys(r,"scale","batchNorm")),null!=a&&(u=Ys(a,"offset","batchNorm")),Ft(2===s.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(s.rank,"."))),Ft(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),Ft(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&Ft(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&Ft(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),Nc(s,i,l,u,c,o)}});const Tc=$s({batchNorm3d_:function(e,t,n,a,r,o){const s=Ys(e,"x","batchNorm"),i=Ys(t,"mean","batchNorm"),l=Ys(n,"variance","batchNorm");let c,u;return null!=r&&(c=Ys(r,"scale","batchNorm")),null!=a&&(u=Ys(a,"offset","batchNorm")),Ft(3===s.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(s.rank,"."))),Ft(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),Ft(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&Ft(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&Ft(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),Nc(s,i,l,u,c,o)}});const Rc=$s({batchNorm4d_:function(e,t,n,a,r,o){const s=Ys(e,"x","batchNorm"),i=Ys(t,"mean","batchNorm"),l=Ys(n,"variance","batchNorm");let c,u;return null!=r&&(c=Ys(r,"scale","batchNorm")),null!=a&&(u=Ys(a,"offset","batchNorm")),Ft(4===s.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(s.rank,"."))),Ft(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),Ft(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&Ft(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&Ft(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),Nc(s,i,l,u,c,o)}});const Ac=$s({broadcastTo_:function(e,t){let n=Ys(e,"broadcastTo","x");const a=n.shape;if(rn(t),t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Sc(n,e)}const r=n.shape,o=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])o[c]=1;else if(1!==n.shape[c])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(t,"]."));const s=o.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(0===s.length)return $i(n);const i={x:n},l={reps:o};return Ws.runKernel(go,i,l)}});const Fc=$s({clipByValue_:function(e,t,n){const a=Ys(e,"x","clipByValue");if(Ft(t<=n,(()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,")."))),t===n)return fl(a.shape,t,a.dtype);const r={x:a},o={clipValueMin:t,clipValueMax:n};return Ws.runKernel(Vn,r,o)}});const Dc=$s({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Ft(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=Js(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))})),1===n.length)return $i(n[0]);const a=n,r={axis:t};return Ws.runKernel(Hn,a,r)}});const _c=$s({concat1d_:function(e){return Dc(e,0)}});const Oc=$s({concat2d_:function(e,t){return Dc(e,t)}});const Lc=$s({concat3d_:function(e,t){return Dc(e,t)}});const zc=$s({concat4d_:function(e,t){return Dc(e,t)}});const Mc=$s({conv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0;const i=Ys(e,"x","conv2d","float32"),l=Ys(t,"filter","conv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=Sc(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Ft(4===c.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(c.rank,"."))),Ft(4===l.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(l.rank,"."))),kc("conv2d",a,s);const h="NHWC"===r?c.shape[3]:c.shape[1];Ft(h===l.shape[2],(()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(l.shape[2],"."))),Ft(vc(n,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),Ft(xc(o),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Ft(xc(n),(()=>"Error in conv2D: Strides should be larger than 0."));const d={x:c,filter:l},p={strides:n,pad:a,dataFormat:r,dilations:o,dimRoundingMode:s},f=Ws.runKernel(Kn,d,p);return u?Sc(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Pc=$s({conv1d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,s=arguments.length>6?arguments[6]:void 0;const i=Ys(e,"x","conv1d"),l=Ys(t,"filter","conv1d");let c=i,u=!1;2===i.rank&&(u=!0,c=Sc(i,[1,i.shape[0],i.shape[1]])),Ft(3===c.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(c.rank,"."))),Ft(3===l.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(l.rank,"."))),kc("conv1d",a,s),Ft(c.shape[2]===l.shape[1],(()=>"Error in conv1d: depth of input (".concat(c.shape[2],") must match ")+"input depth for filter ".concat(l.shape[1],"."))),Ft(vc(n,o),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(o,"'"))),Ft(xc(o),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Ft(xc(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Ft("NWC"===r,(()=>"Error in conv1d: got dataFormat of ".concat(r," but only NWC is currently supported.")));const h=Sc(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=Sc(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=Mc(d,h,[1,n],a,"NHWC",[1,o],s);return Sc(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const Bc=$s({conv2DBackpropInput_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=arguments.length>6?arguments[6]:void 0;Ft(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let i=e,l=t,c=!1;3===t.rank&&(c=!0,l=Sc(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),Ft(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),Ft(4===l.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(l.rank))),Ft(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===o?i[3]:i[1],h="NHWC"===o?l.shape[3]:l.shape[1];Ft(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),Ft(h===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),kc("conv2dDerInput",r,s);const d={dy:l,filter:n},p={strides:a,pad:r,dataFormat:o,dimRoundingMode:s,inputShape:i},f=Ws.runKernel(Xn,d,p);return c?Sc(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Wc=$s({conv2dTranspose_:function(e,t,n,a,r,o){const s=Ys(e,"x","conv2dTranspose"),i=Ys(t,"filter","conv2dTranspose");return Bc(n,s,i,a,r,"NHWC",o)}});const Uc=$s({conv3d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const s=Ys(e,"x","conv3d"),i=Ys(t,"filter","conv3d");let l=s,c=!1;4===s.rank&&(c=!0,l=Sc(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),Ft(5===l.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(l.rank,"."))),Ft(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),Ft(l.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(l.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),Ft(vc(n,o),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),Ft("NDHWC"===r,(()=>"Error in conv3d: got dataFormat of ".concat(r," but only NDHWC is currently supported."))),Ft(xc(o),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Ft(xc(n),(()=>"Error in conv3D: Strides should be larger than 0."));const u={x:l,filter:i},h={strides:n,pad:a,dataFormat:r,dilations:o},d=Ws.runKernel(Yn,u,h);return c?Sc(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Vc=$s({conv3DBackpropInput_:function(e,t,n,a,r){Ft(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let o=e,s=t,i=!1;4===t.rank&&(i=!0,s=Sc(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,e[0],e[1],e[2],e[3]]);const l=o[4],c=s.shape[4];Ft(5===o.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(o.length,"."))),Ft(5===s.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(s.rank))),Ft(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),Ft(l===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(l,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),Ft(c===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(c,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:s,filter:n},h={pad:r,strides:a,inputShape:o},d=Ws.runKernel($n,u,h);return i?Sc(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Gc=$s({conv3dTranspose_:function(e,t,n,a,r){const o=Ys(e,"x","conv3dTranspose"),s=Ys(t,"filter","conv3dTranspose");return Vc(n,o,s,a,r)}});const jc=$s({denseBincount_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Ys(e,"x","denseBincount"),o=Ys(t,"weights","denseBincount");Ft("int32"===r.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(r.dtype))),Ft(r.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(r.rank,"."))),Ft(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Ft(o.size===r.size||0===o.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(r.shape,", weights shape: ")+"".concat(o.shape,".")));const s={x:r,weights:o},i={size:n,binaryOutput:a};return Ws.runKernel(aa,s,i)}});const Hc=$s({depthwiseConv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0;const i=Ys(e,"x","depthwiseConv2d","float32"),l=Ys(t,"filter","depthwiseConv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=Sc(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Ft(4===c.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(c.rank,"."))),Ft(4===l.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(l.rank,".")));const h="NHWC"===r?c.shape[3]:c.shape[1];Ft(h===l.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(l.shape[2],"."))),kc("depthwiseConv2d",a,s);const d={x:c,filter:l},p={strides:n,pad:a,dataFormat:r,dilations:o,dimRoundingMode:s},f=Ws.runKernel(oa,d,p);return u?Sc(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Kc=$s({elu_:function(e){const t={x:Ys(e,"x","elu","float32")};return Ws.runKernel(ga,t)}});const qc=$s({equal_:function(e,t){let n=Ys(e,"a","equal","string_or_numeric"),a=Ys(t,"b","equal","string_or_numeric");[n,a]=Ds(n,a),kl(n.shape,a.shape);const r={a:n,b:a};return Ws.runKernel(ya,r)}});const Xc=$s({erf_:function(e){let t=Ys(e,"x","erf");Ft("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=Ji(t,"float32"));const n={x:t};return Ws.runKernel(ba,n)}});const Yc=$s({exp_:function(e){const t={x:Ys(e,"x","exp")};return Ws.runKernel(va,t)}});const Jc=$s({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Ys(e,"x","expandDims","string_or_numeric");Ft(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const a={input:n},r={dim:t};return Ws.runKernel(xa,a,r)}});const $c=$s({tile_:function(e,t){const n=Ys(e,"x","tile","string_or_numeric");Ft(n.rank===t.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,".")));const a={x:n},r={reps:t};return Ws.runKernel(go,a,r)}});const Qc=$s({eye_:function(e,t,n){null==t&&(t=e);const a=Yi([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),r=e<=t?e:t;for(let s=0;s<r;++s)a.set(1,s,s);const o=Sc(a.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return $c(Jc(o,0),[n[0],1,1]);if(2===n.length)return $c(Jc(Jc(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return $c(Jc(Jc(Jc(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const Zc=$s({floor_:function(e){const t={x:Ys(e,"x","floor","float32")};return Ws.runKernel(Ca,t)}});const eu=$s({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r={x:Ys(e,"x","gather"),indices:Ys(t,"indices","gather","int32")},o={axis:n,batchDims:a};return Ws.runKernel(Ta,r,o)}});const tu=$s({greater_:function(e,t){let n=Ys(e,"a","greater","string_or_numeric"),a=Ys(t,"b","greater","string_or_numeric");[n,a]=Ds(n,a),kl(n.shape,a.shape);const r={a:n,b:a};return Ws.runKernel(Aa,r)}});const nu=$s({greaterEqual_:function(e,t){let n=Ys(e,"a","greaterEqual","string_or_numeric"),a=Ys(t,"b","greaterEqual","string_or_numeric");[n,a]=Ds(n,a),kl(n.shape,a.shape);const r={a:n,b:a};return Ws.runKernel(Fa,r)}});const au=$s({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:Ys(e,"x","leakyRelu")},a={alpha:t};return Ws.runKernel(Pa,n,a)}});const ru=$s({log_:function(e){const t={x:Ys(e,"x","log","float32")};return Ws.runKernel(Va,t)}});const ou=$s({log1p_:function(e){const t={x:Ys(e,"x","log1p")};return Ws.runKernel(Ga,t)}});const su=$s({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Ys(e,"x","max")},r={reductionIndices:t,keepDims:n};return Ws.runKernel(Ya,a,r)}});const iu=$s({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Ys(e,"x","sum");"bool"===a.dtype&&(a=Ji(a,"int32"));const r={x:a},o={axis:t,keepDims:n};return Ws.runKernel(Yr,r,o)}});const lu=$s({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Ys(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const a=ol(((e,n)=>{const a=su(e,t,!0),r=bl(e,a),o=bl(Ji(r,"float32"),ru(iu(Yc(r),t,!0)));n([o]);return{value:o,gradFunc:(e,n)=>{const[a]=n,r=Yc(a);return bl(e,tl(iu(e,t,!0),r))}}}));return a(n)}});function cu(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function uu(e,t,n){const a=e.length+t.length,r=[];let o=0,s=0;for(let i=0;i<a;i++)-1===n.indexOf(i)?r.push(e[o++]):r.push(t[s++]);return r}function hu(e,t){const n=[],a=e.length;for(let r=0;r<a;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map((t=>e[t]))]}function du(e,t){return uu(e,t.map((e=>1)),t)}function pu(e,t,n){Ft(cu(t,n),(()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input.")))}function fu(e,t){if(cu(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach((e=>n.push(e))),n}function gu(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function mu(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}const bu=$s({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=Ys(e,"x","logSumExp"),r=Ut(t,a.shape),o=su(a,r,!0),s=bl(a,o),i=Yc(s),l=iu(i,r),c=ru(l),u=Qi(Sc(o,c.shape),c);if(n){const e=du(u.shape,r);return Sc(u,e)}return u}});const yu=$s({logicalAnd_:function(e,t){const n=Ys(e,"a","logicalAnd","bool"),a=Ys(t,"b","logicalAnd","bool");kl(n.shape,a.shape);const r={a:n,b:a};return Ws.runKernel(ja,r)}});const vu=$s({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=Ys(e,"a","matMul"),o=Ys(t,"b","matMul");[r,o]=Ds(r,o);const s={a:r,b:o},i={transposeA:n,transposeB:a};return Ws.runKernel(Ln,s,i)}});const xu=$s({maxPool_:function(e,t,n,a,r){const o=Ys(e,"x","maxPool");let s=o,i=!1;3===o.rank&&(i=!0,s=Sc(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Ft(4===s.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(s.rank,"."))),Ft(vc(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),kc("maxPool",a,r);const l={x:s},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r},u=Ws.runKernel($a,l,c);return i?Sc(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const wu=$s({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const s=Ys(e,"x","maxPool3d");let i=s,l=!1;4===s.rank&&(l=!0,i=Sc(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),Ft(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),Ft("NDHWC"===o,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),kc("maxPool3d",a,r);const c={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:o},h=Ws.runKernel(Za,c,u);return l?Sc(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const ku=$s({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Ys(e,"x","mean")},r={axis:t,keepDims:n};return Ws.runKernel(nr,a,r)}});const Su=$s({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Ys(e,"x","min")},r={axis:t,keepDims:n};return Ws.runKernel(ar,a,r)}});const Iu=$s({minimum_:function(e,t){let n=Ys(e,"a","minimum"),a=Ys(t,"b","minimum");[n,a]=Ds(n,a),"bool"===n.dtype&&(n=Ji(n,"int32"),a=Ji(a,"int32")),kl(n.shape,a.shape);const r={a:n,b:a};return Ws.runKernel(rr,r)}});const Cu=$s({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Ut(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=Ys(e,"x","moments")).shape),a=ku(e,n,t);let r=a.shape;t||(r=du(a.shape,n));const o=al(bl(Ji(e,"float32"),Sc(a,r)));return{mean:a,variance:ku(o,n,t)}}});const Nu=$s({neg_:function(e){const t={x:Ys(e,"x","neg")};return Ws.runKernel(cr,t)}});const Eu=$s({notEqual_:function(e,t){let n=Ys(e,"a","notEqual","string_or_numeric"),a=Ys(t,"b","notEqual","string_or_numeric");[n,a]=Ds(n,a),kl(n.shape,a.shape);const r={a:n,b:a};return Ws.runKernel(ur,r)}});const Tu=$s({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const o={indices:Ys(e,"indices","oneHot","int32")},s={dtype:r,depth:t,onValue:n,offValue:a};return Ws.runKernel(gr,o,s)}});function Ru(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(rn(e),"complex64"===t){const t=Ru(e,"float32"),n=Ru(e,"float32");return Qs(t,n)}const n=nn(Ot(e),t);return Ws.makeTensor(n,e,t)}function Au(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(rn(e),"complex64"===t){const t=Au(e,"float32"),n=Ru(e,"float32");return Qs(t,n)}const n=tn(Ot(e),t);return Ws.makeTensor(n,e,t)}const Fu=$s({onesLike_:function(e){const t={x:Ys(e,"x","onesLike")};return Ws.runKernel(fr,t)}});const Du=$s({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=Ys(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},o={x:a};return Ws.runKernel(br,o,r)}});const _u=$s({prelu_:function(e,t){const n={x:Ys(e,"x","prelu"),alpha:Ys(t,"alpha","prelu")};return Ws.runKernel(vr,n)}});var Ou=n(334);class Lu{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=r||Math.random();this.random=Ou.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,r,o;do{a=2*this.random()-1,r=2*this.random()-1,o=a*a+r*r}while(o>=1||0===o);const s=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*a*s,t=this.mean+this.stdDev*r*s,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class zu{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"===typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=Ou.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Mu=$s({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(rn(e),null!=a&&"bool"===a)throw new Error("Unsupported data type ".concat(a));const o=new Lu(t,n,a,!1,r),s=Yi(e,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});const Pu=$s({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;rn(e);const o=Yi(e,a),s=new zu(t,n,null,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});function Bu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:a};return Ws.runKernel(Ir,{},r)}const Wu=$s({relu_:function(e){const t={x:Ys(e,"x","relu")};return Ws.runKernel(Er,t)}});const Uu=$s({reverse_:function(e,t){const n={x:Ys(e,"x","reverse")},a={dims:t};return Ws.runKernel(Or,n,a)}});const Vu=$s({selu_:function(e){const t={x:Ys(e,"x","selu")};return Ws.runKernel(Ur,t)}});const Gu=$s({separableConv2d_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=Ys(e,"x","separableConv2d"),l=Ys(t,"depthwiseFilter","separableConv2d"),c=Ys(n,"pointwiseFilter","separableConv2d");let u=i,h=!1;if(3===i.rank&&(h=!0,u=Sc(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===s)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Ft(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),Ft(4===l.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),Ft(4===c.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),Ft(1===c.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(c.shape[0],"."))),Ft(1===c.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(c.shape[1],".")));const d=l.shape[2],p=l.shape[3];Ft(c.shape[2]===d*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(c.shape[2],".")));const f=Hc(u,l,a,r,s,o),g=Mc(f,c,1,"valid",s);return h?Sc(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});const ju=$s({sigmoid_:function(e){const t={x:Ys(e,"x","sigmoid","float32")};return Ws.runKernel(Kr,t)}});const Hu=$s({slice_:function(e,t,n){const a=Ys(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const r={x:a},o={begin:t,size:n};return Ws.runKernel(Vr,r,o)}});const Ku=$s({slice1d_:function(e,t,n){const a=Ys(e,"x","slice1d");return Ft(1===a.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(a.rank," tensor"))),Hu(a,[t],[n])}});const qu=$s({slice2d_:function(e,t,n){const a=Ys(e,"x","slice2d");return Ft(2===a.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(a.rank," tensor"))),Hu(a,t,n)}});const Xu=$s({slice3d_:function(e,t,n){const a=Ys(e,"x","slice3d");return Ft(3===a.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(a.rank," tensor"))),Hu(a,t,n)}});const Yu=$s({slice4d_:function(e,t,n){const a=Ys(e,"x","slice4d");return Ft(4===a.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(a.rank," tensor"))),Hu(a,t,n)}});const Ju=$s({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Ys(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const a={logits:n},r={dim:t};return Ws.runKernel(Qr,a,r)}});const $u=$s({softplus_:function(e){const t={x:Ys(e,"x","softplus")};return Ws.runKernel(qr,t)}});const Qu=$s({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a={x:Ys(e,"x","split")},r={numOrSizeSplits:t,axis:n};return Ws.runKernel($r,a,r)}});const Zu=$s({squeeze_:function(e,t){const n=Ys(e,"x","squeeze","string_or_numeric");return Sc(n,Vt(n.shape,t).newShape)}});const eh=$s({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Js(e,"tensors","stack","string_or_numeric");Ft(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Ft(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const a=n,r={axis:t};return Ws.runKernel(mr,a,r)}});const th=$s({tanh_:function(e){const t={x:Ys(e,"x","tanh","float32")};return Ws.runKernel(fo,t)}});function nh(e,t){_t(e);const n=Ks(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Zs(e,null,n,t)}function ah(e,t,n){if(_t(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=Ks(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Zs(e,t,a,n)}const rh=$s({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(rn(e),null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const o=new Lu(t,n,a,!0,r),s=Yi(e,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});const oh=$s({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Ys(e,"x","unstack","string_or_numeric");Ft(t>=-n.shape.length&&t<n.shape.length,(()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const a={value:n},r={axis:t};return Ws.runKernel(xo,a,r)}});const sh=$s({where_:function(e,t,n){const a=Ys(t,"a","where"),r=Ys(n,"b","where"),o=Ys(e,"condition","where","bool"),s=kl(kl(o.shape,a.shape),r.shape),i={condition:Ac(o,s),t:Ac(a,s),e:Ac(r,s)};return Ws.runKernel(Wr,i)}});const ih=$s({imag_:function(e){const t={input:Ys(e,"input","imag")};return Ws.runKernel(Oa,t)}});const lh=$s({real_:function(e){const t={input:Ys(e,"input","real")};return Ws.runKernel(Cr,t)}});const ch=$s({transpose_:function(e,t,n){const a=Ys(e,"x","transpose");if(null==t&&(t=a.shape.map(((e,t)=>t)).reverse()),Ft(a.rank===t.length,(()=>"Error in transpose: rank of input ".concat(a.rank," ")+"must match length of perm ".concat(t,"."))),t.forEach((e=>{Ft(e>=0&&e<a.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(a.rank-1)+" but got ".concat(t)))})),a.rank<=1)return a.clone();const r={x:a},o={perm:t};return"complex64"===a.dtype?oi((()=>{let e=lh(a),t=ih(a);return e=Ws.runKernel(yo,{x:e},o),t=Ws.runKernel(yo,{x:t},o),n&&(t=Nu(t)),Qs(e,t)})):Ws.runKernel(yo,r,o)}});const uh=$s({dropout_:function(e,t,n,a){const r=Ys(e,"x","dropout");if(Ft("float32"===r.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(r.dtype," tensor instead."))),Ft(t>=0&&t<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(t,"."))),0===t)return e instanceof vs?r.clone():r;const o=function(e,t){if(null==t)return e.shape.slice();if(Lt(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}(r,n),s=1-t,i=el(Zc(Qi(Pu(o,0,1,"float32",a),s)),s);return tl(r,i)}});const hh=$s({fft_:function(e){Ft("complex64"===e.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return Ws.runKernel(ka,t)}});const dh=$s({rfft_:function(e,t){Ft("float32"===e.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(e.dtype)));let n=e.shape[e.shape.length-1];const a=e.size/n;let r;if(null!=t&&t<n){const a=e.shape.map((e=>0)),o=e.shape.map((e=>e));o[e.shape.length-1]=t,r=Hu(e,a,o),n=t}else if(null!=t&&t>n){const a=e.shape.map((e=>e));a[e.shape.length-1]=t-n,r=Dc([e,Ru(a)],e.shape.length-1),n=t}else r=e;const o=rl(r),s=Sc(Qs(r,o),[a,n]),i=hh(s),l=Math.floor(n/2)+1,c=lh(i),u=ih(i),h=Qu(c,[l,n-l],c.shape.length-1),d=Qu(u,[l,n-l],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,Sc(Qs(h[0],d[0]),p)}});const ph=$s({ifft_:function(e){Ft("complex64"===e.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return Ws.runKernel(_a,t)}});const fh=$s({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const r=Sc(e,[n,t]);a=ph(r)}else{const r=[n,2*(t-1)],o=Sc(lh(e),[n,t]),s=Sc(ih(e),[n,t]),i=Uu(Hu(o,[0,1],[n,t-2]),1),l=tl(Uu(Hu(s,[0,1],[n,t-2]),1),sl(-1)),c=Dc([o,i],1),u=Dc([s,l],1),h=Sc(Qs(c,u),[r[0],r[1]]);a=ph(h)}if(a=lh(a),3===e.rank&&0!==e.shape[0]){const t=a,n=e.shape[0];a=Sc(a,[n,a.shape[0]/n,a.shape[1]]),t.dispose()}return a}});const gh=$s({conv2DBackpropFilter_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=Sc(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Sc(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Ft(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),Ft(4===l.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(l.shape,"."))),Ft(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const c="NHWC"===o?i.shape[3]:i.shape[1],u="NHWC"===o?l.shape[3]:l.shape[1];Ft(c===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(c,") must ")+"match input depth in filter (".concat(n[2],"."))),Ft(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),kc("conv2dDerFilter",r,s);const h={x:i,dy:l},d={strides:a,pad:r,dataFormat:o,dimRoundingMode:s,filterShape:n};return Ws.runKernel(qn,h,d)}});const mh=$s({relu6_:function(e){const t={x:Ys(e,"x","relu6")};return Ws.runKernel(_r,t)}});const bh=$s({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Ys(e,"x","step")},a={alpha:t};return Ws.runKernel(So,n,a)}});function yh(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return tl(e,bh(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function vh(e,t){let n=t;const a=wl(e.shape,t.shape);return a.length>0&&(n=iu(n,a)),Sc(n,e.shape)}function xh(e,t,n,a){if("linear"===t)return e;if("relu"===t)return Wu(e);if("elu"===t)return Kc(e);if("relu6"===t)return mh(e);if("prelu"===t)return _u(e,n);if("leakyrelu"===t)return au(e,a);if("sigmoid"===t)return ju(e);throw new Error("Unknown fused activation ".concat(t,"."))}const wh=(e,t)=>!(e>0)||"linear"===t;const kh=$s({fusedConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:l,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:h}=e;if(c=c||"linear",!1===wh(Ws.state.gradientDepth,c)){Ft("NHWC"===o,(()=>"Error in fused conv2d: got dataFormat of ".concat(o," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let e=Mc(t,n,a,r,o,s,i);return null!=l&&(e=Qi(e,l)),xh(e,c,u,h)}const d=Ys(t,"x","conv2d","float32"),p=Ys(n,"filter","conv2d","float32");let f=d,g=!1;3===d.rank&&(g=!0,f=Sc(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Ft(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),Ft(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),kc("fused conv2d",r,i);const m="NHWC"===o?f.shape[3]:f.shape[1];Ft(p.shape[2]===m,(()=>"Error in conv2d: depth of input (".concat(m,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),Ft(vc(a,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(a," and dilations '").concat(s,"'")));const b=hc(f.shape,p.shape,a,s,r,i);let y,v;if(null!=l&&(y=Ys(l,"bias","fused conv2d"),[y]=Ds(y,d),"NHWC"===o?kl(b.outShape,y.shape):(Ft(y.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(y.shape.length,"."))),Ft(0===y.shape.length||y.shape[0]===b.outChannels||1===y.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(y.shape,") is not ")+"compatible with the number of output channels "+"(".concat(b.outChannels,")"))))),null!=u){const e=u.shape;if(Ft(e.length<=1||3===e.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,"."))),1===e.length)Ft(1===e[0]||e[0]===b.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(b.outChannels,").")));else if(3===e.length)try{kl(e,b.outShape)}catch(IW){const n="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(b.outShape,").");throw Error(n)}v=Ys(u,"prelu weights","fused conv2d")}const x=(e,t)=>{Ft("NHWC"===o,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(o," but only NHWC is currently supported.")));const[n,i,l,u]=t,h=yh(e,l,c);Ft(yc(s),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'")));const d=[Bc(i.shape,h,n,a,r),gh(i,h,n.shape,a,r)];if(null!=u){const e=vh(u,h);d.push(e)}return d},w={x:f,filter:p,bias:y,preluActivationWeights:v},k={strides:a,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:c,leakyreluAlpha:h};if(null==l){const e=ol(((e,t,n)=>{let a=Ws.runKernel(Eo,w,k);return n([t,e,a]),g&&(a=Sc(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}));return e(f,p)}{const e=ol(((e,t,n,a)=>{let r=Ws.runKernel(Eo,w,k);return a([t,e,r,n]),g&&(r=Sc(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p,y)}}});const Sh=$s({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=Sc(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Sc(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:i,dy:l},u={strides:a,pad:r,dimRoundingMode:s,dilations:o,filterShape:n};return Ws.runKernel(sa,c,u)}});const Ih=$s({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,i=t,l=!1;3===t.rank&&(l=!0,i=Sc(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:i,filter:n},u={strides:a,pad:r,dimRoundingMode:s,dilations:o,inputShape:e},h=Ws.runKernel(ia,c,u);return l?Sc(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const Ch=$s({fusedMatMul_:function(e){let{a:t,b:n,transposeA:a=!1,transposeB:r=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:l=.2}=e;if(!1===wh(Ws.state.gradientDepth,s)){let e=vu(t,n,a,r);return null!=o&&(e=Qi(e,o)),xh(e,s,i,l)}let c=Ys(t,"a","fused matMul"),u=Ys(n,"b","fused matMul");[c,u]=Ds(c,u);const h=a?c.shape[c.rank-2]:c.shape[c.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=a?c.shape[c.rank-1]:c.shape[c.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],g=c.shape.slice(0,-2),m=u.shape.slice(0,-2),b=Ot(g),y=Ot(m);Ft(h===d,(()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(c.shape," and ")+"".concat(u.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const v=kl(c.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),x=Sc(c,a?[b,h,p]:[b,p,h]),w=Sc(u,r?[y,f,d]:[y,d,f]);let k,S;null!=o&&(k=Ys(o,"bias","fused matMul"),[k]=Ds(k,c),kl(v,k.shape)),null!=i&&(S=Ys(i,"prelu weights","fused matMul"));const I=(e,t)=>{const[n,i,l,c]=t,u=yh(Sc(e,l.shape),l,s);let h,d;if(a||r?!a&&r?(h=vu(u,i,!1,!1),d=vu(u,n,!0,!1)):a&&!r?(h=vu(i,u,!1,!0),d=vu(n,u,!1,!1)):(h=vu(i,u,!0,!0),d=vu(u,n,!0,!0)):(h=vu(u,i,!1,!0),d=vu(n,u,!0,!1)),null!=o){return[h,d,vh(c,u)]}return[h,d]},C={a:x,b:w,bias:k,preluActivationWeights:S},N={transposeA:a,transposeB:r,activation:s,leakyreluAlpha:l};if(null==o){const e=ol(((e,t,n)=>{const a=Ws.runKernel(No,C,N);return n([e,t,a]),{value:Sc(a,v),gradFunc:I}}));return e(x,w)}{const e=ol(((e,t,n,a)=>{const r=Ws.runKernel(No,C,N);return a([e,t,r,n]),{value:Sc(r,v),gradFunc:I}}));return e(x,w,k)}}});const Nh=$s({cropAndResize_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=Ys(e,"image","cropAndResize"),i=Ys(t,"boxes","cropAndResize","float32"),l=Ys(n,"boxInd","cropAndResize","int32"),c=i.shape[0];Ft(4===s.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(s.rank,"."))),Ft(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(c,",4] ")+"but had shape ".concat(i.shape,"."))),Ft(1===l.rank&&l.shape[0]===c,(()=>"Error in cropAndResize: boxInd must be have size [".concat(c,"] ")+"but had shape ".concat(i.shape,"."))),Ft(2===a.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(a.length,"."))),Ft(a[0]>=1&&a[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(a))),Ft("bilinear"===r||"nearest"===r,(()=>"method must be bilinear or nearest, but was ".concat(r)));const u={image:s,boxes:i,boxInd:l},h={method:r,extrapolationValue:o,cropSize:a};return Ws.runKernel(na,u,h)}});const Eh=$s({flipLeftRight_:function(e){const t=Ys(e,"image","flipLeftRight","float32");Ft(4===t.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,".")));const n={image:t};return Ws.runKernel(Ia,n,{})}});const Th=$s({grayscaleToRGB_:function(e){const t=Ys(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];Ft(t.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),Ft(1===a,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(a,".")));const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,$c(t,r)}});const Rh=$s({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const r=n.map(((e,t)=>Ys(e,"tensors".concat(t),"einsum"))),o={equation:e};return Ws.runKernel(fa,r,o)}});const Ah=$s({rgbToGrayscale_:function(e){const t=Ys(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];Ft(t.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),Ft(3===a,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(a,".")));const r=t.dtype,o=Ji(t,"float32"),s=nh([.2989,.587,.114]);let i;switch(t.rank){case 2:i=Rh("ij,j->i",o,s);break;case 3:i=Rh("ijk,k->ij",o,s);break;case 4:i=Rh("ijkl,l->ijk",o,s);break;case 5:i=Rh("ijklm,m->ijkl",o,s);break;case 6:i=Rh("ijklmn,n->ijklm",o,s);break;default:throw new Error("Not a valid tensor rank.")}return i=Jc(i,-1),Ji(i,r)}});const Fh=$s({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Ys(e,"image","rotateWithOffset","float32");Ft(4===r.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(r.rank,".")));const o={image:r},s={radians:t,fillValue:n,center:a};return Ws.runKernel(Co,o,s)}});function Dh(e,t,n,a,r,o){null==a&&(a=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==o&&(o=0);const s=e.shape[0];return n=Math.min(n,s),Ft(0<=a&&a<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(a,"'"))),Ft(2===e.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'"))),Ft(4===e.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1]))),Ft(1===t.rank,(()=>"scores must be a 1D tensor")),Ft(t.shape[0]===s,(()=>"scores has incompatible shape with boxes. Expected ".concat(s,", ")+"but was ".concat(t.shape[0]))),Ft(0<=o&&o<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(o,"'"))),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:o}}const _h=$s({nonMaxSuppression_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=Ys(e,"boxes","nonMaxSuppression","float32"),s=Ys(t,"scores","nonMaxSuppression","float32"),i=Dh(o,s,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const l={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return Ws.runKernel(hr,{boxes:o,scores:s},l)}});function Oh(e,t,n){const a=function(e,t,n){return function(e,t,n){let a=0,r=e.length,o=0,s=!1;for(;a<r;){o=a+(r-a>>>1);const i=n(t,e[o]);i>0?a=o+1:(r=o,s=!i)}return s?a:-a-1}(e,t,n||Lh)}(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function Lh(e,t){return e>t?1:e<t?-1:0}function zh(e,t,n,a,r){return Bh(e,t,n,a,r,0)}function Mh(e,t,n,a,r,o){return Bh(e,t,n,a,r,0,!1,o,!0)}function Ph(e,t,n,a,r,o){return Bh(e,t,n,a,r,o,!0)}function Bh(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const c=[];for(let m=0;m<t.length;m++)t[m]>r&&c.push({score:t[m],boxIndex:m,suppressBeginIndex:0});c.sort(Vh);const u=o>0?-.5/o:0,h=[],d=[];for(;h.length<n&&c.length>0;){const t=c.pop(),{score:n,boxIndex:o,suppressBeginIndex:s}=t;if(n<r)break;let i=!1;for(let l=h.length-1;l>=s;--l){const n=Wh(e,o,h[l]);if(n>=a){i=!0;break}if(t.score=t.score*Uh(a,u,n),t.score<=r)break}t.suppressBeginIndex=h.length,i||(t.score===n?(h.push(o),d.push(t.score)):t.score>r&&Oh(c,t,Vh))}const p=h.length,f=n-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return s&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function Wh(e,t,n){const a=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),o=Math.min(a[0],a[2]),s=Math.min(a[1],a[3]),i=Math.max(a[0],a[2]),l=Math.max(a[1],a[3]),c=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(i-o)*(l-s),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const g=Math.max(o,c),m=Math.max(s,u),b=Math.min(i,h),y=Math.min(l,d),v=Math.max(b-g,0)*Math.max(y-m,0);return v/(p+f-v)}function Uh(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function Vh(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const Gh=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=Ys(e,"boxes","nonMaxSuppressionAsync"),s=Ys(t,"scores","nonMaxSuppressionAsync"),i=Dh(o,s,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const l=await Promise.all([o.data(),s.data()]),c=l[0],u=l[1],{selectedIndices:h}=zh(c,u,n,a,r);return o!==e&&o.dispose(),s!==t&&s.dispose(),nh(h,"int32")};const jh=$s({nonMaxSuppressionWithScore_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=Ys(e,"boxes","nonMaxSuppression"),i=Ys(t,"scores","nonMaxSuppression"),l=Dh(s,i,n,a,r,o);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;const c={boxes:s,scores:i},u={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:o},h=Ws.runKernel(pr,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}});const Hh=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=Ys(e,"boxes","nonMaxSuppressionAsync"),i=Ys(t,"scores","nonMaxSuppressionAsync"),l=Dh(s,i,n,a,r,o);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;const c=await Promise.all([s.data(),i.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=Ph(u,h,n,a,r,o);return s!==e&&s.dispose(),i!==t&&i.dispose(),{selectedIndices:nh(d,"int32"),selectedScores:nh(p)}};const Kh=$s({nonMaxSuppressionPadded_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=Ys(e,"boxes","nonMaxSuppression"),i=Ys(t,"scores","nonMaxSuppression"),l=Dh(s,i,n,a,r,null),c={boxes:s,scores:i},u={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:o},h=Ws.runKernel(dr,c,u);return{selectedIndices:h[0],validOutputs:h[1]}}});const qh=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=Ys(e,"boxes","nonMaxSuppressionAsync"),i=Ys(t,"scores","nonMaxSuppressionAsync"),l=Dh(s,i,n,a,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([s.data(),i.data()]),{selectedIndices:f,validOutputs:g}=Mh(d,p,c,u,h,o);return s!==e&&s.dispose(),i!==t&&i.dispose(),{selectedIndices:nh(f,"int32"),validOutputs:sl(g,"int32")}};const Xh=$s({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Ys(e,"images","resizeBilinear");Ft(3===r.rank||4===r.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),Ft(2===t.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,"."))),Ft(!1===a||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let o=r,s=!1;3===r.rank&&(s=!0,o=Sc(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:o},l={alignCorners:n,halfPixelCenters:a,size:t},c=Ws.runKernel(Fr,i,l);return s?Sc(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Yh=$s({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Ys(e,"images","resizeNearestNeighbor");Ft(3===r.rank||4===r.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),Ft(2===t.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,"."))),Ft("float32"===r.dtype||"int32"===r.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Ft(!1===a||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let o=r,s=!1;3===r.rank&&(s=!0,o=Sc(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:o},l={alignCorners:n,halfPixelCenters:a,size:t},c=Ws.runKernel(Rr,i,l);return s?Sc(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Jh=$s({bincount_:function(e,t,n){const a=Ys(e,"x","bincount"),r=Ys(t,"weights","bincount");Ft("int32"===a.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(a.dtype))),Ft(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Ft(r.size===a.size||0===r.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(a.shape,", weights shape: ")+"".concat(r.shape,".")));const o={x:a,weights:r},s={size:n};return Ws.runKernel(Mn,o,s)}});const $h=$s({lessEqual_:function(e,t){let n=Ys(e,"a","lessEqual","string_or_numeric"),a=Ys(t,"b","lessEqual","string_or_numeric");[n,a]=Ds(n,a),kl(n.shape,a.shape);const r={a:n,b:a};return Ws.runKernel(Wa,r)}});const Qh=$s({round_:function(e){const t={x:Ys(e,"x","round")};return Ws.runKernel(Lr,t)}});const Zh=$s({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Ys(e,"image","threshold"),o=r.shape[0]*r.shape[1];let s,i,l,c,u=tl(nh([a]),255);if(Ft(3===r.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(r.rank,"."))),Ft(3===r.shape[2]||1===r.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(r.shape[2],"."))),Ft("int32"===r.dtype||"float32"===r.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(r.dtype,"."))),Ft("otsu"===t||"binary"===t,(()=>"Method must be binary or otsu, but was ".concat(t))),3===r.shape[2]){[s,i,l]=Qu(r,[1,1,1],-1);const e=tl(s,.2989),t=tl(i,.587),n=tl(l,.114);c=Qi(Qi(e,t),n)}else c=e;if("otsu"===t){u=function(e,t){let n,a,r,o,s,i,l=nh([-1]),c=nh([0]),u=nh([0]);for(let h=0;h<e.size-1;h++){n=Hu(e,0,h+1),a=Hu(e,h+1),s=el(iu(n),t),i=el(iu(a),t);const d=iu(tl(n,Bu(0,n.size)));r=el(d,iu(n));const p=fl(a.shape,n.size),f=Qi(Bu(0,a.size),p),g=tl(a,f);o=el(iu(g),iu(a));const m=bl(r,o),b=bl(r,o),y=tl(s,i);u=tl(tl(y,m),b);const v=tu(u,c);c=sh(v,u,c),l=sh(v,nh([h]),l)}return l}(Jh(Ji(Qh(c),"int32"),ei([]),256),o)}const h=n?$h(c,u):tu(c,u);return Ji(tl(h,255),"int32")}});const ed=$s({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5?arguments[5]:void 0;const s=Ys(e,"image","transform","float32"),i=Ys(t,"transforms","transform","float32");Ft(4===s.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(s.rank,"."))),Ft(2===i.rank&&(i.shape[0]===s.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Ft(null==o||2===o.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(o,".")));const l={image:s,transforms:i},c={interpolation:n,fillMode:a,fillValue:r,outputShape:o};return Ws.runKernel(bo,l,c)}});const td=$s({less_:function(e,t){let n=Ys(e,"a","less","string_or_numeric"),a=Ys(t,"b","less","string_or_numeric");[n,a]=Ds(n,a),kl(n.shape,a.shape);const r={a:n,b:a};return Ws.runKernel(Ba,r)}});const nd=$s({bandPart_:function(e,t,n){const a=Ys(e,"a","bandPart");Ft(a.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(a.rank,".")));const r=a.shape,[o,s]=a.shape.slice(-2);let i,l;"number"===typeof t?(Ft(t%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(t,"."))),Ft(t<=o,(()=>"bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(o,")."))),i=Ys(t<0?o:t,"numLower","bandPart")):(Ft("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),i=sh(td(t,0),o,Iu(t,o))),"number"===typeof n?(Ft(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,"."))),Ft(n<=s,(()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(s,")."))),l=Ys(n<0?s:n,"numUpper","bandPart")):(Ft("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=sh(td(n,0),s,Iu(n,s)));const c=Sc(Bu(0,o,1,"int32"),[-1,1]),u=Bu(0,s,1,"int32"),h=bl(c,u),d=yu($h(h,i),nu(h,Nu(l))),p=Ru([o,s],a.dtype);return Sc(eh(oh(Sc(a,[-1,o,s])).map((e=>sh(d,e,p)))),r)}});function ad(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return vl(e);if(1!==e.rank&&null===n)return ad(Sc(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return iu(vl(e),n);if(t===1/0)return su(vl(e),n);if(t===-1/0)return Su(vl(e),n);if("euclidean"===t||2===t)return nl(iu(ml(vl(e),sl(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return su(iu(vl(e),n[0]),n[1]-1);if(t===1/0)return su(iu(vl(e),n[1]),n[0]);if(t===-1/0)return Su(iu(vl(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return nl(iu(al(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const rd=$s({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=ad(e=Ys(e,"x","norm"),t,n);let o=r.shape;if(a){const t=Ut(n,e.shape);o=du(r.shape,t)}return Sc(r,o)}});const od=$s({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Ft(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Ft(e[t].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")")))}else t=!0,e=Qu(e,e.shape[0],0).map((e=>Zu(e,[0])));Ft(e.length<=e[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],").")));const n=[],a=e;for(let r=0;r<e.length;++r)n.push(Ws.tidy((()=>{let e=a[r];if(r>0)for(let t=0;t<r;++t){const a=tl(iu(tl(n[t],e)),n[t]);e=bl(e,a)}return el(e,rd(e,"euclidean"))})));return t?eh(n,0):n}});function sd(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Ws.tidy((()=>{Ft(2===e.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor.")));const n=e.shape[0],a=e.shape[1];let r=Qc(n),o=$i(e);const s=ah([[1]],[1,1]);let i=$i(s);const l=n>=a?a:n;for(let e=0;e<l;++e){const t=o,l=i,c=r;[i,o,r]=Ws.tidy((()=>{const t=Hu(o,[e,e],[n-e,1]),l=rd(t),c=Hu(o,[e,e],[1,1]),u=sh(tu(c,0),ah([[-1]]),ah([[1]])),h=bl(c,tl(u,l)),d=el(t,h);i=1===d.shape[0]?$i(s):Dc([s,Hu(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=Nu(el(vu(u,h),l)),f=Hu(o,[e,0],[n-e,a]),g=tl(p,i),m=ch(i);if(0===e)o=bl(f,vu(g,vu(m,f)));else{const t=bl(f,vu(g,vu(m,f)));o=Dc([Hu(o,[0,0],[e,a]),t],0)}const b=ch(g),y=Hu(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=bl(y,vu(vu(y,i),b));else{const t=bl(y,vu(vu(y,i),b));r=Dc([Hu(r,[0,0],[n,e]),t],1)}return[i,o,r]})),si([t,l,c])}return!t&&n>a&&(r=Hu(r,[0,0],[n,a]),o=Hu(o,[0,0],[a,a])),[r,o]}))}const id=$s({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Ft(e.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank))),2===e.rank)return sd(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),a=oh(Sc(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],o=[];a.forEach((e=>{const[n,a]=sd(e,t);r.push(n),o.push(a)}));return[Sc(eh(r,0),e.shape),Sc(eh(o,0),e.shape)]}}});var ld;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(ld||(ld={}));const cd=$s({squaredDifference_:function(e,t){let n=Ys(e,"a","squaredDifference"),a=Ys(t,"b","squaredDifference");[n,a]=Ds(n,a),kl(n.shape,a.shape);const r={a:n,b:a};return Ws.runKernel(ro,r,{})}});const ud={flipLeftRight:Eh,grayscaleToRGB:Th,resizeNearestNeighbor:Yh,resizeBilinear:Xh,rgbToGrayscale:Ah,rotateWithOffset:Fh,cropAndResize:Nh,nonMaxSuppression:_h,nonMaxSuppressionAsync:Gh,nonMaxSuppressionWithScore:jh,nonMaxSuppressionWithScoreAsync:Hh,nonMaxSuppressionPadded:Kh,nonMaxSuppressionPaddedAsync:qh,threshold:Zh,transform:ed},hd={bandPart:nd,gramSchmidt:od,qr:id};const dd=class{static sgd(e){return new Cl(e)}static momentum(e,t){return new Nl(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new El(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new yl(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new pl(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new Il(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new gl(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},pd="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function fd(){return new Promise((e=>pd((()=>e()))))}function gd(e,t){const n=e[0].length;e.forEach(((e,t)=>{Ft(e.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),Ft(t>=0&&t<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const a=e[0];e.forEach(((e,r)=>{for(let o=0;o<n;o++)Ft(o===t||e[o]===a[o],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(r,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(a,") ")+"along the non-concatenated axis ".concat(r,".")))}))}function md(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var bd;function yd(e,t,n){let a=new Array;if(null==n&&null==t)return a;if(null==t)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(null==n)return a;if(e+n.length!==a.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(a.length));for(let r=1;r<n.length;++r){const o=n[r],s=a[a.length-n.length+r],i=a[s];if(o>=0)if(i>=0){if(i!==o)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(r+e,"] = ").concat(o," but shape[").concat(r+e,"] = ").concat(i))}else a[s]=o}return a}function vd(e){const t={FIRST_DIM_SIZE:bd.FIRST_DIM_SIZE,VALUE_ROWIDS:bd.VALUE_ROWIDS,ROW_LENGTHS:bd.ROW_LENGTHS,ROW_SPLITS:bd.ROW_SPLITS,ROW_LIMITS:bd.ROW_LIMITS,ROW_STARTS:bd.ROW_STARTS},n=[];for(const a of e){if(!(a in t))break;n.push(t[a])}return n}function xd(e){return 0===e.length?0:e[0]===bd.FIRST_DIM_SIZE?e.length-1:e.length}function wd(e,t){if(null==e||null==t)return;const n=e.length,a=t.length;if(n>=a)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(a,")"));for(let r=0;r<Math.min(n,a-1);++r){const n=e[r],a=t[r+1];if(n>=0&&a>=0&&1!==n&&n!==a)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(r-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(r-e.length,"] = ").concat(a))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(bd||(bd={}));const kd=30;function Sd(e){return e<=kd?e:$t(e,Math.floor(Math.sqrt(e)))}function Id(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function Cd(e,t,n){let a=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function Nd(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let a=t+1;a<e;++a)a<=2*t?(n.push(a),n.push(a-(t+1))):n.push(a)}else{const a=[],r=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?r.push(n):a.push(n);n.push(...a),n.push(0),n.push(...r)}return n}function Ed(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let o=1;o<e.length;++o)o<=t.length?a?r.push(t[o-1]*e[o]):r.push(e[o]/t[o-1]):r.push(e[o]);return r}function Td(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function Rd(e,t,n){const a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}function Ad(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(a<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(a,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[a-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[a-1]," vs. ").concat(n));if(0===Ot(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const r=t.shape,o=r[r.length-1];let s=1;for(let h=0;h<r.length-1;++h)s*=r[h];const i=e.shape,l=r.slice();l.pop();let c=1;for(let h=o;h<n;++h)c*=i[h],l.push(i[h]);const u=[...Qt(e.shape).map((e=>e/c)),1].slice(0,o);return[l,s,c,u]}function Fd(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,o="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(a,", and batchDim: ").concat(r,".");if(n.rank<r)throw new Error(o+" update.rank < ".concat(r,". "));if(e.length<a+(n.rank-r))throw new Error(o+" Output shape length < ".concat(a+(n.rank-r)));if(n.rank!==r+e.length-a)throw new Error(o+" update.rank != ".concat(r+e.length-a));for(let s=0;s<r;++s)if(n.shape[s]!==t.shape[s])throw new Error(o+" updates.shape[".concat(s,"] (").concat(n.shape[s],") != indices.shape[").concat(s,"] (").concat(t.shape[s],")."));for(let s=0;s<n.rank-r;++s)if(n.shape[s+r]!==e[s+a])throw new Error(o+" updates.shape[".concat(s+r,"] (").concat(n.shape[s+r],") != shape[").concat(s+r,"] (").concat(e[s+r],")"))}function Dd(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}Fd(n,t,e)}function _d(e,t,n){const a=t.shape.length,r=a>1?t.shape[a-1]:1,o=n.length;let s=1;for(let l=r;l<o;++l)s*=n[l];const i=r<1?1:r;return{sliceRank:r,numUpdates:Ot(t.shape)/i,sliceSize:s,strides:[...Qt(n.slice(0,r)),1],outputSize:Ot(n)}}const Od=1.7580993408473768,Ld=1.0507009873554805,zd=.3275911,Md=.254829592,Pd=-.284496736,Bd=1.421413741,Wd=-1.453152027,Ud=1.061405429;function Vd(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function Gd(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function jd(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function Hd(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function Kd(e,t){return{real:e[2*t],imag:e[2*t+1]}}function qd(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function Xd(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const o=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(o),a[r]=Math.sin(o)}return{real:n,imag:a}}function Yd(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}const Jd="->",$d=/->/g,Qd=",",Zd="...";function ep(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace($d,"").length)/Jd.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(Jd,'").'));const[a,r]=e.split(Jd);Ft(-1===a.indexOf(Zd),(()=>'The ellipsis notation ("'.concat(Zd,'") is not supported yet.')));const o=a.split(Qd),s=o.length;if(t!==s)throw new Error("Expected ".concat(s," input tensors, received ").concat(t));if(s>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let h=0;h<r.length;++h){const e=r[h];if(!o.some((t=>-1!==t.indexOf(e))))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===i.indexOf(e)&&i.push(e)}for(let h=0;h<a.length;++h){const e=a[h];-1===i.indexOf(e)&&e!==Qd&&i.push(e)}const l=new Array(o.length);for(let h=0;h<s;++h){if(new Set(o[h].split("")).size!==o[h].length)throw new Error("Found duplicate axes in input component ".concat(o[h],". ")+"Support for duplicate axes in input is not implemented yet.");l[h]=[];for(let e=0;e<o[h].length;++e)l[h].push(i.indexOf(o[h][e]))}const c=i.length,u=[];for(let h=r.length;h<c;++h)u.push(h);return{allDims:i,summedDims:u,idDims:l}}function tp(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const a=[];for(let r=0;r<e;++r)-1===n[r]&&a.push(r);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:a}}function np(e,t,n){const a=new Array(e);for(let r=0;r<n.length;++r){const e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===a[t[r][n]]?a[t[r][n]]=e[n]:Ft(a[t[r][n]]===e[n],(()=>"Expected dimension ".concat(a[t[r][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n])))}}function ap(e,t){const n=e,a=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let s=0;s<r;++s)a.push([]);const o=[];for(let s=0;s<n.length;++s){const e=op(t,n[s]);for(const t of e)-1===o.indexOf(t)&&(a[s].push(t),o.push(t))}return{path:n,steps:a}}function rp(e){return e.every(((e,t)=>e===t))}function op(e,t){const n=[];for(let a=0;a<e.length;++a)0!==e[a].length&&-1===e[a].indexOf(t)&&-1!==t||n.push(a);return n}function sp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=[];if("number"===typeof t)Ft(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),a=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Ft(r<=1,(()=>"There should be only one negative value in split array."));const o=t.indexOf(-1);if(-1!==o){const a=t.reduce(((e,t)=>t>0?e+t:e));t[o]=e.shape[n]-a}Ft(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),a=t}return a}function ip(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function lp(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function cp(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function up(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function hp(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function dp(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function pp(e,t){const n=Ot(e),a=Ot(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(a,". inputShape=").concat(e," outputShape= ").concat(t)}function fp(e,t){const n=Ot(e),a=Ot(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(a,". inputShape=").concat(e," outputShape=").concat(t)}function gp(){return"segment ids must be >= 0"}function mp(){return"segment ids are not increasing"}function bp(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function yp(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function vp(e,t){let n,a=!1;for(e<=kd?(n=e,a=!0):n=$t(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=$t(e,n+1);return n}function xp(e,t,n){const a=[],r=e.length;for(let o=0;o<r;o++)o!==t?a.push(e[o]):a.push(n);return a}function wp(e,t,n,a){const r=t.shape.length,o=e.shape.length;if(0!==a&&(a<-r||a>r))throw new Error("Expect batchDims in the range of [-".concat(r,", ").concat(r,"], but got ").concat(a));if(a<0&&(a+=r),a>o)throw new Error("batchDims (".concat(a,") must be less than rank(x) (\n    ").concat(o,")."));if(n<a)throw new Error("batchDims (".concat(a,") must be less than or equal to axis (").concat(n,")."));for(let h=0;h<a;++h)if(e.shape[h]!==t.shape[h])throw new Error("x.shape[".concat(h,"]: ").concat(e.shape[h]," should be equal to indices.shape[").concat(h,"]: ").concat(t.shape[h],"."));const s=e.shape[n],i=[];let l=1,c=1,u=1;for(let h=0;h<a;++h)i.push(e.shape[h]),l*=e.shape[h];for(let h=a;h<n;h++)i.push(e.shape[h]),c*=e.shape[h];for(let h=a;h<r;h++)i.push(t.shape[h]);for(let h=n+1;h<o;h++)i.push(e.shape[h]),u*=e.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:s,outputShape:i}}function kp(e){try{return e.map((e=>rs(e)))}catch(CW){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(CW))}}function Sp(e){return e.map((e=>as(e)))}function Ip(e,t){const n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);const a=Yi(e,"int32"),r=Yi([n.length,e.length],"int32");for(let o=0;o<n.length;o++){const t=a.indexToLoc(n[o]),s=o*e.length;r.values.set(t,s)}return r.toTensor()}!function(){for(const e of Tl)hl(e)}();const Cp={kernelName:bn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tl(e,bh(Ji(n,"float32"),-1))}}},Np={kernelName:yn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=al(Ji(n,"float32")),a=nl(bl(sl(1),t));return Nu(el(e,a))}}}},Ep={kernelName:vn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=nl(bl(al(Ji(n,"float32")),1));return el(e,t)}}}},Tp={kernelName:xn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=kl(n.shape,a.shape);return{a:()=>{let t=e;const a=wl(n.shape,r);return a.length>0&&(t=iu(t,a)),Sc(t,n.shape)},b:()=>{let t=e;const n=wl(a.shape,r);return n.length>0&&(t=iu(t,n)),Sc(t,a.shape)}}}},Rp={kernelName:wn,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,a)=>{n[a]=()=>e.clone()})),n}},Ap={kernelName:In,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>rl(n)}}},Fp={kernelName:Cn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>rl(n)}}},Dp={kernelName:Nn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>el(e,nl(bl(sl(1),al(Ji(n,"float32")))))}}},_p={kernelName:En,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=nl(Qi(sl(1),al(Ji(n,"float32"))));return el(e,t)}}}},Op={kernelName:An,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=kl(n.shape,a.shape);return{a:()=>{const t=Qi(al(n),al(a));let o=tl(e,el(a,t));const s=wl(n.shape,r);return s.length>0&&(o=iu(o,s)),Sc(o,n.shape)},b:()=>{const t=Qi(al(n),al(a));let o=Nu(tl(e,el(n,t)));const s=wl(a.shape,r);return s.length>0&&(o=iu(o,s)),Sc(o,a.shape)}}}},Lp={kernelName:Tn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>el(e,Qi(al(Ji(n,"float32")),1))}}},zp={kernelName:Rn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>el(e,bl(sl(1),al(Ji(n,"float32"))))}}};const Mp=$s({avgPool3dGrad_:function(e,t,n,a,r,o){const s=Ys(e,"dy","avgPool3dGrad"),i=Ys(t,"input","avgPool3dGrad");let l=s,c=i,u=!1;4===i.rank&&(u=!0,l=Sc(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),c=Sc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Ft(5===l.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(l.rank,"."))),Ft(5===c.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(c.rank,"."))),kc("avgPool3dGrad",r,o);const h={dy:l,input:c},d={filterSize:n,strides:a,pad:r,dimRoundingMode:o},p=Ws.runKernel(On,h,d);return u?Sc(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),Pp={kernelName:_n,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:o,pad:s,dimRoundingMode:i}=n;return{x:()=>Mp(e,a,r,o,s,i)}}};const Bp=$s({avgPoolGrad_:function(e,t,n,a,r){const o=Ys(e,"dy","avgPoolGrad"),s=Ys(t,"input","avgPoolGrad");Ft(s.rank===o.rank,(()=>"Rank of input (".concat(s.rank,") does not match rank of dy (").concat(o.rank,")")));let i=s,l=o,c=!1;3===s.rank&&(c=!0,i=Sc(s,[1,s.shape[0],s.shape[1],s.shape[2]]),l=Sc(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Ft(4===l.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(l.rank,"."))),Ft(4===i.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(i.rank,".")));const u={dy:l,input:i},h={filterSize:n,strides:a,pad:r},d=Ws.runKernel(Dn,u,h);return c?Sc(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Wp={kernelName:Fn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:o,pad:s}=n;return{x:()=>Bp(e,a,r,o,s)}}},Up={kernelName:Ln,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[a,r]=t,{transposeA:o,transposeB:s}=n;return o||s?!o&&s?{a:()=>vu(e,r,!1,!1),b:()=>vu(e,a,!0,!1)}:o&&!s?{a:()=>vu(r,e,!1,!0),b:()=>vu(a,e,!1,!1)}:{a:()=>vu(r,e,!0,!0),b:()=>vu(e,a,!0,!0)}:{a:()=>vu(e,r,!1,!0),b:()=>vu(a,e,!0,!1)}}};const Vp=$s({spaceToBatchND_:function(e,t,n){const a=Ys(e,"x","spaceToBatchND");Ft(a.rank>=1+t.length,(()=>"input rank ".concat(a.rank," should be > than [blockShape] ").concat(t.length))),Ft(n.length===t.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length))),Ft(a.shape.reduce(((e,a,r)=>r>0&&r<=t.length?e&&(a+n[r-1][0]+n[r-1][1])%t[r-1]===0:e),!0),(()=>"input spatial dimensions ".concat(a.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString())));const r={x:a},o={blockShape:t,paddings:n};return Ws.runKernel(Jr,r,o)}}),Gp={kernelName:zn,gradFunc:(e,t,n)=>{const{blockShape:a,crops:r}=n;return{x:()=>Vp(e,a,r)}}},jp={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const a=n,r=a.inputShape,o=a.shape,s=Array.from(o);for(let l=r.length-1;l>=0;l--)if(r[l]===o[l])s[l]=1;else if(1!==r[l])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(o,"]."));const i=[];for(let l=0;l<s.length;l++)s[l]>1&&i.push(l);return{x:()=>iu(e,i,!0)}}},Hp={kernelName:Wn,gradFunc:e=>({x:()=>e.clone()})},Kp={kernelName:Un,gradFunc:e=>({x:()=>rl(e)})},qp={kernelName:Vn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{clipValueMin:r,clipValueMax:o}=n;return{x:()=>sh(yu(nu(a,r),$h(a,o)),e,rl(e))}}},Xp={kernelName:jn,inputsToSave:["x"],gradFunc:Cp.gradFunc},Yp={kernelName:Hn,saveAllInputs:!0,gradFunc:(e,t,n)=>{const a=t.map((e=>e.shape)),{axis:r}=n,o=Ut(r,t[0].shape)[0],s=a.map((e=>e[o]));return Qu(e,s,o).map((e=>()=>e))}},Jp={kernelName:Kn,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{dilations:o,strides:s,pad:i,dataFormat:l}=n;return Ft(yc(o),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'"))),{x:()=>Bc(a.shape,e,r,s,i,l),filter:()=>gh(a,e,r.shape,s,i,l)}}},$p={kernelName:Xn,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{strides:o,pad:s,dataFormat:i,dimRoundingMode:l}=n;return{dy:()=>Mc(e,r,o,s,i,1,l),filter:()=>gh(e,a,r.shape,o,s,i,l)}}};const Qp=$s({conv3DBackpropFilter_:function(e,t,n,a,r){let o=e;4===e.rank&&(o=Sc(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let s=t;4===s.rank&&(s=Sc(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Ft(5===o.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(o.shape,"."))),Ft(5===s.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(s.shape,"."))),Ft(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),Ft(o.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(o.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),Ft(s.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(s.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const i={x:o,dy:s},l={strides:a,pad:r,filterShape:n};return Ws.runKernel(Jn,i,l)}}),Zp={kernelName:Yn,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:o}=n;Ft(yc(a),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(a,"'")));const[s,i]=t;return{x:()=>Vc(s.shape,e,i,r,o),filter:()=>Qp(s,e,i.shape,r,o)}}};const ef=$s({sin_:function(e){const t={x:Ys(e,"x","sin","float32")};return Ws.runKernel(Gr,t)}}),tf={kernelName:Qn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tl(Nu(ef(Ji(n,"float32"))),e)}}};const nf=$s({sinh_:function(e){const t={x:Ys(e,"x","sinh")};return Ws.runKernel(jr,t)}}),af={kernelName:Zn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tl(nf(Ji(n,"float32")),e)}}};const rf=$s({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:Ys(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:a};return Ws.runKernel(ta,r,o)}}),of={kernelName:ta,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r,exclusive:o,reverse:s}=n;return{x:()=>{const t=fu([r],a.rank);let n=rf(e,r,o,!s);return null!=t&&(n=ch(n,t)),n}}}},sf={kernelName:oa,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:o,dimRoundingMode:s}=n,i=null==a?[1,1]:a;Ft(yc(i),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'")));const[l,c]=t;return Ft(4===l.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(l.rank,"."))),Ft(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(c.rank,"."))),Ft(l.shape[3]===c.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(l.shape[3],") must match the inChannels dimension ")+"in filter ".concat(c.shape[2],"."))),Ft(vc(r,i),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(r," and dilations ")+"'".concat(i,"'."))),kc("depthwiseConv2d",o,s),{x:()=>Ih(l.shape,e,c,r,o,i,s),filter:()=>Sh(l,e,c.shape,r,o,i,s)}}},lf={kernelName:ca,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,o={x:a,filter:r,dy:e},s={x:a,filter:r,dy:e};return{x:()=>Ws.runKernel(ua,o,n),filter:()=>Ws.runKernel(ha,s,n)}}},cf={kernelName:ga,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,a={dy:e,y:n};return{x:()=>Ws.runKernel(ma,a)}}},uf={kernelName:ba,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=tl(Yc(Nu(al(n))),2/Math.sqrt(Math.PI));return{x:()=>tl(e,a)}}},hf={kernelName:va,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tl(e,n)}}},df={kernelName:xa,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Sc(e,n.shape)}}},pf={kernelName:wa,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tl(e,Yc(n))}}},ff={kernelName:Ca,gradFunc:e=>({x:()=>rl(e)})},gf={kernelName:Na,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=kl(n.shape,a.shape);return{a:()=>{const t=el(e,Ji(a,"float32")),o=wl(n.shape,r);return o.length>0?Sc(iu(t,o),n.shape):t},b:()=>{let t=tl(e,Ji(n,"float32"));const o=wl(a.shape,r);o.length>0&&(t=Sc(iu(t,o),a.shape));const s=al(a);return Nu(el(t,Ji(s,"float32")))}}}};const mf=$s({rsqrt_:function(e){const t={x:Ys(e,"x","rsqrt","float32")};return Ws.runKernel(zr,t)}}),bf={kernelName:Ea,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:a}=n,[r,o,s,i]=t,l=null==i?sl(1):i,c=wl(o.shape,r.shape),u=[];if(1===o.rank){for(let e=0;e<r.shape.length-1;++e)u.push(r.shape[e]);u.push(1)}const h=bl(r,o),d=tl(e,l),p=mf(Qi(s,sl(a))),f=tl(tl(tl(p,p),p),sl(-.5));return{x:()=>1===o.rank?Sc(tl(tl(e,$c(Sc(p,[1,1,1,o.shape[0]]),u)),l),r.shape):Sc(tl(tl(e,p),l),r.shape),mean:()=>{let e=tl(tl(p,sl(-1)),d);return 1===o.rank&&(e=iu(e,c)),Sc(e,o.shape)},variance:()=>{let e=tl(tl(f,h),d);return 1===o.rank&&(e=iu(e,c)),Sc(e,o.shape)},scale:()=>{const t=tl(h,p);let n=tl(e,t);return 1===o.rank&&(n=iu(n,c)),Sc(n,o.shape)},offset:()=>{let t=e;return 1===o.rank&&(t=iu(t,c)),Sc(t,o.shape)}}}};const yf=$s({unsortedSegmentSum_:function(e,t,n){const a=Ys(e,"x","unsortedSegmentSum"),r=Ys(t,"segmentIds","unsortedSegmentSum","int32");Ft(zt(n),(()=>"numSegments must be of dtype int"));const o={x:a,segmentIds:r},s={numSegments:n};return Ws.runKernel(wo,o,s)}}),vf={kernelName:Ta,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[a,r]=t,{axis:o,batchDims:s}=n,i=Ut(o,a.shape)[0],l=(e,t,n)=>()=>{const a=e.shape,r=t.size,s=a.slice(0,i),l=s.length,c=a.slice(o,a.length).slice(1),u=c.length,h=xf(0,l),d=xf(l+1,l+1+u),p=wf([s,[r],c]),f=Sc(n,p),g=Sc(t,[r]),m=wf([[l],h,d]),b=ch(f,m);let y=yf(b,g,e.shape[i]);const v=gu(m);return y=ch(y,v),y};if(1===s){const t=a.shape[0],n=a.split(t,0),o=()=>{const t=eh(n.map(((t,n)=>l(t,r.slice(n,1),e.slice(n,1))())));return t.reshape(a.shape)};return{x:o,indices:()=>r}}return{x:l(a,r,e),indices:()=>r}}};function xf(e,t){const n=[];for(let a=e;a<t;++a)n.push(a);return n}function wf(e){const t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}const kf={kernelName:Fa,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>rl(n),b:()=>rl(a)}}},Sf={kernelName:Da,gradFunc:e=>({x:()=>Ji(e,"float32")})},If={kernelName:La,gradFunc:e=>({x:()=>rl(e)})},Cf={kernelName:za,gradFunc:e=>({x:()=>rl(e)})},Nf={kernelName:Ma,gradFunc:e=>({x:()=>rl(e)})},Ef={kernelName:Pa,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{alpha:r}=n,o=tu(a,0);return{x:()=>sh(o,e,tl(e,r))}}},Tf={kernelName:Ga,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>el(e,Qi(n,1))}}},Rf={kernelName:Va,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>el(e,Ji(n,"float32"))}}},Af={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;return{logits:()=>{const t=Yc(a);return bl(e,tl(iu(e,r,!0),t))}}}};const Ff=$s({localResponseNormalizationBackprop_:function(e,t,n){const a={x:e,y:t,dy:n},r={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Ws.runKernel(Xa,a,r)}}),Df={kernelName:qa,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{depthRadius:o,bias:s,alpha:i,beta:l}=n;return{x:()=>Ff(a,r,e,o,s,i,l)}}};function _f(e,t,n,a){return t.rank<n.rank&&(t=Sc(t,du(t.shape,a))),e.rank<n.rank&&(e=Sc(e,du(e.shape,a))),{x:()=>tl(e,Ji(qc(n,t),e.dtype))}}const Of={kernelName:Ya,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{reductionIndices:r}=a,o=t[0],s=_f(e,t[1],o,Ut(r,o.shape));return{x:()=>s.x()}}},Lf={kernelName:Ja,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>tl(e,Ji(nu(n,a),"float32")),b:()=>tl(e,Ji(td(n,a),"float32"))}}};const zf=$s({maxPool3dGrad_:function(e,t,n,a,r,o,s){const i=Ys(e,"dy","maxPool3dGrad"),l=Ys(t,"input","maxPool3dGrad"),c=Ys(n,"output","maxPool3dGrad");let u=i,h=l,d=c,p=!1;4===l.rank&&(p=!0,u=Sc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=Sc(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=Sc(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),Ft(5===u.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),Ft(5===h.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,"."))),Ft(5===d.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(d.rank,"."))),kc("maxPool3dGrad",o,s);const f={dy:u,input:h,output:d},g={filterSize:a,strides:r,pad:o,dimRoundingMode:s},m=Ws.runKernel(er,f,g);return p?Sc(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),Mf={kernelName:Za,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:l}=n;return{x:()=>zf(e,a,r,o,s,i,l)}}};const Pf=$s({maxPoolGrad_:function(e,t,n,a,r,o,s){const i=Ys(e,"dy","maxPoolGrad"),l=Ys(t,"input","maxPoolGrad"),c=Ys(n,"output","maxPoolGrad");Ft(l.rank===i.rank,(()=>"Rank of input (".concat(l.rank,") does not match rank of dy ")+"(".concat(i.rank,")"))),Ft(4===i.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(i.rank,"."))),Ft(4===l.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(l.rank,"."))),kc("maxPoolGrad",o,s);const u={dy:i,input:l,output:c},h={filterSize:a,strides:r,pad:o,dimRoundingMode:s};return Ws.runKernel(Qa,u,h)}}),Bf={kernelName:$a,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:o,strides:s,pad:i}=n;return{x:()=>Pf(e,a,r,o,s,i)}}},Wf={kernelName:nr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n,o=Ut(r,a.shape),s=Ot(hu(a.shape,o)[1]);return{x:()=>{const t=a.shape.slice();o.forEach((e=>{t[e]=1}));const n=Sc(e,t);return el(tl(n,Au(a.shape,"float32")),s)}}}},Uf={kernelName:ar,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{axis:r}=a,[o,s]=t,i=_f(e,s,o,Ut(r,o.shape));return{x:()=>i.x()}}},Vf={kernelName:rr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>tl(e,Ji($h(n,a),"float32")),b:()=>tl(e,Ji(tu(n,a),"float32"))}}},Gf={kernelName:or,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,o=r.map((e=>e[0]));return{x:()=>Hu(e,o,a.shape)}}},jf={kernelName:sr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=kl(n.shape,a.shape);return{a:()=>{const t=wl(n.shape,r);return t.length>0?Sc(iu(e,t),n.shape):e},b:()=>{const t=tl(e,Nu(Zc(el(n,a)))),o=wl(a.shape,r);return o.length>0?Sc(iu(t,o),a.shape):t}}}},Hf={kernelName:lr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=kl(n.shape,a.shape);return{a:()=>{const t=tl(e,Ji(a,"float32")),o=wl(n.shape,r);return o.length>0?Sc(iu(t,o),n.shape):t},b:()=>{const t=tl(e,Ji(n,"float32")),o=wl(a.shape,r);return o.length>0?Sc(iu(t,o),a.shape):t}}}},Kf={kernelName:cr,gradFunc:e=>({x:()=>Nu(e)})},qf={kernelName:gr,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>Ru(n.shape,"float32")}}},Xf={kernelName:fr,gradFunc:e=>({x:()=>rl(e)})},Yf={kernelName:mr,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:a}=n;return oh(e,a).map((e=>()=>e))}},Jf={kernelName:br,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,o=r.map((e=>e[0]));return{x:()=>Hu(e,o,a.shape)}}},$f={kernelName:yr,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,a,r]=t,o=n,s=a,i=kl(o.shape,s.shape);return{a:()=>{const t=Ji(s,"float32");let n=tl(e,tl(t,ml(o,bl(t,sl(1)))));const a=wl(o.shape,i);return a.length>0&&(n=iu(n,a)),Sc(n,o.shape)},b:()=>{const t=tu(o,0),n=sh(t,ru(o),rl(o));let a=tl(e,tl(r,n));const l=wl(s.shape,i);return l.length>0&&(a=iu(a,l)),Sc(a,s.shape)}}}},Qf={kernelName:vr,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,a]=t,r=tu(n,0);return{x:()=>sh(r,e,tl(e,a)),alpha:()=>{let t=sh(r,rl(e),tl(e,n));const o=wl(a.shape,e.shape);return o.length>0&&(t=iu(t,o)),Sc(t,a.shape)}}}};const Zf=$s({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:Ys(e,"x","cumprod")},o={axis:t,exclusive:n,reverse:a};return Ws.runKernel(ea,r,o)}});function eg(e,t,n){const a=e.shape.length,r=a-n.length,o=fu(n,a);let s=e;null!=o&&(s=ch(e,o));const i=s.shape.slice(),l=i.splice(a-n.length,n.length).reduce(((e,t)=>e*t),1);i.push(l);let c=function(e,t,n){const a=e.shape.slice();a[n]=1;const r=Sc(t,a),o=Zf(e,n,!0,!1),s=Zf(e,n,!0,!0),i=tl(o,s);return tl(r,i)}(s.reshape(i),t,r);if(c=c.reshape(s.shape),null!=o){const e=gu(o);c=ch(c,e)}return c}const tg={kernelName:xr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;let o=[];return o=void 0===r||null===r?a.shape.map(((e,t)=>t)):"number"===typeof r?[r]:r,{x:()=>eg(a,e,o)}}},ng={kernelName:pa,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=kl(n.shape,a.shape);return{a:()=>{const t=el(e,Ji(a,"float32")),o=wl(n.shape,r);return o.length>0?Sc(iu(t,o),n.shape):t},b:()=>{let t=tl(e,Ji(n,"float32"));const o=wl(a.shape,r);o.length>0&&(t=Sc(iu(t,o),a.shape));const s=al(a);return Nu(el(t,Ji(s,"float32")))}}}},ag={kernelName:Nr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>el(e,Nu(al(n)))}}},rg={kernelName:_r,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=tl($h(n,6),bh(n));return{x:()=>tl(e,Ji(a,"float32"))}}},og={kernelName:Er,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tl(e,Ji(bh(n),"float32"))}}},sg={kernelName:Tr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Sc(e,n.shape)}}},ig={kernelName:Fr,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>Ws.runKernel(Dr,r,n)}}},lg={kernelName:Rr,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>Ws.runKernel(Ar,r,n)}}},cg={kernelName:Or,gradFunc:(e,t,n)=>{const{dims:a}=n,r=Ut(a,e.shape);return{x:()=>Uu(e,r)}}},ug={kernelName:Lr,gradFunc:e=>({x:()=>rl(e)})},hg={kernelName:zr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Nu(el(e,tl(ml(n,1.5),2)))}}};const dg=$s({logicalNot_:function(e){const t={x:Ys(e,"x","logicalNot","bool")};return Ws.runKernel(Ha,t)}}),pg={kernelName:Wr,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Ji(rl(n),"float32"),t:()=>tl(e,Ji(n,e.dtype)),e:()=>tl(e,Ji(dg(n),e.dtype))}}},fg={kernelName:Ur,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=tu(n,sl(0)),a=sl(Od),r=sl(Ld),o=tl(e,r),s=tl(tl(e,a),Yc(Ji(n,"float32")));return sh(t,o,s)}}}},gg={kernelName:Kr,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tl(e,tl(n,bl(sl(1),n)))}}},mg={kernelName:Hr,gradFunc:e=>({x:()=>rl(e)})};const bg=$s({cos_:function(e){const t={x:Ys(e,"x","cos","float32")};return Ws.runKernel(Qn,t)}}),yg={kernelName:Gr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tl(bg(Ji(n,"float32")),e)}}};const vg=$s({cosh_:function(e){const t={x:Ys(e,"x","cosh","float32")};return Ws.runKernel(Zn,t)}}),xg={kernelName:jr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tl(vg(Ji(n,"float32")),e)}}},wg={kernelName:Vr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{begin:r,size:o}=n,s=a.shape,[i,l]=nc(a,r,o),c=[];for(let u=0;u<e.rank;u++)c.push([i[u],s[u]-i[u]-l[u]]);return{x:()=>Du(e,c)}}},kg={kernelName:Qr,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{dim:r}=n,o=tl(e,a);return{logits:()=>bl(o,tl(iu(o,[r],true),a))}}},Sg={kernelName:qr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tl(e,ju(n))}}};const Ig=$s({batchToSpaceND_:function(e,t,n){const a=Ys(e,"x","batchToSpaceND"),r=t.reduce(((e,t)=>e*t));Ft(a.rank>=1+t.length,(()=>"input rank is ".concat(a.rank," but should be > than blockShape.length ").concat(t.length))),Ft(n.length===t.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length))),Ft(a.shape[0]%r===0,(()=>"input tensor batch is ".concat(a.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(r)));const o={x:a},s={blockShape:t,crops:n};return Ws.runKernel(zn,o,s)}}),Cg={kernelName:Jr,gradFunc:(e,t,n)=>{const{blockShape:a,paddings:r}=n;return{x:()=>Ig(e,a,r)}}},Ng={kernelName:$r,gradFunc:(e,t,n)=>{const{axis:a}=n;return{x:()=>Dc(e,a)}}},Eg={kernelName:ro,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=sl(2);return{a:()=>tl(e,tl(r,bl(n,a))),b:()=>tl(e,tl(r,bl(a,n)))}}},Tg={kernelName:ho,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=kl(n.shape,a.shape);return{a:()=>{let t=e;const a=wl(n.shape,r);return a.length>0&&(t=iu(t,a)),Sc(t,n.shape)},b:()=>{let t=e;const n=wl(a.shape,r);return n.length>0&&(t=iu(t,n)),Sc(Nu(t),a.shape)}}}},Rg={kernelName:go,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{reps:r}=n;return{x:()=>{let t=rl(a);if(1===a.rank)for(let n=0;n<r[0];++n)t=Qi(t,Hu(e,[n*a.shape[0]],[a.shape[0]]));else if(2===a.rank)for(let n=0;n<r[0];++n)for(let o=0;o<r[1];++o)t=Qi(t,Hu(e,[n*a.shape[0],o*a.shape[1]],[a.shape[0],a.shape[1]]));else if(3===a.rank)for(let n=0;n<r[0];++n)for(let o=0;o<r[1];++o)for(let s=0;s<r[2];++s)t=Qi(t,Hu(e,[n*a.shape[0],o*a.shape[1],s*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else{if(4!==a.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(a.rank," tensors yet."));for(let n=0;n<r[0];++n)for(let o=0;o<r[1];++o)for(let s=0;s<r[2];++s)for(let i=0;i<r[3];++i)t=Qi(t,Hu(e,[n*a.shape[0],o*a.shape[1],s*a.shape[2],i*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]))}return t}}}},Ag={kernelName:wo,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Sl(t,rl(t)),a=eu(e,n);let r=nu(t,sl(0,"int32"));const o=a.rank-r.rank;for(let i=0;i<o;++i)r=Jc(r,i+1);r=yu(r,Au(a.shape,"bool"));const s=rl(a);return sh(r,a,s)}(e,n)}}};const Fg=[Cp,Np,Ep,Tp,Rp,Ap,Fp,Dp,_p,Op,Lp,zp,Pp,Wp,Up,Gp,jp,Hp,Kp,qp,Xp,Yp,$p,Jp,Zp,tf,af,of,sf,lf,ng,cf,uf,hf,df,pf,gf,ff,bf,vf,kf,Sf,If,Cf,Nf,Ef,Tf,Rf,Af,Df,Of,Of,Lf,Mf,Bf,Wf,Uf,Vf,Gf,jf,Hf,Kf,qf,Xf,Yf,Jf,Jf,$f,Qf,tg,ag,rg,og,sg,ig,lg,cg,ug,hg,pg,fg,gg,mg,yg,xg,wg,kg,Sg,Cg,Cg,Ng,Ng,{kernelName:Xr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>el(e,tl(nl(Ji(n,"float32")),2))}}},Eg,{kernelName:oo,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tl(e,tl(Ji(n,"float32"),2))}}},{kernelName:So,gradFunc:e=>({x:()=>rl(e)})},Tg,{kernelName:Yr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,r=a.shape.slice(),{axis:o}=n;Ut(o,a.shape).forEach((e=>{r[e]=1}));const s=Sc(e,r),i=tl(s,Au(a.shape,"float32"));return{x:()=>i}}},{kernelName:po,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>el(e,al(bg(n)))}}},{kernelName:fo,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tl(bl(sl(1),al(n)),e)}}},Rg,{kernelName:yo,gradFunc:(e,t,n)=>{const a=n,{perm:r}=a,o=gu(r);return{x:()=>ch(e,o)}}},{kernelName:xo,gradFunc:(e,t,n)=>{const a=n,{axis:r}=a;return{value:()=>eh(e,r)}}},Ag,{kernelName:ko,gradFunc:e=>({x:()=>rl(e)})}];for(const n of Fg)Mo(n);xs().prototype.abs=function(){return this.throwIfDisposed(),vl(this)};const Dg=$s({acos_:function(e){const t={x:Ys(e,"x","acos")};return Ws.runKernel(yn,t)}});xs().prototype.acos=function(){return this.throwIfDisposed(),Dg(this)};const _g=$s({acosh_:function(e){const t={x:Ys(e,"x","acosh")};return Ws.runKernel(vn,t)}});xs().prototype.acosh=function(){return this.throwIfDisposed(),_g(this)},xs().prototype.add=function(e){return this.throwIfDisposed(),Qi(this,e)},xs().prototype.all=function(e,t){return this.throwIfDisposed(),oc(this,e,t)},xs().prototype.any=function(e,t){return this.throwIfDisposed(),sc(this,e,t)},xs().prototype.argMax=function(e){return this.throwIfDisposed(),ic(this,e)};const Og=$s({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Ys(e,"x","argMin")},a={axis:t};return Ws.runKernel(Cn,n,a)}});xs().prototype.argMin=function(e){return this.throwIfDisposed(),Og(this,e)},xs().prototype.asScalar=function(){return this.throwIfDisposed(),Ft(1===this.size,(()=>"The array must have only 1 element.")),Sc(this,[])},xs().prototype.asType=function(e){return this.throwIfDisposed(),Ji(this,e)},xs().prototype.as1D=function(){return this.throwIfDisposed(),Sc(this,[this.size])},xs().prototype.as2D=function(e,t){return this.throwIfDisposed(),Sc(this,[e,t])},xs().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Sc(this,[e,t,n])},xs().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),Sc(this,[e,t,n,a])},xs().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),Sc(this,[e,t,n,a,r])};const Lg=$s({asin_:function(e){const t={x:Ys(e,"x","asin")};return Ws.runKernel(Nn,t)}});xs().prototype.asin=function(){return this.throwIfDisposed(),Lg(this)};const zg=$s({asinh_:function(e){const t={x:Ys(e,"x","asinh")};return Ws.runKernel(En,t)}});xs().prototype.asinh=function(){return this.throwIfDisposed(),zg(this)};const Mg=$s({atan_:function(e){const t={x:Ys(e,"x","atan")};return Ws.runKernel(Tn,t)}});xs().prototype.atan=function(){return this.throwIfDisposed(),Mg(this)};const Pg=$s({atan2_:function(e,t){let n=Ys(e,"a","atan2"),a=Ys(t,"b","atan2");[n,a]=Ds(n,a);const r={a:n,b:a};return Ws.runKernel(An,r)}});xs().prototype.atan2=function(e){return this.throwIfDisposed(),Pg(this,e)};const Bg=$s({atanh_:function(e){const t={x:Ys(e,"x","atanh")};return Ws.runKernel(Rn,t)}});xs().prototype.atanh=function(){return this.throwIfDisposed(),Bg(this)},xs().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),Ic(this,e,t,n,a)},xs().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Ig(this,e,t)},xs().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),Nc(this,e,t,n,a,r)},xs().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Ac(this,e)},xs().prototype.cast=function(e){return this.throwIfDisposed(),Ji(this,e)};const Wg=$s({ceil_:function(e){const t={x:Ys(e,"x","ceil","float32")};return Ws.runKernel(Un,t)}});xs().prototype.ceil=function(){return this.throwIfDisposed(),Wg(this)},xs().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Fc(this,e,t)},xs().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof vs&&(e=[e]),Dc([this,...e],t)},xs().prototype.conv1d=function(e,t,n,a,r,o){return this.throwIfDisposed(),Pc(this,e,t,n,a,r,o)},xs().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),Wc(this,e,t,n,a,r)},xs().prototype.conv2d=function(e,t,n,a,r,o){return this.throwIfDisposed(),Mc(this,e,t,n,a,r,o)},xs().prototype.cos=function(){return this.throwIfDisposed(),bg(this)},xs().prototype.cosh=function(){return this.throwIfDisposed(),vg(this)},xs().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Zf(this,e,t,n)},xs().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),rf(this,e,t,n)};const Ug=$s({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const a=Ys(e,"x","depthToSpace","float32"),r="NHWC"===n?a.shape[1]:a.shape[2],o="NHWC"===n?a.shape[2]:a.shape[3],s="NHWC"===n?a.shape[3]:a.shape[1];Ft(t>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t))),Ft(r*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(r," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(a.shape))),Ft(o*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(o," and ").concat(t," for depthToSpace with input shape\n        ").concat(a.shape))),Ft(s%(t*t)===0,(()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(s," for depthToSpace with input shape ").concat(a.shape)));const i={x:a},l={blockSize:t,dataFormat:n};return Ws.runKernel(ra,i,l)}});xs().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Ug(this,e,t)},xs().prototype.depthwiseConv2d=function(e,t,n,a,r,o){return this.throwIfDisposed(),Hc(this,e,t,n,a,r,o)};const Vg=$s({dilation2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const s=Ys(e,"x","dilation2d"),i=Ys(t,"filter","dilation2d");Ft(3===s.rank||4===s.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(s.rank,"."))),Ft(3===i.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(i.rank,"."))),Ft("NHWC"===o,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(o)));let l=s,c=!1;3===s.rank&&(l=Sc(s,[1,s.shape[0],s.shape[1],s.shape[2]]),c=!0),Ft(l.shape[3]===i.shape[2],(()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(l.shape[3]," vs ").concat(i.shape[2])));const u={x:l,filter:i},h={strides:n,pad:a,dilations:r},d=Ws.runKernel(ca,u,h);return c?Sc(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});xs().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),Vg(this,e,t,n,a,r)};const Gg=$s({divNoNan_:function(e,t){let n=Ys(e,"a","div"),a=Ys(t,"b","div");[n,a]=Ds(n,a);const r=el(n,a),o=rl(r),s=qc(a,o);return sh(s,o,r)}});xs().prototype.divNoNan=function(e){return this.throwIfDisposed(),Gg(this,e)},xs().prototype.div=function(e){return this.throwIfDisposed(),el(this,e)};const jg=$s({dot_:function(e,t){const n=Ys(e,"t1","dot"),a=Ys(t,"t2","dot");Ft((1===n.rank||2===n.rank)&&(1===a.rank||2===a.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(a.rank,".")));const r=1===n.rank?n.size:n.shape[1],o=1===a.rank?a.size:a.shape[0];if(Ft(r===o,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(r," and ").concat(o,"."))),1===n.rank&&1===a.rank){const e=Sc(n,[1,-1]),t=Sc(a,[-1,1]),r=vu(e,t);return Sc(r,[])}if(1===n.rank&&2===a.rank){const e=Sc(n,[1,-1]),t=Sc(a,[a.shape[0],a.shape[1]]),r=vu(e,t);return Sc(r,[r.size])}if(2===n.rank&&1===a.rank){const e=Sc(a,[-1,1]),t=vu(n,e);return Sc(t,[t.size])}{const e=Sc(a,[a.shape[0],a.shape[1]]);return vu(n,e)}}});xs().prototype.dot=function(e){return this.throwIfDisposed(),jg(this,e)},xs().prototype.elu=function(){return this.throwIfDisposed(),Kc(this)},xs().prototype.equal=function(e){return this.throwIfDisposed(),qc(this,e)},xs().prototype.erf=function(){return this.throwIfDisposed(),Xc(this)};const Hg=$s({euclideanNorm_:function(e){return rd(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});xs().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Hg(this,e,t)},xs().prototype.exp=function(){return this.throwIfDisposed(),Yc(this)},xs().prototype.expandDims=function(e){return this.throwIfDisposed(),Jc(this,e)};const Kg=$s({expm1_:function(e){const t={x:Ys(e,"x","expm1")};return Ws.runKernel(wa,t)}});xs().prototype.expm1=function(){return this.throwIfDisposed(),Kg(this)},xs().prototype.fft=function(){return this.throwIfDisposed(),hh(this)},xs().prototype.flatten=function(){return this.throwIfDisposed(),Sc(this,[this.size])},xs().prototype.floor=function(){return this.throwIfDisposed(),Zc(this)},xs().prototype.floorDiv=function(e){return this.throwIfDisposed(),Zi(this,e)},xs().prototype.gather=function(e,t,n){return this.throwIfDisposed(),eu(this,e,t,n)},xs().prototype.greaterEqual=function(e){return this.throwIfDisposed(),nu(this,e)},xs().prototype.greater=function(e){return this.throwIfDisposed(),tu(this,e)},xs().prototype.ifft=function(){return this.throwIfDisposed(),ph(this)},xs().prototype.irfft=function(){return this.throwIfDisposed(),fh(this)};const qg=$s({isFinite_:function(e){const t={x:Ys(e,"x","isFinite")};return Ws.runKernel(La,t)}});xs().prototype.isFinite=function(){return this.throwIfDisposed(),qg(this)};const Xg=$s({isInf_:function(e){const t={x:Ys(e,"x","isInf")};return Ws.runKernel(za,t)}});xs().prototype.isInf=function(){return this.throwIfDisposed(),Xg(this)};const Yg=$s({isNaN_:function(e){const t={x:Ys(e,"x","isNaN")};return Ws.runKernel(Ma,t)}});xs().prototype.isNaN=function(){return this.throwIfDisposed(),Yg(this)},xs().prototype.leakyRelu=function(e){return this.throwIfDisposed(),au(this,e)},xs().prototype.lessEqual=function(e){return this.throwIfDisposed(),$h(this,e)},xs().prototype.less=function(e){return this.throwIfDisposed(),td(this,e)};const Jg=$s({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const o=Ys(e,"x","localResponseNormalization");Ft(4===o.rank||3===o.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(o.rank,"."))),Ft(zt(t),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,".")));let s=o,i=!1;3===o.rank&&(i=!0,s=Sc(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const l={x:s},c={depthRadius:t,bias:n,alpha:a,beta:r},u=Ws.runKernel(qa,l,c);return i?Sc(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});xs().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),Jg(this,e,t,n,a)};const $g=$s({logSigmoid_:function(e){const t=Ys(e,"x","logSigmoid");return ol((e=>({value:Nu($u(Nu(e))),gradFunc:t=>tl(t,ju(Nu(e)))})))(t)}});xs().prototype.logSigmoid=function(){return this.throwIfDisposed(),$g(this)},xs().prototype.logSoftmax=function(e){return this.throwIfDisposed(),lu(this,e)},xs().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),bu(this,e,t)},xs().prototype.log=function(){return this.throwIfDisposed(),ru(this)},xs().prototype.log1p=function(){return this.throwIfDisposed(),ou(this)},xs().prototype.logicalAnd=function(e){return this.throwIfDisposed(),yu(this,e)},xs().prototype.logicalNot=function(){return this.throwIfDisposed(),dg(this)};const Qg=$s({logicalOr_:function(e,t){const n=Ys(e,"a","logicalOr","bool"),a=Ys(t,"b","logicalOr","bool");kl(n.shape,a.shape);const r={a:n,b:a};return Ws.runKernel(Ka,r)}});xs().prototype.logicalOr=function(e){return this.throwIfDisposed(),Qg(this,e)};const Zg=$s({logicalXor_:function(e,t){const n=Ys(e,"a","logicalXor","bool"),a=Ys(t,"b","logicalXor","bool");return kl(n.shape,a.shape),yu(Qg(e,t),dg(yu(e,t)))}});xs().prototype.logicalXor=function(e){return this.throwIfDisposed(),Zg(this,e)},xs().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),vu(this,e,t,n)},xs().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),xu(this,e,t,n,a)},xs().prototype.max=function(e,t){return this.throwIfDisposed(),su(this,e,t)},xs().prototype.maximum=function(e){return this.throwIfDisposed(),Sl(this,e)},xs().prototype.mean=function(e,t){return this.throwIfDisposed(),ku(this,e,t)},xs().prototype.min=function(e,t){return this.throwIfDisposed(),Su(this,e,t)},xs().prototype.minimum=function(e){return this.throwIfDisposed(),Iu(this,e)};const em=$s({mirrorPad_:function(e,t,n){Ft("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const a=Ys(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Ft(t.length===a.rank,(()=>"Padding doesn't match input. Must be ".concat(a.rank,". ")+"Got ".concat(t.length,".")));const r="reflect"===n?1:0;for(let i=0;i<a.rank;i++)Ft(2===t[i].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Ft(t[i][0]>=0&&t[i][0]<=a.shape[i]-r&&t[i][1]>=0&&t[i][1]<=a.shape[i]-r,(()=>"Padding in dimension ".concat(i," cannot be greater than or equal ")+"to ".concat(a.shape[i]-r," or less than 0 for input of ")+"shape ".concat(a.shape)));const o={paddings:t,mode:n},s={x:a};return Ws.runKernel(or,s,o)}});xs().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),em(this,e,t)};const tm=$s({mod_:function(e,t){let n=Ys(e,"a","mod"),a=Ys(t,"b","mod");[n,a]=Ds(n,a);const r={a:n,b:a};return Ws.runKernel(sr,r)}});xs().prototype.mod=function(e){return this.throwIfDisposed(),tm(this,e)},xs().prototype.mul=function(e){return this.throwIfDisposed(),tl(this,e)},xs().prototype.neg=function(){return this.throwIfDisposed(),Nu(this)},xs().prototype.norm=function(e,t,n){return this.throwIfDisposed(),rd(this,e,t,n)},xs().prototype.notEqual=function(e){return this.throwIfDisposed(),Eu(this,e)},xs().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),Tu(this,e,t,n)},xs().prototype.onesLike=function(){return this.throwIfDisposed(),Fu(this)},xs().prototype.pad=function(e,t){return this.throwIfDisposed(),Du(this,e,t)};const nm=$s({pool_:function(e,t,n,a,r,o,s){null==r&&(r=[1,1]),null==o&&(o=1),0===a&&(a="valid");const i=Ys(e,"x","maxPool");let l=i,c=!1;3===i.rank&&(c=!0,l=Sc(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Ft(vc(o,r),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(r,"'")));const u=cc(l.shape,t,o,r,a),h=[u.dilationHeight,u.dilationWidth];let d;d="same"===a?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),a=n.map((e=>e-1)),r=a.map((e=>Math.floor(e/2))),o=a.map(((e,t)=>e-r[t]));return a.map(((e,t)=>[r[t],o[t]]))}([u.filterHeight,u.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,g]=function(e,t,n){const a=n.map((e=>e[0])),r=n.map((e=>e[1])),o=e.concat(a,r),s=t.map(((e,t)=>(e-o[t]%e)%e)),i=r.map(((e,t)=>e+s[t])),l=t.map(((e,t)=>[a[t],i[t]])),c=t.map(((e,t)=>[0,s[t]]));return[l,c]}([u.inHeight,u.inWidth],h,d),m=p?a:"valid",b=p?l:Vp(l,h,f),y=("avg"===n?()=>Ic(b,t,o,m,s):()=>xu(b,t,o,m,s))(),v=p?y:Ig(y,h,g);return c?Sc(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});xs().prototype.pool=function(e,t,n,a,r,o){return this.throwIfDisposed(),nm(this,e,t,n,a,r,o)},xs().prototype.pow=function(e){return this.throwIfDisposed(),ml(this,e)},xs().prototype.prelu=function(e){return this.throwIfDisposed(),_u(this,e)};const am=$s({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Ys(e,"x","prod");"bool"===a.dtype&&(a=Ji(a,"int32"));const r={x:a},o={axis:t,keepDims:n};return Ws.runKernel(xr,r,o)}});xs().prototype.prod=function(e,t){return this.throwIfDisposed(),am(this,e,t)};const rm=$s({reciprocal_:function(e){const t={x:Ys(e,"x","reciprocal")};return Ws.runKernel(Nr,t)}});xs().prototype.reciprocal=function(){return this.throwIfDisposed(),rm(this)},xs().prototype.relu=function(){return this.throwIfDisposed(),Wu(this)},xs().prototype.relu6=function(){return this.throwIfDisposed(),mh(this)},xs().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Sc(this,e.shape)},xs().prototype.reshape=function(e){return this.throwIfDisposed(),Sc(this,e)},xs().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Xh(this,e,t,n)},xs().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Yh(this,e,t,n)},xs().prototype.reverse=function(e){return this.throwIfDisposed(),Uu(this,e)},xs().prototype.rfft=function(){return this.throwIfDisposed(),dh(this)},xs().prototype.round=function(){return this.throwIfDisposed(),Qh(this)},xs().prototype.rsqrt=function(){return this.throwIfDisposed(),mf(this)},xs().prototype.selu=function(){return this.throwIfDisposed(),Vu(this)},xs().prototype.separableConv2d=function(e,t,n,a,r,o){return this.throwIfDisposed(),Gu(this,e,t,n,a,r,o)},xs().prototype.sigmoid=function(){return this.throwIfDisposed(),ju(this)};const om=$s({sign_:function(e){const t={x:Ys(e,"x","sign")};return Ws.runKernel(Hr,t)}});xs().prototype.sign=function(){return this.throwIfDisposed(),om(this)},xs().prototype.sin=function(){return this.throwIfDisposed(),ef(this)},xs().prototype.sinh=function(){return this.throwIfDisposed(),nf(this)},xs().prototype.slice=function(e,t){return this.throwIfDisposed(),Hu(this,e,t)},xs().prototype.softmax=function(e){return this.throwIfDisposed(),Ju(this,e)},xs().prototype.softplus=function(){return this.throwIfDisposed(),$u(this)},xs().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Vp(this,e,t)},xs().prototype.split=function(e,t){return this.throwIfDisposed(),Qu(this,e,t)},xs().prototype.sqrt=function(){return this.throwIfDisposed(),nl(this)},xs().prototype.square=function(){return this.throwIfDisposed(),al(this)},xs().prototype.squaredDifference=function(e){return this.throwIfDisposed(),cd(this,e)},xs().prototype.squeeze=function(e){return this.throwIfDisposed(),Zu(this,e)},xs().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof vs?[this,e]:[this,...e];return eh(n,t)},xs().prototype.step=function(e){return this.throwIfDisposed(),bh(this,e)};const sm=$s({stridedSlice_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const c={x:Ys(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:a,beginMask:r,endMask:o,ellipsisMask:s,newAxisMask:i,shrinkAxisMask:l};return Ws.runKernel(io,c,u)}});xs().prototype.stridedSlice=function(e,t,n,a,r,o,s,i){return this.throwIfDisposed(),sm(this,e,t,n,a,r,o,s,i)},xs().prototype.sub=function(e){return this.throwIfDisposed(),bl(this,e)},xs().prototype.sum=function(e,t){return this.throwIfDisposed(),iu(this,e,t)};const im=$s({tan_:function(e){const t={x:Ys(e,"x","tan","float32")};return Ws.runKernel(po,t)}});xs().prototype.tan=function(){return this.throwIfDisposed(),im(this)},xs().prototype.tanh=function(){return this.throwIfDisposed(),th(this)},xs().prototype.tile=function(e){return this.throwIfDisposed(),$c(this,e)},xs().prototype.toBool=function(){return this.throwIfDisposed(),Ji(this,"bool")},xs().prototype.toFloat=function(){return this.throwIfDisposed(),Ji(this,"float32")},xs().prototype.toInt=function(){return this.throwIfDisposed(),Ji(this,"int32")};const lm=$s({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=Ys(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=a.shape[a.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>r)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(r,") ")+"but got ".concat(t));const o={x:a},s={k:t,sorted:n},[i,l]=Ws.runKernel(mo,o,s);return{values:i,indices:l}}});xs().prototype.topk=function(e,t){return this.throwIfDisposed(),lm(this,e,t)},xs().prototype.transpose=function(e){return this.throwIfDisposed(),ch(this,e)};const cm=$s({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Ys(e,"x","unique","string_or_numeric");Ft(n.rank>0,(()=>"The input tensor must be at least 1D"));const a={x:n},r={axis:t},[o,s]=Ws.runKernel(vo,a,r);return{values:o,indices:s}}});xs().prototype.unique=function(e){return this.throwIfDisposed(),cm(this,e)},xs().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),yf(this,e,t)},xs().prototype.unstack=function(e){return this.throwIfDisposed(),oh(this,e)},xs().prototype.where=function(e,t){return this.throwIfDisposed(),sh(e,this,t)},xs().prototype.zerosLike=function(){return this.throwIfDisposed(),rl(this)};class um extends Error{constructor(e){super(e),Object.setPrototypeOf(this,um.prototype)}}class hm extends Error{constructor(e){super(e),Object.setPrototypeOf(this,hm.prototype)}}class dm extends Error{constructor(e){super(e),Object.setPrototypeOf(this,dm.prototype)}}class pm extends Error{constructor(e){super(e),Object.setPrototypeOf(this,pm.prototype)}}class fm extends Error{constructor(e){super(e),Object.setPrototypeOf(this,fm.prototype)}}Error;class gm{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e,"."));if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function mm(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function bm(e,t){if(!e)throw new fm(t)}function ym(e,t){let n=0;for(const a of e)a===t&&n++;return n}function vm(e){return 1===e.length?e[0]:e}function xm(e){return Array.isArray(e)?e:[e]}function wm(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function km(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let Sm={};function Im(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Cm(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>Cm(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?Cm(t):e[n]=t.value)}}}function Nm(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const r=e;let o;if(r in n)o=n[r];else if(r in Sm)o=Sm[r];else if(o=t[r],null==o)throw new dm("Unknown ".concat(a,": ").concat(e,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return o}{const o=e;if(null==o.className||null==o.config)throw new dm("".concat(a,": Improper config format: ")+"".concat(JSON.stringify(o),".\n")+"'className' and 'config' must set.");const s=o.className;let i,l;if(s in n?[i,l]=n[s]:s in Sm?[i,l]=Sm.className:s in t&&([i,l]=t[s]),null==i)throw new dm("Unknown ".concat(a,": ").concat(s,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=l){const e={};for(const n of Object.keys(Sm))e[n]=Sm[n];for(const r of Object.keys(n))e[r]=n[r];o.config.customObjects=e;const t=Object.assign({},Sm);for(const r of Object.keys(n))Sm[r]=n[r];Cm(o.config);const a=l(i,o.config,n,r);return Sm=Object.assign({},t),a}{const e=Object.assign({},Sm);for(const a of Object.keys(n))Sm[a]=n[a];const t=new i(o.config);return Sm=Object.assign({},e),t}}}function Em(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function Tm(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function Rm(e){if(null==e)throw new dm("Invalid value in obj: ".concat(JSON.stringify(e)));for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function Am(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new dm("".concat(n," is not a valid ").concat(t,".  Valid values are ").concat(e," or null/undefined."))}function Fm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return bm(n>=0),bm(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every((e=>typeof e===t))}function Dm(e,t){Array.isArray(e)?(Ft(e.length>0,(()=>"".concat(t," is unexpectedly an empty array."))),e.forEach(((e,n)=>Dm(e,"element ".concat(n+1," of ").concat(t))))):Ft(Number.isInteger(e)&&e>0,(()=>"Expected ".concat(t," to be a positive integer, but got ")+"".concat(_m(e),".")))}function _m(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>_m(e))).join(",")+"]":"string"===typeof e?'"'.concat(e,'"'):"".concat(e)}function Om(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let Lm=0;function zm(){return Lm++}const Mm={};function Pm(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in Mm||(Mm[e]=0),Mm[e]+=1,e+Mm[e].toString()}const Bm=["channelsFirst","channelsLast"],Wm=["nearest","bilinear"],Um=["valid","same","causal"],Vm=["max","avg"],Gm=["sum","mul","concat","ave"],jm=new Map;function Hm(e){Am(Bm,"DataFormat",e)}function Km(e){Am(Um,"PaddingMode",e)}function qm(e){Am(Vm,"PoolMode",e)}const Xm=[];function Ym(e,t){Xm.push(e);try{const e=t();return Xm.pop(),e}catch(IW){throw Xm.pop(),IW}}function Jm(e){if(!Zm(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===Xm.length?"":Xm.join("/")+"/")+e}function $m(e){if(!Zm(e))throw new Error("Not a valid tensor name: '"+e+"'");jm.has(e)||jm.set(e,0);const t=jm.get(e);if(jm.set(e,jm.get(e)+1),t>0){const n="".concat(e,"_").concat(t);return jm.set(n,1),n}return e}const Qm=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Zm(e){return!!e.match(Qm)}function eb(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function tb(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a<t&&(t=a)}return t}function nb(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a>t&&(t=a)}return t}function ab(e,t){if(t<e)throw new dm("end (".concat(t,") < begin (").concat(e,") is forbidden."));const n=[];for(let a=e;a<t;++a)n.push(a);return n}let rb;function ob(){return null==rb&&(rb=ci().epsilon()),rb}function sb(e,t){return Ji(e,t)}function ib(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Sc(e,n)}function lb(e,t,n){return oi((()=>{switch(e.rank){case 1:return Ku(e,t,n);case 2:return qu(e,[t,0],[n,e.shape[1]]);case 3:return Xu(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Yu(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Hu(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Hu(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new dm("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function cb(e,t,n){return oi((()=>{switch(e.rank){case 1:return Ku(e,t,n);case 2:return qu(e,[0,t],[e.shape[0],n]);case 3:return Xu(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Yu(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new dm("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function ub(e,t,n,a){return oi((()=>{switch(e.rank){case 1:return Ku(e,t,n);case 2:switch(a){case 1:return lb(e,t,n);case 2:return cb(e,t,n);default:throw new dm("The axis is not within the rank of the tensor "+"".concat(a))}case 3:switch(a){case 1:return lb(e,t,n);case 2:return Xu(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return cb(e,t,n);default:throw new dm("The axis is not within the rank of the tensor "+"".concat(a))}case 4:switch(a){case 1:return lb(e,t,n);case 2:return Yu(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Yu(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return cb(e,t,n);default:throw new dm("The axis is not within the rank of the tensor "+"".concat(a))}default:throw new dm("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function hb(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),Dc(e,n)}function db(e,t){switch(e.rank){case 1:return _c([e,t]);case 2:return Oc([e,t],0);case 3:return Lc([e,t],0);case 4:return zc([e,t],0);default:throw new dm("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(e.rank))}}function pb(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new dm("The length of input n (".concat(t.length,") does not match ")+"the number of dimensions in input x (".concat(e.rank,")"));return $c(e,t)}function fb(e){return Mu(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function gb(e,t,n,a){if(e.rank<2||t.rank<2)throw new pm("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(e.shape," and y shape = ").concat(t.shape));if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new pm("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(e.shape," and ")+" y shape = ".concat(t.shape))}if(2===e.rank&&2===t.rank){return Ch({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?yb(e.rank,a,"channelsLast"):null,activation:n})}{const r=e.shape.slice(),o=r.pop();e=Sc(e,[-1,o]);const s=t.shape.slice(),i=s.pop(),l=s.pop(),c=[...s,i],u=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Sc(ch(t,u),[l,-1]);const h=[...r,...c];return Sc(Ch({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?yb(e.rank,a,"channelsLast"):null,activation:n}),h)}}function mb(e,t,n){return oi((()=>(t=Array.isArray(t)?nh(t,"int32"):Ji(t,"int32"),eu(e,t,n))))}function bb(e){return tl(e,e)}function yb(e,t,n){const a=t.shape;if(1!==t.rank&&t.rank!==e)throw new dm("Unexpected bias dimensions: ".concat(t.rank)+"; expected it to be 1 or ".concat(e));if(5===e){if("channelsFirst"===n)return 1===a.length?Sc(t,[1,a[0],1,1,1]):Sc(t,[1,a[3],a[0],a[1],a[2]]);if("channelsLast"===n)return 1===a.length?Sc(t,[1,1,1,1,a[0]]):Sc(t,[1].concat(a))}else if(4===e){if("channelsFirst"===n)return 1===a.length?Sc(t,[1,a[0],1,1]):Sc(t,[1,a[2],a[0],a[1]]);if("channelsLast"===n)return 1===a.length?Sc(t,[1,1,1,a[0]]):Sc(t,[1].concat(a))}else if(3===e){if("channelsFirst"===n)return 1===a.length?Sc(t,[1,a[0],1]):Sc(t,[1,a[1],a[0]]);if("channelsLast"===n)return 1===a.length?Sc(t,[1,1,a[0]]):Sc(t,[1].concat(a))}else if(e<3)return t;throw new dm("Unsupported input rank by biasAdd: ".concat(t.rank))}function vb(e,t,n){return oi((()=>(null==n&&(n="channelsLast"),Hm(n),Qi(e,yb(e.rank,t,n)))))}function xb(e,t,n,a){return oi((()=>uh(e,t,n,a)))}function wb(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const kb=["fanIn","fanOut","fanAvg"],Sb=["normal","uniform","truncatedNormal"];class Ib extends cl{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Cb extends Ib{apply(e,t){return Ru(e,t)}}Cb.className="Zeros",hl(Cb);class Nb extends Ib{apply(e,t){return Au(e,t)}}Nb.className="Ones",hl(Nb);class Eb extends Ib{constructor(e){if(super(),"object"!==typeof e)throw new dm("Expected argument of type ConstantConfig but got ".concat(e));if(void 0===e.value)throw new dm("config must have value set but got ".concat(e));this.value=e.value}apply(e,t){return oi((()=>tl(sl(this.value),Au(e,t))))}getConfig(){return{value:this.value}}}Eb.className="Constant",hl(Eb);class Tb extends Ib{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Pu(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Tb.className="RandomUniform",hl(Tb);class Rb extends Ib{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new pm("randomNormal does not support dType ".concat(t,"."));return fb(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Rb.className="RandomNormal",hl(Rb);class Ab extends Ib{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new pm("truncatedNormal does not support dType ".concat(t,"."));return rh(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Ab.className="TruncatedNormal",hl(Ab);class Fb extends Ib{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return oi((()=>{if(2!==e.length||e[0]!==e[1])throw new dm("Identity matrix initializer can only be used for 2D square matrices.");return tl(this.gain,Qc(e[0]))}))}getConfig(){return{gain:this.gain}}}Fb.className="Identity",hl(Fb);class Db extends Ib{constructor(e){if(super(),e.scale<0)throw new dm("scale must be a positive float. Got: ".concat(e.scale));var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,Am(kb,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){Am(Sb,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(Hm(a),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===a){const a=eb(e,2);t=e[1]*a,n=e[0]*a}else if("channelsLast"===a){const a=eb(e,0,e.length-2);t=e[e.length-2]*a,n=e[e.length-1]*a}}else{const a=eb(e);t=Math.sqrt(a),n=Math.sqrt(a)}return[t,n]}(e),a=n[0],r=n[1];let o=this.scale;if("fanIn"===this.mode?o/=Math.max(1,a):"fanOut"===this.mode?o/=Math.max(1,r):o/=Math.max(1,(a+r)/2),"normal"===this.distribution){const n=Math.sqrt(o);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new pm("".concat(this.getClassName()," does not support dType ").concat(t,"."));return rh(e,0,n,t,this.seed)}{const n=Math.sqrt(3*o);return Pu(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Db.className="VarianceScaling",hl(Db);class _b extends Db{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Db.className}}_b.className="GlorotUniform",hl(_b);class Ob extends Db{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Db.className}}Ob.className="GlorotNormal",hl(Ob);class Lb extends Db{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Db.className}}Lb.className="HeNormal",hl(Lb);class zb extends Db{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Db.className}}zb.className="HeUniform",hl(zb);class Mb extends Db{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Db.className}}Mb.className="LeCunNormal",hl(Mb);class Pb extends Db{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Db.className}}Pb.className="LeCunUniform",hl(Pb);class Bb extends Ib{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return oi((()=>{if(e.length<2)throw new pm("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError("Unsupported data type ".concat(t,"."));const n=Ot(e.slice(0,-1)),a=e[e.length-1],r=n*a;r>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than ".concat(this.ELEMENTS_WARN_SLOW," (").concat(r,") elements: ")+"Slowness may result.");const o=fb([Math.max(a,n),Math.min(a,n)],0,1,t,this.seed),s=hd.qr(o,!1);let i=s[0];const l=s[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return i=tl(i,l.sign()),n<a&&(i=i.transpose()),tl(sl(this.gain),i.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}Bb.className="Orthogonal",hl(Bb);const Wb={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Ub(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Nm(e,ul.getMap().classNameMap,t,"initializer")}function Vb(e){return Im(e)}function Gb(e){if("string"===typeof e){const t=e in Wb?Wb[e]:e;if("GlorotNormal"===t)return new Ob;if("GlorotUniform"===t)return new _b;if("HeNormal"===t)return new Lb;if("HeUniform"===t)return new zb;if("LeCunNormal"===t)return new Mb;if("LeCunUniform"===t)return new Pb;{const e={};return e.className=t,e.config={},Ub(e)}}return e instanceof Ib?e:Ub(e)}function jb(e){return Array.isArray(e)&&Array.isArray(e[0])}function Hb(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Kb(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new dm("Expected Tensor length to be 1; got ".concat(e.length));t=e[0]}else t=e;return t}function qb(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new dm("Expected exactly 1 Shape; got ".concat(e.length))}return e}function Xb(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const Yb="Variable";class Jb{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Yb,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=zm(),n=null==n?Yb:n,this.originalName=Jm(n),this.name=$m(this.originalName),this.trainable_=a,this.constraint=r,this.val=function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return Ws.makeVariable(e,t,n,a)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function $b(e){return e.map((e=>e.read()))}function Qb(e){e.forEach((e=>{e[0].write(e[1])}))}class Zb{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class ey{constructor(e,t,n,a,r,o,s){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=s,this.id=zm(),null!=o&&(this.originalName=Jm(o),this.name=$m(this.originalName)),this.rank=t.length}}let ty=0;class ny{constructor(e,t){this.callArgs=t,this.id=ty++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let ay=0;class ry extends cl{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=ay++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=wm(e)+"_"+Pm(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new hm("The layer has never been called "+"and thus has no defined ".concat(t,"."));if(this.inboundNodes.length<=e)throw new dm("Asked to get ".concat(t," at node ").concat(e,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[e]}getInputAt(e){return vm(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return vm(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new um("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new um("Layer ".concat(this.name)+" is not connected, no input to return.");return vm(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new um("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new um("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return vm(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=xm(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=xm(this.inputSpec);if(t.length!==n.length)throw new dm("Layer ".concat(this.name," expects ").concat(n.length," inputs, ")+"but it received ".concat(t.length," input tensors. ")+"Input received: ".concat(e));for(let a=0;a<t.length;a++){const e=t[a],r=n[a];if(null==r)continue;const o=e.rank;if(null!=r.ndim&&o!==r.ndim)throw new dm("Input ".concat(a," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(r.ndim,", found ndim=").concat(o));if(null!=r.maxNDim&&o>r.maxNDim)throw new dm("Input ".concat(a," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(r.maxNDim,", found ndim=").concat(o));if(null!=r.minNDim&&o<r.minNDim)throw new dm("Input ".concat(a," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(r.minNDim,", found ndim=").concat(o,"."));if(null!=r.dtype&&e.dtype!==r.dtype)throw new dm("Input ".concat(a," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(r.dtype,", found dtype=").concat(e.dtype,"."));if(r.axes){const t=e.shape;for(const e in r.axes){const n=Number(e),o=r.axes[e],s=n>=0?t[n]:t[t.length+n];if(null!=o&&-1===[o,null].indexOf(s))throw new dm("Input ".concat(a," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(n," of input shape to ")+"have value ".concat(o," but got shape ").concat(t,"."))}}if(null!=r.shape)for(let t=0;t<r.shape.length;++t){const n=r.shape[t],o=e.shape[t];if(null!=n&&null!=o&&n!==o)throw new dm("Input ".concat(a," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(r.shape,", ")+"found shape=".concat(e.shape,"."))}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=xm(e),a=function(e){let t=!0;for(const n of xm(e))if(!(n instanceof ey)){t=!1;break}return t}(e),r=function(e){let t=!0;for(const n of xm(e))if(n instanceof ey){t=!1;break}return t}(e);if(a===r)throw new dm("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ym(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of xm(e))t.push(n.shape);this.build(vm(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const r=xm(a),o=[];for(let e of r)-1!==n.indexOf(e)&&(e=e.clone()),o.push(e);if(a=vm(o),null!=this.activityRegularizer)throw new pm("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}{const n=function(e){e=xm(e);const t=[];for(const n of e)t.push(n.shape);return vm(t)}(e),a=this.computeOutputShape(n);let r;const o="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),r=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,a)=>new ey(o,n,this,xm(e),t,this.name,a))):new ey(o,a,this,xm(e),t,this.name),this.addInboundNode(e,r,null,null,n,a,t),this._refCount++,null!=this.activityRegularizer)throw new pm("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(e),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let t=!1;this.batchInputShape.forEach(((n,a)=>{null!=n&&null!=e[a]&&e[a]!==n&&(t=!0)})),t&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(e),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new um("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new um("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new hm("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return Xb(this.weights)}build(e){this.built=!0}getWeights(){return $b(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){oi((()=>{const t=this.weights;if(t.length!==e.length)throw new dm('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(e.length,", ")+"but the layer was expecting ".concat(t.length," weights. ")+"Provided weights: ".concat(e,"..."));if(0===t.length)return;const n=[],a=$b(t);for(let r=0;r<a.length;++r){const o=a[r],s=t[r],i=e[r];if(!Lt(o.shape,i.shape))throw new dm("Layer weight shape ".concat(o.shape," ")+"not compatible with provided weight shape ".concat(i.shape));n.push([s,i])}Qb(n)}))}addWeight(e,t,n,a,r,o,s,i){if(-1!==this._addedWeightNames.indexOf(e))throw new dm("Duplicate weight name ".concat(e," for layer ").concat(this.name));this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(a=null!=i?i():Gb("zeros"));const l=a.apply(t,n),c=new Jb(l,n,e,o,s);return l.dispose(),null!=r&&this.addLoss((()=>r.apply(c.read()))),null==o&&(o=!0),o?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=xm(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");t.forEach((e=>{if(null!=e)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const a=this.computeMask(e,n),r=xm(t),o=xm(a);if(r.length!==o.length)throw new Error("".concat(this.name," outputs ").concat(r.length," tensors ")+"but ".concat(r.length," masks for those tensors"));for(let s=0;s<r.length;s++)r[s].kerasMask=o[s]}addInboundNode(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const i=xm(e);t=xm(t),n=xm(n),a=xm(a),r=Hb(r),o=Hb(o);const l=[],c=[],u=[];for(const h of i)l.push(h.sourceLayer),c.push(h.nodeIndex),u.push(h.tensorIndex);new ny({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:i,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:o},s);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function oy(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const a=oy(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of a)-1===t.indexOf(e)&&t.push(e)}return t}}}class sy extends ry{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Pm("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new dm("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new dm("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new dm("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const a=new ey(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new ny({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new dm("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}sy.className="InputLayer",hl(sy);class iy{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof iy)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new dm("Duplicate key: name=".concat(e.name,", id=").concat(e.id));return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Ji(t,e.dtype)}catch(CW){throw new dm("The dtype of the feed (".concat(t.dtype,") can not be cast to the dtype ")+"of the key '".concat(e.name,"' (").concat(e.dtype,")."))}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof ey){if(null==this.id2Value[e.id])throw new dm("Nonexistent key: ".concat(e.name));return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new dm("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Value[t]}}getMask(e){if(e instanceof ey){if(null==this.id2Value[e.id])throw new dm("Nonexistent key: ".concat(e.name));return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new dm("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&si(this.id2Mask)}}const ly=new gm,cy=new gm;function uy(e,t,n,a){const r=null!=n&&n.training,o=Array.isArray(e),s=o?e:[e],i=s.map((e=>e.name)),l=[],c=t.names();for(const f of i)-1!==c.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=a&&(a.maxNumTensors=-1/0,a.minNumTensors=1/0);const u=i.join(",")+"|"+t.names().sort().join(",");let h,d=ly.get(u);if(null==d){const e=function(e,t){Ft(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],a={};if(1===e.length){const r=dy(e[0],t);n=r.sorted,a=r.recipientMap}else{const r=new Set;for(const o of e){const{sorted:e,recipientMap:s}=dy(o,t);for(const t of e)r.has(t.name)||(n.push(t),r.add(t.name));for(const t in s)null==a[t]&&(a[t]=new Set),s[t].forEach((e=>a[t].add(e)))}}return{sorted:n,recipientCounts:hy(a)}}(s,t);d=e.sorted,h=e.recipientCounts,ly.put(u,d),cy.put(u,h)}h={},r||Object.assign(h,cy.get(u));const p=new iy(t);for(let f=0;f<d.length;++f){if(null!=a){const e=ri().numTensors;e>a.maxNumTensors&&(a.maxNumTensors=e),e<a.minNumTensors&&(a.minNumTensors=e)}const e=d[f],o=e.sourceLayer;if(o instanceof sy)continue;const s=[],c=[],u=[];let g=!1;for(const n of e.inputs){const e=p.getValue(n),a=p.getMask(n);s.push(e),c.push(a),null!=a&&(g=!0),r||(h[n.name]--,0!==h[n.name]||t.hasKey(n)||-1!==i.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||u.push(e))}g&&((n=n||{}).mask=c[0]);const m=xm(o.apply(s,n));let b=null;o.supportsMasking&&(b=o.computeMask(s,c));const y=py(e),v=Array.isArray(y)?y:[y];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],m[t],Array.isArray(b)?b[0]:b);const e=i.indexOf(v[t].name);-1!==e&&(l[e]=m[t])}r||si(u)}return p.disposeMasks(),o?l:l[0]}function hy(e){const t={};for(const n in e)t[n]=e[n].size;return t}function dy(e,t){const n=new Set,a=[],r={};for(const i of t.names())n.add(i);const o=[],s=[];for(o.push(e);o.length>0;){const e=o[o.length-1];if(n.has(e.name)){o.pop();continue}const t=s[s.length-1]===o.length-1;if(0===e.inputs.length||t)o.pop(),a.push(e),n.add(e.name),t&&s.pop();else{s.push(o.length-1);for(const t of e.inputs)null==r[t.name]&&(r[t.name]=new Set),r[t.name].add(e.name),n.has(t.name)||o.push(t)}}return{sorted:a,recipientMap:r}}function py(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const a of e.sourceLayer.inboundNodes[t].outputTensors)if(a.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function fy(e,t){return oi((()=>nl(iu(tl(e,e),t,!0))))}dn().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=ly&&ly.setMaxEntries(e),null!=cy&&cy.setMaxEntries(e)}));class gy extends cl{getConfig(){return{}}}class my extends gy{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return oi((()=>{const t=fy(e,this.axis),n=Fc(t,0,this.maxValue);return tl(e,el(n,Qi(ob(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}my.className="MaxNorm",hl(my);class by extends gy{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return oi((()=>el(e,Qi(ob(),fy(e,this.axis)))))}getConfig(){return{axis:this.axis}}}by.className="UnitNorm",hl(by);class yy extends gy{apply(e){return Wu(e)}}yy.className="NonNeg",hl(yy);class vy extends gy{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return oi((()=>{const t=fy(e,this.axis),n=Qi(tl(this.rate,Fc(t,this.minValue,this.maxValue)),tl(1-this.rate,t));return tl(e,el(n,Qi(ob(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}vy.className="MinMaxNorm",hl(vy);const xy={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function wy(e){return Im(e)}function ky(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Nm(e,ul.getMap().classNameMap,t,"constraint")}function Sy(e){if(null==e)return null;if("string"===typeof e){return ky({className:e in xy?xy[e]:e,config:{}})}return e instanceof gy?e:ky(e)}async function Iy(e){if(null==e)return;const t=[],n=[],a=[];for(const r in e){const o=e[r];if("number"!==typeof o){const e=o;t.push(e.data()),n.push(r),a.push(e)}}if(t.length>0){const r=await Promise.all(t);for(let t=0;t<r.length;++t)e[n[t]]=r[t][0];si(a)}}function Cy(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var Ny;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(Ny||(Ny={}));class Ey{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Ty{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Ry extends Ey{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const a in t){const e=t[a];if("number"===typeof e)this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+e*n;else{let t;a in this.totals?t=this.totals[a]:this.totals[a]=0;const r=oi((()=>Qi(this.totals[a],tl(e,n))));this.totals[a]=r,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:oi((()=>{const e=tl(el(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),ii(t[n])})))}}class Ay extends Ey{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const a=this.history[r];for(let o=0;o<a.length;++o)if("number"!==typeof a[o]){const s=a[o];e.push(s.data()),t.push(r),n.push(o)}}const a=await Promise.all(e);for(let r=0;r<a.length;++r){this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}}}class Fy extends Ey{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||fd,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Xt(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let a,r=null!=n?n():ns();return function(){const o=null!=n?n():ns();return o-r<t||(r=o,a=e(...arguments)),a}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const a=[];null!=this.yield&&(await Iy(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Iy(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await Iy(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Iy(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await Iy(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Xt(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Iy(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Iy(e),await this.trainEnd(e))}}function Dy(e,t){if(null==e&&(e={}),e instanceof Ey)return[e];if(Array.isArray(e)&&e[0]instanceof Ey)return e;return xm(e).map((e=>new Fy(e,t)))}class _y{constructor(){}static registerCallbackConstructor(e,t){Ft(e>=0&&Number.isInteger(e),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(e))),_y.checkForDuplicate(t),null==_y.constructors[e]&&(_y.constructors[e]=[]),_y.constructors[e].push(t)}static checkForDuplicate(e){for(const t in _y.constructors){_y.constructors[+t].forEach((t=>{if(t===e)throw new dm("Duplicate callback constructor.")}))}}static clear(){_y.constructors={}}static createCallbacks(e){const t=[];for(const n in _y.constructors){const a=+n;e>=a&&t.push(..._y.constructors[a])}return t.map((e=>new e))}}function Oy(e,t,n,a,r,o,s,i,l){const c=new Ay,u=[new Ry,..._y.createCallbacks(t)];null!=e&&u.push(...e),u.push(c);const h=new Ty(u);return h.setParams({epochs:n,initialEpoch:a,samples:r,steps:o,batchSize:s,verbose:t,doValidation:i,metrics:l}),{callbackList:h,history:c}}function Ly(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Nm(e,ul.getMap().classNameMap,t,"layer",n)}function zy(e,t){return oi((()=>{"float32"!==e.dtype&&(e=Ji(e,"float32"));const n=iu(bb(e),t,!0),a=fl(n.shape,ob()),r=nl(Sl(n,a));return el(e,r)}))}function My(e,t){return oi((()=>ku(bb(bl(t,e)),-1)))}function Py(e,t){return oi((()=>ku(vl(bl(t,e)),-1)))}function By(e,t){return oi((()=>{const n=bl(e,t),a=Fc(vl(e),ob(),Number.MAX_VALUE),r=vl(el(n,a));return tl(100,ku(r,-1))}))}function Wy(e,t){return oi((()=>{const n=Fc(t,ob(),Number.MAX_VALUE),a=ru(Qi(1,n)),r=Fc(e,ob(),Number.MAX_VALUE),o=ru(Qi(1,r));return ku(bb(bl(a,o)),-1)}))}function Uy(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return oi((()=>{if(n)t=Ju(t);else{const e=iu(t,t.shape.length-1,!0);t=el(t,e)}return t=Fc(t,ob(),1-ob()),Nu(iu(tl(Ji(e,"float32"),ru(t)),t.shape.length-1))}))}function Vy(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return oi((()=>{const a=Ji(Zc(function(e){const t=[eb(e.shape)];return Sc(e,t)}(e)),"int32"),r=(t=Fc(t,ob(),1-ob())).shape;return Uy(Sc(Tu(a,r[r.length-1]),r),t,n)}))}function Gy(e,t){return oi((()=>{let n;return n=Fc(t,ob(),1-ob()),n=ru(el(n,bl(1,n))),ku(function(e,t){if(!Lt(e.shape,t.shape))throw new dm("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(e.shape)," and ").concat(JSON.stringify(t.shape)));return oi((()=>{const n=Wu(t),a=Nu(vl(t));return Qi(bl(n,tl(t,e)),ou(Yc(a)))}))}(e,n),-1)}))}function jy(e,t){return oi((()=>{const n=Fc(e,ob(),1),a=Fc(t,ob(),1);return iu(tl(e,ru(el(n,a))),-1)}))}function Hy(e,t){return oi((()=>{const n=zy(e,-1),a=zy(t,-1),r=tl(n,a);return Nu(iu(r,-1))}))}_y.constructors={};const Ky={meanSquaredError:My,meanAbsoluteError:Py,meanAbsolutePercentageError:By,meanSquaredLogarithmicError:Wy,squaredHinge:function(e,t){return oi((()=>{const n=Sl(0,bl(1,tl(e,t)));return ku(bb(n),-1)}))},hinge:function(e,t){return oi((()=>{const n=Sl(0,bl(1,tl(e,t)));return ku(n,-1)}))},categoricalHinge:function(e,t){return oi((()=>{const n=iu(tl(e,t),-1),a=su(tl(bl(1,e),t),-1);return Sl(0,Qi(1,bl(a,n)))}))},logcosh:function(e,t){return oi((()=>{const n=Math.log(2),a=bl(t,e),r=bl(Qi(a,$u(tl(-2,a))),n);return ku(r,-1)}))},categoricalCrossentropy:Uy,sparseCategoricalCrossentropy:Vy,binaryCrossentropy:Gy,kullbackLeiblerDivergence:jy,poisson:function(e,t){return oi((()=>{const n=ru(Qi(ob(),t));return ku(bl(t,tl(e,n)),-1)}))},cosineProximity:Hy};function qy(e){if("string"===typeof e){if(e in Ky)return Ky[e];let t="Unknown loss ".concat(e);throw e.toLowerCase().includes("softmaxcrossentropy")&&(t="Unknown loss ".concat(e,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new dm(t)}return e}function Xy(e,t){return oi((()=>{const n=tl(.5,Fu(t)),a=sb(tu(t,n),e.dtype);return ku(qc(e,a),-1)}))}function Yy(e,t){return oi((()=>sb(qc(ic(e,-1),ic(t,-1)),"float32")))}function Jy(e,t){return oi((()=>Ji(iu(yu(qc(e,1),qc(t,1))),"float32")))}function $y(e,t){return Gy(e,t)}function Qy(e,t){return e.rank===t.rank&&(e=Zu(e,[e.rank-1])),(t=ic(t,-1)).dtype!==e.dtype&&(t=Ji(t,e.dtype)),Ji(qc(e,t),"float32")}const Zy=Uy,ev=Vy,tv={binaryAccuracy:Xy,categoricalAccuracy:Yy,precision:function(e,t){return oi((()=>{const n=Jy(e,t),a=function(e,t){return oi((()=>Ji(iu(yu(qc(e,0),qc(t,1))),"float32")))}(e,t),r=Qi(n,a);return Ji(sh(tu(r,0),el(n,r),0),"float32")}))},categoricalCrossentropy:Zy,sparseCategoricalCrossentropy:ev,mse:My,MSE:My,mae:Py,MAE:Py,mape:By,MAPE:By,cosine:Hy};function nv(e){if("string"===typeof e&&e in tv)return tv[e];if("string"!==typeof e&&null!=e)return e;throw new dm("Unknown metric ".concat(e))}function av(e){if(bm(null!==e,"Unknown LossOrMetricFn ".concat(e)),"string"===typeof e)return e;{let t;for(const n of Object.keys(Ky))if(Ky[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(tv))if(tv[n]===e){t=n;break}return void 0!==t?t:e.name}}const rv=1048576;function ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!sv(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>rv&&console.warn('User-defined metadata of model "'.concat(t,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(rv,"."))}}function sv(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!sv(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!sv(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function iv(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const r=function(e){let t=!0;const n=[],a=[];for(const r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(const r of e.layers){let e=!1;for(const n of r.inboundNodes)if(-1!==a.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),o=["Layer (type)","Input Shape","Output shape","Param #"];let s;if(r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!r){o.push("Receives inputs"),s=[];for(const t in e.nodesByDepth)s.push(...e.nodesByDepth[t])}a("_".repeat(t)),lv(o,n,a),a("=".repeat(t));const i=e.layers;for(let u=0;u<i.length;++u)r?cv(i[u],n,a):uv(i[u],n,s,a),a((u===i.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;t=null!=e.collectedTrainableWeights?Xb(e.collectedTrainableWeights):Xb(e.trainableWeights);return t}(e),c=Xb(e.nonTrainableWeights);a("Total params: ".concat(l+c)),a("Trainable params: ".concat(l)),a("Non-trainable params: ".concat(c)),a("_".repeat(t))}function lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,a="";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+" "),a+=e[r],a=a.slice(0,t[r]),a+=" ".repeat(t[r]-a.length);n(a)}function cv(e,t,n){let a,r;try{r=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(CW){r="multiple"}try{a=JSON.stringify(e.outputShape)}catch(CW){a="multiple"}const o=e.name,s=e.getClassName();lv(["".concat(o," (").concat(s,")"),r,a,e.countParams().toString()],t,n)}function uv(e,t,n,a){let r,o;try{o=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(CW){o="multiple"}try{r=JSON.stringify(e.outputShape)}catch(CW){r="multiple"}const s=[];for(const u of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let e=0;e<u.inboundLayers.length;++e){const t=u.inboundLayers[e].name,n=u.nodeIndices[e],a=u.tensorIndices[e];s.push("".concat(t,"[").concat(n,"][").concat(a,"]"))}const i=e.name,l=e.getClassName(),c=0===s.length?"":s[0];lv(["".concat(i," (").concat(l,")"),o,r,e.countParams().toString(),c],t,a);for(let u=1;u<s.length;++u)lv(["","","","",s[u]],t,a)}function hv(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function dv(e,t){if(null===e)return null;if("string"===typeof e)return km(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];hv(t,r,a)?n.push(a):n.push(dv(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n];if("name"===n&&"string"===typeof a)t[n]=a;else{const e=km(n);t[e]=dv(a,e)}}return t}}function pv(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return wm(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];hv(t,r,a)?n.push(a):n.push(pv(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n],r=wm(n);t[r]="name"!==n&&"className"!==n||"string"!==typeof a?pv(a,n):a}return t}}const fv="4.22.0";class gv extends ry{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=Pm(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Tm(this.inputs).length!==this.inputs.length)throw new dm("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((e=>e.name))));Tm(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((e=>e.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;bm(0===t,"input layer has >1 nodes"),bm(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const t=this.inputLayers[b];if(!(t instanceof sy))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(e.inputs,". ")+"Input ".concat(b," (0-based) originates ")+"from layer type ".concat(t.getClassName(),"."));this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},a={},r={},o={},s=[],i=(e,t,n,a,r,l)=>{null!=a&&null!=r&&null!=l||(a=e.sourceLayer,r=e.nodeIndex,l=e.tensorIndex);const c=a.inboundNodes[r];if(-1!==n.indexOf(c))throw new hm("The tensor ".concat(e.name,' at layer "').concat(a.name,'" ')+"is part of a cycle.");if(-1!==t.indexOf(c))return;this.containerNodes.add(gv.nodeKey(a,r)),a.id in o||(o[a.id]=Object.keys(o).length),-1===n.indexOf(c)&&n.push(c);const u=c.inboundLayers.length;for(let o=0;o<u;o++){const e=c.inputTensors[o],a=c.inboundLayers[o],r=c.nodeIndices[o],s=c.tensorIndices[o];i(e,t,n,a,r,s)}for(t.push(c);n.indexOf(c)>=0;)n.splice(n.indexOf(c),1);s.push(c)},l=[],c=[];for(const b of this.outputs)i(b,l,c);const u=s.slice().reverse();for(const b of u){n[b.id]=b,b.id in t||(t[b.id]=0);let e=t[b.id];const o=null==a[b.outboundLayer.id]?0:a[b.outboundLayer.id];e=Math.max(e,o),a[b.outboundLayer.id]=e,r[b.outboundLayer.id]=b.outboundLayer,t[b.id]=e;for(let a=0;a<b.inboundLayers.length;a++){const r=b.inboundLayers[a],o=b.nodeIndices[a],s=r.inboundNodes[o],i=null==t[s.id]?0:t[s.id];t[s.id]=Math.max(e+1,i),n[s.id]=s}}const h={};for(const b in t){const e=t[b];e in h||(h[e]=[]),h[e].push(n[b])}const d={};for(const b in a){const e=a[b];e in d||(d[e]=[]),d[e].push(r[b])}let p=Object.keys(d).map((e=>parseInt(e,10))).sort(Em);this.layers=[];for(const b of p){const e=d[b];e.sort(((e,t)=>{const n=o[e.id],a=o[t.id];return n<a?-1:n>a?1:0}));for(const t of e)t instanceof gv&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map((e=>parseInt(e,10))).sort(Em);const f=this.inputs.slice(),g=[];for(const b of p)for(const e of h[b]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new hm("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(t.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(g));for(const t of e.outputTensors)f.push(t);g.push(t.name)}}this.nodesByDepth=h;const m=this.layers.map((e=>e.name));for(const b of m){const e=m.filter((e=>e===b)).length;if(1!==e)throw new hm('The name "'.concat(b,'" is used ').concat(e," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new ny({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new dm("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let a=0;const r=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);r&&this.parseWeights(e);for(const s of this.layers)for(const[e,t]of s.weights.entries()){const o=r?"".concat(t.name.split("/").slice(0,-1).join("/")+"/").concat(e):t.originalName;if(null!=n[o])throw new dm("Duplicate weight name: ".concat(o));n[o]=t,a++}const o=[];for(const s in e){let a=s;if(null==n[s]){const e=s.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[a])o.push([n[a],e[s]]);else if(t)throw new dm("Provided weight data has no target variable: ".concat(s));delete n[a]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new dm("".concat(e.length," of ").concat(a," weights are not set: ")+"".concat(e))}Qb(o)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),a=["vars","layer_checkpoint_dependencies"],r=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!a.includes(e))).join("/");r!==t&&(e[r]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers ".concat(fv),t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=pv(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return oi((()=>{e=xm(e);const n=new iy;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return uy(this.outputs,n,t)}))}computeMask(e,t){return oi((()=>{let n;return e=xm(e),n=null==t?mm(null,e.length):xm(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=Hb(e);if(t.length!==this.inputLayers.length)throw new dm("Invalid inputShape argument ".concat(e,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let s=0;s<t.length;s++){const e=this.inputLayers[s],a=t[s];n[e.name+"_0_0"]=a}const a=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Em);if(a.length>1)for(const s of a){const e=this.nodesByDepth[s];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const a=[];for(let s=0;s<t.inboundLayers.length;s++){const e=t.inboundLayers[s],r=t.nodeIndices[s],o=t.tensorIndices[s],i=n["".concat(e.name,"_").concat(r,"_").concat(o)];a.push(i)}const r=Hb(e.computeOutputShape(vm(a))),o=e.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++){n["".concat(e.name,"_").concat(o,"_").concat(t)]=r[t]}}}const r=[],o=[];for(let s=0;s<this.outputLayers.length;s++){const e=this.outputLayers[s],t=this.outputLayersNodeIndices[s],n=this.outputLayersTensorIndices[s],a="".concat(e.name,"_").concat(t,"_").concat(n);o.push(a)}for(let s=0;s<o.length;s++){const e=o[s];bm(e in n),r.push(n[e])}return vm(r)}runInternalGraph(e,t){null==t&&(t=mm(null,e.length));const n={};for(let i=0;i<this.inputs.length;++i){const a=this.inputs[i],r=e[i],o=t[i];n[a.id]=[r,o]}const a=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Em);for(const i of a){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer,a=t.inputTensors,r=t.outputTensors,o=new Array;for(const t of a)t.id in n&&o.push(n[t.id]);if(o.length===a.length){let a,s,i,l,c={};if(null!=t.callArgs&&(c=t.callArgs),1===o.length){const[t,n]=o[0];null==c.mask&&(c.mask=n),i=xm(e.call(t,c)),l=xm(e.computeMask(t,n)),a=[t],s=[n]}else a=o.map((e=>e[0])),s=o.map((e=>e[1])),null==c.mask&&(c.mask=s),i=xm(e.call(a,c)),l=xm(e.computeMask(a,s));if(e.activityRegularizer)throw new pm("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<r.length;++e){const t=r[e],a=i[e],o=l[e];n[t.id]=[a,o]}}}}const r=[],o=[],s=[];for(const i of this.outputs){bm(i.id in n,"Could not compute output ".concat(i.name," : ").concat(i.id));const[e,t]=n[i.id];s.push(e.shape),r.push(e),o.push(t)}return[r,o,s]}buildNodeConversionMap(e){const t={};let n;for(const a of this.layers){n=a instanceof gv?1:0;for(let e=0;e<a.inboundNodes.length;e++){const r=gv.nodeKey(a,e);this.containerNodes.has(r)&&(t[r]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new dm("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new dm("No such layer: ".concat(e))}findLayer(e){if(this.layers.length<=e)throw new dm("Was asked to retrieve layer at index ".concat(e,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[e]}calculateLosses(){return oi((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const a=gv.nodeKey(t,n);this.containerNodes.has(a)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const o of this.layers){const e=o.getClassName(),a=o.getConfig(),r=[];for(let n=0;n<o.inboundNodes.length;n++){const e=o.inboundNodes[n],a=gv.nodeKey(o,n);let s={};if(this.containerNodes.has(a)){if(e.callArgs)try{JSON.stringify(e.callArgs),s=e.callArgs}catch(CW){console.warn("Layer ".concat(o.name," was passed ")+"non-serializable keyword arguments: "+"".concat(e.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),s={}}if(e.inboundLayers.length>0){const n=[];for(let a=0;a<e.inboundLayers.length;a++){const r=e.inboundLayers[a],o=e.nodeIndices[a],i=e.tensorIndices[a];let l=t[gv.nodeKey(r,o)];null==l&&(l=0),n.push([r.name,l,i,s])}r.push(n)}}}const s={};s.name=o.name,s.className=e,s.config=a,s.inboundNodes=r,n.push(s)}e.layers=n;const a=[];for(let o=0;o<this.inputLayers.length;o++){const e=this.inputLayers[o],n=this.inputLayersNodeIndices[o],r=gv.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let s=t[r];null!==s&&void 0!==s||(s=0);const i=this.inputLayersTensorIndices[o];a.push([e.name,s,i])}e.inputLayers=a;const r=[];for(let o=0;o<this.outputLayers.length;o++){const e=this.outputLayers[o],n=this.outputLayersNodeIndices[o],a=gv.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let s=t[a];null!==s&&void 0!==s||(s=0);const i=this.outputLayersTensorIndices[o];r.push([e.name,s,i])}return e.outputLayers=r,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={},r={};function o(e,t){e.name in r?r[e.name].push(t):r[e.name]=[t]}function s(e,t){const n=[];let r;for(const s of t){const i=s[0],l=s[1],c=s[2];if(r=null==s[3]?{}:s[3],!(i in a))return void o(e,t);const u=a[i];if(u.inboundNodes.length<=l)return void o(e,t);const h=u.inboundNodes[l];n.push(h.outputTensors[c])}n.length>0&&e.apply(vm(n),r)}function i(e){const r=e.name,s=Ly(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(n),a[r]=s;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new dm("Corrupted configuration, expected array for nodeData: ".concat(e));o(s,e)}))}const l=t.name,c=t.layers;for(const f of c)i(f);for(;!Rm(r);)for(const e of c){const t=a[e.name];if(t.name in r){const e=r[t.name];delete r[t.name];for(const n of e)s(t,n)}}const u=[],h=[],d=t.inputLayers;for(const f of d){const e=f[0],t=f[1],n=f[2];bm(e in a);const r=a[e].inboundNodes[t].outputTensors;u.push(r[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];bm(e in a);const r=a[e].inboundNodes[t].outputTensors;h.push(r[n])}return new e({inputs:u,outputs:h,name:l})}get stateful(){if(this._stateful)throw new dm("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){oi((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function mv(e,t,n){const a=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===a)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error("Provided ".concat(n," is an array of ").concat(e.length," ")+"element(s), but the model has ".concat(a," outputs. ")+"Make sure a set of weights is provided for each model output.");return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error("The model has multiple (".concat(a,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(a," elements or an object with ").concat(t," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(e)))}function bv(e,t){return mv(e,t,"classWeight")}async function yv(e,t,n,a){if(null!=t||null!=a)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=oi((()=>{if(1===e.shape.length)return $i(e);if(2===e.shape.length){if(e.shape[1]>1){return ic(e,1)}if(1===e.shape[1])return Sc(e,[e.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),a=Array.from(await t.data());si(t);const r=[];return a.forEach((e=>{if(null==n[e])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(e," exists in the data but not in ")+"classWeight");r.push(n[e])})),nh(r,"float32")}return null}function vv(e,t){return tl(e,t)}function xv(e,t){let n,a;const r=t;n=r.xs,a=r.ys,Ft(null!=n&&null!=a,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(t)));const o=wv("input",e.inputNames,n),s=wv("output",e.outputNames,a),i=o[0].shape[0];Ft(o.length===e.inputs.length,(()=>"LayersModel has ".concat(e.inputs.length," inputs, but the dataset ")+"provides ".concat(o.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(e.inputNames),")"))),Ft(s.length===e.outputs.length,(()=>"LayersModel has ".concat(e.outputs.length," outputs, but the dataset ")+"provides ".concat(s.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(e.outputNames),")")));for(let l=0;l<o.length;l++)Ft(o[l].shape[0]===i,(()=>"Batch size mismatch: input "+"".concat(e.inputNames[l]," has ").concat(o[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(e.inputNames[0],".")));for(let l=0;l<s.length;l++)Ft(s[l].shape[0]===i,(()=>"Batch size mismatch: output "+"".concat(e.outputNames[l]," has ").concat(s[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(e.inputNames[0],".")));return{xs:o,ys:s}}function wv(e,t,n){if(n instanceof vs)return[n];if(Array.isArray(n))return Ft(n.length===t.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(t.length," to match the ").concat(e," keys ").concat(t,"."))),n;{const a=[];for(const r of t){if(null==n[r])throw new dm("The feature data generated by the dataset lacks the required "+"".concat(e," key '").concat(r,"'."));a.push(n[r])}return a}}async function kv(e,t,n){const a=null!=n.batchesPerEpoch;if(Ft(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Ft(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Ft(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),Ft(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),Ft(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const r=null!=n.validationData;let o,s;if(r)if(Sv(n.validationData))Ft(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const e=function(e){if(3===e.length)throw new pm("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);o=e.xs,s=e.ys}const i=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let c;c=r?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const u=Dy(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=Oy(u,h,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,r,c);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,g=await t.iterator();for(;f<n.epochs;){const c={};await d.onEpochBegin(f);let u=0,h=0;for(a||(g=await t.iterator());!a||u<n.batchesPerEpoch;){const t=await g.next();if(a&&t.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:a,ys:r}=xv(e,t.value),o={};o.batch=h,o.size=a[0].shape[0],await d.onBatchBegin(h,o);const s=[];if(null!=n.classWeight){const t=bv(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)s.push(await yv(r[e],null,t[e]))}const c=a.concat(r).concat(s),p=i(c);si(c);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];o[t]=n,ii(n)}await d.onBatchEnd(h,o),Cy(o),h++,u++}if(a?u>=n.batchesPerEpoch:t.done){if(r){let t;t=Sv(n.validationData)?xm(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):xm(e.evaluate(o,s,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)c["val_".concat(e.metricsNames[n])]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,c),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Sv(e){return"function"===typeof e.iterator}function Iv(e){Ft(e>0&&Number.isInteger(e),(()=>"batchSize is required to be a positive integer, but got ".concat(e)))}function Cv(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>lb(e,t,n-t))):lb(e,t,n-t)}function Nv(e,t){return oi((()=>null==e?null:Array.isArray(e)?e.map((e=>Nv(e,t))):mb(e,"int32"===t.dtype?t:Ji(t,"int32"))))}function Ev(e,t){const n=[];let a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}function Tv(e){const t=[];e instanceof vs&&(e=[e]);for(let n=0;n<e.length;++n){const a=e[n];if(1===a.rank)t.push(ib(a,1));else{if(0===a.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function Rv(e,t){if(null==e)return;const n=[];if(t instanceof vs)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const r in t){const e=t[r];n.push(e.id)}const a=[];if(e instanceof vs)-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&a.push(e)}));else if(null!=e)for(const r in e){const t=e[r];-1===n.indexOf(t.id)&&a.push(t)}a.forEach((e=>{e.isDisposed||e.dispose()}))}function Av(e){return Array.isArray(e)}function Fv(e){return!function(e){return e instanceof vs}(e)&&!Av(e)}function Dv(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(Av(e)&&e.length>0)t=!0;else if(Fv(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new dm("Error when checking model ".concat(o," expected no data, ")+"but got ".concat(e))}return[]}if(null==e)return t.map((e=>null));if(Fv(e)){a=[];for(const n of t){if(null==e[n])throw new dm('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(t));a.push(e[n])}}else if(Av(e)){if(e.length!==t.length)throw new dm("Error when checking model ".concat(o,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(t.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(e));a=e}else{if(t.length>1)throw new dm("The model ".concat(o," expects ").concat(t.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(e.shape));a=[e]}if(a=Tv(a),null!=n)for(let s=0;s<t.length;++s){if(null==n[s])continue;const e=a[s];if(e.shape.length!==n[s].length)throw new dm("Error when checking ".concat(o,": expected ").concat(t[s]," ")+"to have ".concat(n[s].length," dimension(s). but got array with ")+"shape ".concat(e.shape));for(let t=0;t<n[s].length;++t){if(0===t&&!r)continue;const a=e.shape[t],i=n[s][t];if(null!=i&&i>=0&&a!==i)throw new dm("".concat(o," expected a batch of elements where each ")+"example has shape [".concat(n[s].slice(1,n[s].length),"] ")+"(i.e.,tensor shape [*,".concat(n[s].slice(1,n[s].length),"])")+" but the ".concat(o," received an input with ").concat(e.shape[0])+" examples, each with shape [".concat(e.shape.slice(1,e.shape.length),"]")+" (tensor shape [".concat(e.shape,"])"))}}return a}function _v(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new dm("Error when checking model ".concat(o,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(t.length," Tensor(s),")+" but instead got ".concat(e.length," Tensors(s)."));a=e}else{if(t.length>1)throw new dm("The model expects ".concat(t.length," ").concat(o," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(e.shape),"."));a=[e]}if(null!=n)for(let s=0;s<t.length;++s){if(null==n[s])continue;const e=a[s];if(e.shape.length!==n[s].length)throw new dm("Error when checking ".concat(o,": expected ").concat(t[s]," ")+"to have ".concat(n[s].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(e.shape)));for(let a=0;a<n[s].length;++a){if(0===a&&!r)continue;const i=e.shape[a],l=n[s][a];if(null!=l&&l!==i)throw new dm("Error when checking ".concat(o,": expected ")+"".concat(t[s]," to have shape ").concat(JSON.stringify(n[s])," but ")+"got array with shape ".concat(JSON.stringify(e.shape),"."))}}}class Ov extends gv{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new dm("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");iv(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>dd.adagrad(.01),Adadelta:()=>dd.adadelta(1,.95,ob()),Adam:()=>dd.adam(.001,.9,.999,ob()),Adamax:()=>dd.adamax(.002,.9,.999,ob(),0),RMSProp:()=>dd.rmsprop(.001,.9,0,ob()),SGD:()=>dd.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new dm("Unknown Optimizer ".concat(e))}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof dl))throw new dm("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new dm("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(e.loss,"."));const n=e.loss;t=n.map((e=>qy(e)))}else{const n=qy(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new dm('Unknown entry in loss dictionary: "'.concat(t,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==e.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),t.push(qy(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const e=this.internalOutputShapes[o],t=this.outputNames[o];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[o])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ym("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const a=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(e));n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const a of t){let t=n.hasOwnProperty(a)?n[a]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),r=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};Ym("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,a,o;for(const s of t){if("string"===typeof s&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(s)){const t=this.internalOutputShapes[e];let r;1===t[t.length-1]||this.lossFunctions[e]===Gy?-1!==["accuracy","acc"].indexOf(s)?a=Xy:-1!==["crossentropy","ce"].indexOf(s)&&(a=$y):this.lossFunctions[e]===Vy?-1!==["accuracy","acc"].indexOf(s)?a=Qy:-1!==["crossentropy","ce"].indexOf(s)&&(a=ev):-1!==["accuracy","acc"].indexOf(s)?a=Yy:-1!==["crossentropy","ce"].indexOf(s)&&(a=Zy),-1!==["accuracy","acc"].indexOf(s)?r="acc":-1!==["crossentropy","ce"].indexOf(s)&&(r="ce"),o=a,n=""+r}else{const e=nv(s);o=e,n=""+av(s)}let t;Ym(n,(()=>{t=o})),r(e,n,t)}})(a[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=null==n.batchSize?32:n.batchSize;Iv(a);const r=this.standardizeUserDataXY(e,t,!0,a);try{const e=r[0].concat(r[1]);this.makeTestFunction();const t=this.testFunction;return vm(this.testLoop(t,e,a,n.verbose,n.steps))}finally{Rv(r[0],e),Rv(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const a=null!=(n=n||{}).batches,r=e.testFunction;let o=[];if(n.verbose>0)throw new pm("Verbose mode is not implemented yet.");Ft(!a||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const s="function"===typeof t.next?t:await t.iterator();let i=0,l=0;for(;!a||l<n.batches;){const t=await s.next();if(o=oi((()=>{if(t.value){const{xs:n,ys:a}=xv(e,t.value),s=n.concat(a),c=oi((()=>r(s)));if(si(s),0===l)for(let e=0;e<c.length;++e)o.push(sl(0));const u=s[0].shape[0];for(let e=0;e<c.length;++e){const t=c[e],n=o[e];o[e]=oi((()=>Qi(o[e],tl(u,t)))),l>0&&si(n)}si(c),i+=u,++l}return o})),t.done){a&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let c=0;c<o.length;++c){const e=o[c];o[c]=el(o[c],i),si(e)}return vm(o)}(this,e,t)}checkNumSamples(e,t,n){let a,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(a=null,null!=t)throw new dm("If ".concat(r," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(t))}else{if(null==e)throw new dm("Either the input data should have a defined shape, or "+"".concat(r," shoud be specified."));a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new dm("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),o=new iy;if(e instanceof vs&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new dm("The number of inputs provided (".concat(e.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let t=0;t<this.inputs.length;++t)o.add(this.inputs[t],e[t])}else for(const i of this.inputs){const t=e[i.name];if(null==t)throw new dm("No value is provided for the model's input ".concat(i.name));o.add(i,t)}const s=uy(r,o);return n?s:s[0]}retrieveSymbolicTensors(e){const t=mm(null,e.length);let n=e.length;for(const a of this.layers){const r=Array.isArray(a.output)?a.output:[a.output],o=r.map((e=>e.name));for(let a=0;a<e.length;++a){const s=o.indexOf(e[a]);if(-1!==s&&(t[a]=r[s],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,a)=>{null==t&&n.push(e[a])})),new dm("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return oi((()=>{const a=this.checkNumSamples(e);if(n)throw new pm("Verbose predictLoop() is not implemented yet.");const r=Ev(a,t),o=this.outputs.map((e=>[]));for(let t=0;t<r.length;++t){const n=oi((()=>{const n=r[t][0],a=r[t][1],o=Cv(e,n,a),s=[];if(Array.isArray(o))for(let e=0;e<o.length;++e)s.push({key:this.inputs[e],value:o[e]});else s.push({key:this.inputs[0],value:o});const i=new iy(s);return uy(this.outputs,i)}));n.forEach(((e,t)=>o[t].push(e)))}return vm(o.map((e=>Dc(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Tv(e);_v(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return Iv(e),this.predictLoop(n,e)}finally{Rv(n,e)}}predictOnBatch(e){_v(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new hm("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let r=0;r<this.feedOutputShapes.length;++r){const e=this.feedOutputShapes[r];this.feedLossFns[r]===Vy?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(function(e,t){const n=Tm(e.map((e=>e.shape[0])));n.sort();const a=Tm(t.map((e=>e.shape[0])));if(a.sort(),n.length>1)throw new dm("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((e=>e.shape)))));if(a.length>1)throw new dm("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((e=>e.shape)))));if(n.length>0&&a.length>0&&!Lt(n,a))throw new dm("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(n[0]," input sample(s) and ").concat(a[0]," target ")+"sample(s).")}(e=Dv(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Dv(t,this.feedOutputNames,a,!1,"target")),function(e,t,n){const a=[My,Gy,Uy];for(let r=0;r<e.length;++r){const o=e[r],s=t[r],i=n[r];if(null!=s){if(s===Uy&&1===o.shape[o.shape.length-1])throw new dm("You are passing a target array of shape ".concat(o.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==a.indexOf(s)){const e=o.shape.slice(1),t=i.slice(1);for(let n=0;n<e.length;++n){const a=e[n],r=t[n];if(null!=r&&a!==r)throw new dm("A target Tensor with shape ".concat(o.shape," was passed for an ")+"output of shape ".concat(i,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new dm("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(e[0].shape[0]," sample(s)."));return[e,t]}async standardizeUserData(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],o=arguments.length>5?arguments[5]:void 0;const[s,i]=this.standardizeUserDataXY(e,t,r,o);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=a){const e=bv(a,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await yv(i[t],null,e[t]))}return[s,i,l]}testLoop(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4?arguments[4]:void 0;return oi((()=>{const o=this.checkNumSamples(t,n,r,"steps"),s=[];if(a>0)throw new pm("Verbose mode is not implemented yet.");if(null!=r)throw new pm("steps mode in testLoop() is not implemented yet");{const a=Ev(o,n),r=nh(ab(0,o));for(let n=0;n<a.length;++n){const o=a[n][0],i=a[n][1],l=lb(r,o,i-o),c=Nv(t,l),u=e(c);if(0===n)for(let e=0;e<u.length;++e)s.push(sl(0));for(let e=0;e<u.length;++e){const t=u[e];s[e]=Qi(s[e],tl(i-o,t))}}for(let e=0;e<s.length;++e)s[e]=el(s[e],o)}return s}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const a=e[n];let r=a;if(ym(e,a)>1){const t=ym(e.slice(0,n),a);r+="_".concat(t)}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),o=[],s=this.collectedTrainableWeights.map((e=>e.read())),i=this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const s=new iy(e),i=uy(this.outputs,s,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(a[n],i[n]);null!=r[n]&&(e=vv(e,r[n]));const o=ku(e);t.push(o),l=0===n?e:Qi(l,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],r=this.metricsTensors[n][1];e=ku(t(a[r],i[r]))}ii(e),o.push(e)}return l=ku(l),this.calculateLosses().forEach((e=>{l=Qi(l,e)})),l}),!0,s);return[i].concat(o)}}makeTestFunction(){this.testFunction=e=>oi((()=>{const t=[];let n;const a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let e=0;e<this.inputs.length;++e)o.push({key:this.inputs[e],value:a[e]});const s=new iy(o),i=uy(this.outputs,s);for(let e=0;e<this.lossFunctions.length;++e){const a=this.lossFunctions[e],o=ku(a(r[e],i[e]));n=0===e?o:Qi(n,o),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],a=this.metricsTensors[e][1],o=ku(n(r[a],i[a]));t.push(o)}return t}))}async fit(e,t){let n,a,r,o,s,i,l,c,u,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const d=null==h.batchSize?32:h.batchSize;Iv(d);const p=!1,f=await this.standardizeUserData(e,t,h.sampleWeight,h.classWeight,p,d);n=f[0],a=f[1],u=f[2];let g,m=!1;if(null!=h.validationData&&h.validationData.length>0){if(m=!0,2!==h.validationData.length)throw 3===h.validationData.length?new pm("validationData including sample weights is not supported yet."):new dm("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(h.validationData," is invalid."));s=h.validationData[0],i=h.validationData[1];const e=!0,t=await this.standardizeUserData(s,i,null,null,e,d);l=t[0],c=t[1],g=l.concat(c)}else if(null!=h.validationSplit&&h.validationSplit>0&&h.validationSplit<1){m=!0;const e=Math.floor(n[0].shape[0]*(1-h.validationSplit)),t=n[0].shape[0];l=Cv(n,e,t),r=n,n=Cv(n,0,e),c=Cv(a,e,t),o=a,a=Cv(a,0,e),g=l.concat(c)}else null!=h.validationSteps&&(m=!0);const b=n.concat(a).concat(u);this.checkTrainableWeightsConsistency();const y=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let x,w;m?(this.makeTestFunction(),x=this.testFunction,w=v.slice().concat(v.map((e=>"val_"+e)))):(x=null,g=[],w=v.slice());const k=Dy(h.callbacks,h.yieldEvery);return await this.fitLoop(y,b,v,d,h.epochs,h.verbose,k,x,g,h.shuffle,w,h.initialEpoch,null,null)}finally{this.isTraining=!1,Rv(n,e),Rv(a,t),Rv(r,e),Rv(o,t),Rv(l,s),Rv(c,i),null!=u&&si(u)}}async fitLoop(e,t,n,a,r,o,s,i,l,c,u,h,d,p){null==a&&(a=32),null==r&&(r=1),null==c&&(c=!0),null==h&&(h=0);let f=!1;if(null!=i&&null!=l&&(f=!0),null!=p&&(f=!0,null==d))throw new dm("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(t,a,d,"steps_per_epoch");let m;null!=g&&(m=ab(0,g)),null==o&&(o=1);const{callbackList:b,history:y}=Oy(s,o,r,h,g,d,a,f,u);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let v=h;v<r;++v){await b.onEpochBegin(v);const r={};if(null!=d)throw new pm("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new pm("batch shuffling is not implemneted yet");c&&Et(m);const o=nh(m),s=Ev(g,a);for(let c=0;c<s.length;++c){const u={};if(await b.onBatchBegin(c,u),oi((()=>{const h=s[c][0],d=s[c][1],p=lb(o,h,d-h);u.batch=c,u.size=d-h;const g=Nv(t,p),m=e(g);for(let e=0;e<n.length;++e){const t=n[e],a=m[e];u[t]=a,ii(a)}if(c===s.length-1&&f){const e=this.testLoop(i,l,a);for(let t=0;t<n.length;++t){const a=n[t],o=e[t];ii(o),r["val_"+a]=o}}})),await b.onBatchEnd(c,u),Cy(u),this.stopTraining_)break}o.dispose()}if(await b.onEpochEnd(v,r),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return kv(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),a=n[0],r=n[1],o=this.makeTrainFunction()(a.concat(r)),s=[];for(const i of o){const e=await i.data();s.push(e[0])}return si(o),Rv(n[0],e),Rv(n[1],t),vm(s)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let o=0;o<a.length;++o)n&&!a[o].trainable||t.push({name:a[o].originalName,tensor:r[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=ri().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-ri().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=wm(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>wm(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const a of t){if("string"!==typeof n[a])throw new Error("Serialization of non-string loss is not supported.");e[a]=wm(n[a])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[wm(av(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>wm(av(e))));{const e={};for(const t in this.metrics)e[t]=wm(av(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Ly(dv(e.optimizer_config));let n,a;if("string"===typeof e.loss)n=km(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>km(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=km(e.loss[t])}if(Array.isArray(e.metrics))a=e.metrics.map((e=>km(e)));else if(null!=e.metrics){a={};for(const t in e.metrics)a[t]=km(e.metrics[t])}this.compile({loss:n,metrics:a,optimizer:t})}async save(e,t){if("string"===typeof e){const t=(n=e,wi.getSaveHandlers(n));if(0===t.length)throw new dm("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new dm("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}var n;if(null==e.save)throw new dm("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const a=await ui(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(fv),convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:n}=await ui(await this.optimizer.getWeights(),e);a.specs.push(...n),a.data=(o=[a.data,t],ni.join(o))}var o;if(null!=this.userDefinedMetadata){const e=!0;ov(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=a.data,r.weightSpecs=a.specs,e.save(r)}setUserDefinedMetadata(e){ov(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Ov.className="Model",hl(Ov);class Lv extends Ov{}async function zv(e,t){if(null==t&&(t={}),"string"===typeof e){const r=(n=e,a=t,wi.getLoadHandlers(n,a));if(0===r.length)r.push(function(e,t){return zl(e,t)}(e,t));else if(r.length>1)throw new dm("Found more than one (".concat(r.length,") load handlers for ")+"URL '".concat(e,"'"));e=r[0]}var n,a;return async function(e,t,n){null==n&&(n={});if(null==e.load)throw new dm("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const a=await e.load();let r=a.modelTopology;null!=r.model_config&&(r=r.model_config);const o=null==n.strict||n.strict,s=null!=a.weightData&&null!=a.weightSpecs&&o,i=Ly(dv(r),t,s),l=a.trainingConfig;null!=l&&i.loadTrainingConfig(l);null!=a.userDefinedMetadata&&i.setUserDefinedMetadata(a.userDefinedMetadata);if(null!=a.weightData){if(null==a.weightSpecs)throw new dm("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=function(e,t){const n=hi(e,t),a={},r=[];return t.forEach((e=>{"optimizer"===e.group?r.push({name:e.name,tensor:n[e.name]}):a[e.name]=n[e.name]})),{modelWeights:a,optimizerWeights:r}}(a.weightData,a.weightSpecs);i.loadWeights(e,o),null!=i.optimizer&&t.length>0&&await i.optimizer.setWeights(t),si(e),si(t.map((e=>e.tensor)))}return i}(e,void 0,t)}Lv.className="Functional",hl(Lv);class Mv extends Ov{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Pm("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new dm("Negative dimension size caused by adding layer "+"".concat(e.name," with input shape [")+"".concat(e.inboundNodes[0].inputTensors[0].shape,"]"))}add(e){const t=e instanceof Mv||e instanceof Ov;let n;if(t){if(n=e,1!==n.outputs.length)throw new dm("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new dm("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new dm("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new dm("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new sy({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new dm("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(e.name," ")+"which has ".concat(e.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new dm("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=oy(this.outputs[0])}this.inboundNodes=[],new ny({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:mm(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(qb(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ov({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new hm("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new hm("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new hm("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new hm("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new dm("Legacy serialization format not supported yet.");n=t}else Ft(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,r=t;const o=new e(r);if(!(o instanceof Mv))throw new pm("Sequential.fromConfig called on non-Sequential input: ".concat(o));for(const s of n){const e=Ly(s,void 0,a);a&&e.setFastWeightInitDuringBuild(!0),o.add(e)}return o}set stopTraining(e){if(null==this.model)throw new dm("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new dm("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}Mv.className="Sequential",hl(Mv);class Pv extends cl{getConfig(){return{}}}class Bv extends Pv{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new pm("Support for alpha values other than 1 (".concat(t,") is not implemented ")+"yet.");return Kc(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}Bv.className="elu",hl(Bv);class Wv extends Pv{apply(e){return Vu(e)}}Wv.className="selu",hl(Wv);class Uv extends Pv{apply(e){return Wu(e)}}Uv.className="relu",hl(Uv);class Vv extends Pv{apply(e){return oi((()=>Iu(6,Wu(e))))}}Vv.className="relu6",hl(Vv);class Gv extends Pv{apply(e){return e}}Gv.className="linear",hl(Gv);class jv extends Pv{apply(e){return ju(e)}}jv.className="sigmoid",hl(jv);class Hv extends Pv{apply(e){return function(e){return oi((()=>{const t=Qi(.5,tl(.2,e));return Fc(t,0,1)}))}(e)}}Hv.className="hardSigmoid",hl(Hv);class Kv extends Pv{apply(e){return $u(e)}}Kv.className="softplus",hl(Kv);class qv extends Pv{apply(e){return function(e){return oi((()=>el(e,Qi(vl(e),1))))}(e)}}qv.className="softsign",hl(qv);class Xv extends Pv{apply(e){return th(e)}}Xv.className="tanh",hl(Xv);class Yv extends Pv{apply(e){return Ju(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}Yv.className="softmax",hl(Yv);class Jv extends Pv{apply(e){return lu(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}Jv.className="logSoftmax",hl(Jv);class $v extends Pv{apply(e){return oi((()=>oi((()=>{const t=Math.sqrt(2),n=tl(.5,Qi(1,Xc(el(e,t))));return tl(e,n)}))))}}$v.className="gelu",hl($v);class Qv extends Pv{apply(e){return oi((()=>tl(.5,tl(e,Qi(1,th(tl(nl(el(2,Math.PI)),Qi(e,tl(.044715,ml(e,3))))))))))}}Qv.className="gelu_new",hl(Qv);class Zv extends Pv{apply(e){return oi((()=>tl(e,th($u(e)))))}}Zv.className="mish",hl(Zv);class ex extends Pv{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return oi((()=>tl(ju(tl(e,t)),e)))}}function tx(e){return e.getClassName()}function nx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Nm(e,ul.getMap().classNameMap,t,"activation")}function ax(e){if(null==e){const e={className:"linear",config:{}};return nx(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},nx(t)}return e instanceof Pv?e:nx(e)}function rx(e){if(null!=e&&"object"!==typeof e)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(e))}ex.className="swish",hl(ex);class ox extends cl{}class sx extends ox{constructor(e){super(),rx(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return oi((()=>{let t=Ru([1]);return this.hasL1&&(t=Qi(t,iu(tl(this.l1,vl(e))))),this.hasL2&&(t=Qi(t,iu(tl(this.l2,bb(e))))),Sc(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}sx.className="L1L2",hl(sx);const ix={l1l2:"L1L2"};function lx(e){return Im(e)}function cx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Nm(e,ul.getMap().classNameMap,t,"regularizer")}function ux(e){if(null==e)return null;if("string"===typeof e){return cx({className:e in ix?ix[e]:e,config:{}})}return e instanceof ox?e:cx(e)}class hx extends ry{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=Kb(e);let n=Wu(e);return null!=this.maxValue&&(n=Fc(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}hx.className="ReLU",hl(hx);class dx extends ry{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Kb(e);return au(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}dx.className="LeakyReLU",hl(dx);class px extends ry{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Gb(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ux(e.alphaRegularizer),this.alphaConstraint=Sy(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new dm("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(e.sharedAxes));this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=qb(e)).slice(1);if(null!=this.sharedAxes)for(const a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new Zb({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Kb(e),_u(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Vb(this.alphaInitializer),alphaRegularizer:lx(this.alphaRegularizer),alphaConstraint:wy(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}px.className="PReLU",hl(px);class fx extends ry{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new pm("Non-default alpha value (".concat(e.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Kb(e);return Kc(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}fx.className="ELU",hl(fx);class gx extends ry{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=Kb(e);return tl(n,Ji(tu(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}gx.className="ThresholdedReLU",hl(gx);class mx extends ry{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Yv).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return oi((()=>{let n=Kb(e);const a=t.mask;if(null!=a){const e=tl(bl(Au(n.shape),Ji(a,n.dtype)),sl(-1e9));n=Qi(n,e)}return this.axis instanceof Array?this.axis.length>1?Yc(bl(n,bu(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function bx(e,t,n){if("number"===typeof e)return mm(e,t);if(e.length!==t)throw new dm("The ".concat(n," argument must be an integer or tuple of ").concat(t," integers.")+" Received: ".concat(e.length," elements."));for(let r=0;r<t;++r){const o=e[r];if((a=o)!==parseInt(a.toString(),10))throw new dm("The ".concat(n," argument must be an integer or tuple of ").concat(t)+" integers. Received: ".concat(JSON.stringify(e)," including a")+" non-integer number ".concat(o))}return e;var a}function yx(e,t,n,a){if(null==e)return e;let r;return r="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((r+a-1)/a)}function vx(e,t,n,a){if(null==e)return null;if("valid"===a)e=e*t+nb([n-t,0]);else{if("same"!==a)throw new dm("Unsupport padding mode: ".concat(a,"."));e*=t}return e}function xx(e,t){return oi((()=>(Hm(t),"channelsFirst"===t?ch(e,[0,2,3,1]):e)))}function wx(e,t){return oi((()=>(Hm(t),"channelsFirst"===t?ch(e,[0,2,3,4,1]):e)))}function kx(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return oi((()=>{if(null==o&&(o="channelsLast"),Hm(o),3!==e.shape.length)throw new dm("The input of a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead."));if(3!==t.shape.length)throw new dm("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new dm("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(n.shape.length," instead"));if("channelsFirst"===o&&(e=ch(e,[0,2,1])),"causal"===r)throw new pm("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=Pc(e,t,a,"same"===r?"same":"valid","NWC",s);return null!=n&&(i=vb(i,n)),i}))}function Sx(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,s=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return oi((()=>{if(null==o&&(o="channelsLast"),Hm(o),3!==e.rank&&4!==e.rank)throw new dm("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));if(3!==t.rank&&4!==t.rank)throw new dm("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));let l=xx(e,o);if("causal"===r)throw new pm("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=kh({x:l,filter:t,strides:a,pad:"same"===r?"same":"valid",dilations:s,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===o&&(l=ch(l,[0,3,1,2])),l}))}function Ix(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,s=arguments.length>6?arguments[6]:void 0;return oi((()=>{if(null==o&&(o="channelsLast"),Hm(o),4!==e.rank&&5!==e.rank)throw new dm("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(e.rank,"."));if(4!==t.rank&&5!==t.rank)throw new dm("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(e.rank,"."));let i=wx(e,o);if("causal"===r)throw new pm("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=Uc(i,t,a,"same"===r?"same":"valid","NDHWC",s),null!=n&&(i=vb(i,n)),"channelsFirst"===o&&(i=ch(i,[0,4,1,2,3])),i}))}mx.className="Softmax",hl(mx);class Cx extends ry{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Cx.verifyArgs(t),this.rank=e,Dm(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new pm("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=bx(t.kernelSize,e,"kernelSize"),this.strides=bx(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,Km(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Hm(this.dataFormat),this.activation=ax(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=Gb(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Sy(t.biasConstraint),this.biasRegularizer=ux(t.biasRegularizer),this.activityRegularizer=ux(t.activityRegularizer),this.dilationRate=bx(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new dm("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new dm("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new dm("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(e){if(bm("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!Fm(e.kernelSize,"number",1,3))throw new dm("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize),"."))}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:tx(this.activation),useBias:this.useBias,biasInitializer:Vb(this.biasInitializer),biasRegularizer:lx(this.biasRegularizer),activityRegularizer:lx(this.activityRegularizer),biasConstraint:wy(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Nx extends Cx{constructor(e,t){super(e,t),this.kernel=null,Nx.verifyArgs(t),this.filters=t.filters,Dm(this.filters,"filters"),this.kernelInitializer=Gb(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Sy(t.kernelConstraint),this.kernelRegularizer=ux(t.kernelRegularizer)}build(e){e=qb(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new dm("The channel dimension of the input should be defined. "+"Found ".concat(e[t]));const n=e[t],a=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return oi((()=>{let t;e=Kb(e);const n=null==this.bias?null:this.bias.read(),a=Om(this.activation.getClassName());if(null!=a&&2===this.rank)t=Sx(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(1===this.rank)t=kx(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=Sx(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new pm("convolutions greater than 3D are not implemented yet.");t=Ix(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=qb(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<n.length;++r){const e=yx(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(e)}let a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t),a.push(this.filters)):(a.push(this.filters),a=a.concat(t)),a}getConfig(){const e={filters:this.filters,kernelInitializer:Vb(this.kernelInitializer),kernelRegularizer:lx(this.kernelRegularizer),kernelConstraint:wy(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new dm("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(e.filters)))}}class Ex extends Nx{constructor(e){super(2,e),Ex.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!Fm(e.kernelSize,"number",1,2))throw new dm("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize),"."))}}Ex.className="Conv2D",hl(Ex);class Tx extends Nx{constructor(e){super(3,e),Tx.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new dm("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(e.kernelSize),"."))}}Tx.className="Conv3D",hl(Tx);class Rx extends Ex{constructor(e){if(super(e),this.inputSpec=[new Zb({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new dm("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(4!==(e=qb(e)).length)throw new dm("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new dm("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Zb({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return oi((()=>{let t=Kb(e);if(4!==t.shape.length)throw new dm("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let r,o;"channelsFirst"===this.dataFormat?(r=2,o=3):(r=1,o=2);const s=n[r],i=n[o],l=this.kernelSize[0],c=this.kernelSize[1],u=this.strides[0],h=this.strides[1],d=[a,vx(s,u,l,this.padding),vx(i,h,c,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=ch(t,[0,2,3,1]));let p=Wc(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=ch(p,[0,3,1,2])),null!=this.bias&&(p=vb(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=qb(e)).slice();let n,a,r;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3):(n=3,a=1,r=2);const o=this.kernelSize[0],s=this.kernelSize[1],i=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[a]=vx(t[a],i,o,this.padding),t[r]=vx(t[r],l,s,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Rx.className="Conv2DTranspose",hl(Rx);class Ax extends Tx{constructor(e){if(super(e),this.inputSpec=[new Zb({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new dm("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(5!==(e=qb(e)).length)throw new dm("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new dm("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Zb({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return oi((()=>{let t=Kb(e);if(5!==t.shape.length)throw new dm("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let r,o,s;"channelsFirst"===this.dataFormat?(s=2,r=3,o=4):(s=1,r=2,o=3);const i=n[s],l=n[r],c=n[o],u=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],g=this.strides[2],m=[a,vx(i,p,u,this.padding),vx(l,f,h,this.padding),vx(c,g,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=ch(t,[0,2,3,4,1]));let b=Gc(t,this.kernel.read(),m,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=ch(b,[0,4,1,2,3])),null!==this.bias&&(b=vb(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(e){const t=(e=qb(e)).slice();let n,a,r,o;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3,o=4):(n=4,a=1,r=2,o=3);const s=this.kernelSize[0],i=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],u=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[a]=vx(t[a],c,s,this.padding),t[r]=vx(t[r],u,i,this.padding),t[o]=vx(t[o],h,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Ax.className="Conv3DTranspose",hl(Ax);class Fx extends Nx{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new dm("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new dm("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new dm("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(t.padding)));this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Gb(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ux(t.depthwiseRegularizer),this.depthwiseConstraint=Sy(t.depthwiseConstraint),this.pointwiseInitializer=Gb(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ux(t.pointwiseRegularizer),this.pointwiseConstraint=Sy(t.pointwiseConstraint)}build(e){if((e=qb(e)).length<this.rank+2)throw new dm("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(e)));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new dm("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(e[t])));const n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let s=0;s<this.rank;++s)r.push(1);r.push(n*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Zb({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return oi((()=>{let t;if(e=Kb(e),1===this.rank)throw new pm("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=ch(e,[0,2,3,1])),t=Gu(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=vb(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=ch(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Vb(this.depthwiseInitializer),e.pointwiseInitializer=Vb(this.pointwiseInitializer),e.depthwiseRegularizer=lx(this.depthwiseRegularizer),e.pointwiseRegularizer=lx(this.pointwiseRegularizer),e.depthwiseConstraint=wy(this.depthwiseConstraint),e.pointwiseConstraint=wy(this.pointwiseConstraint),e}}Fx.className="SeparableConv";class Dx extends Fx{constructor(e){super(2,e)}}Dx.className="SeparableConv2D",hl(Dx);class _x extends Nx{constructor(e){super(1,e),_x.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!Fm(e.kernelSize,"number",1,1))throw new dm("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(e.kernelSize),"."))}}_x.className="Conv1D",hl(_x);class Ox extends ry{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return oi((()=>{if(e=Kb(e),"channelsLast"===this.dataFormat){const t=ub(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return ub(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=ub(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return ub(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Ox.className="Cropping2D",hl(Ox);class Lx extends ry{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Hm(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,Am(Wm,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return oi((()=>{let t=Kb(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=ch(t,[0,2,3,1]);const e=this.size[0]*n[2],a=this.size[1]*n[3],r="nearest"===this.interpolation?ud.resizeNearestNeighbor(t,[e,a]):ud.resizeBilinear(t,[e,a]);return ch(r,[0,3,1,2])}{const e=this.size[0]*n[1],a=this.size[1]*n[2];return"nearest"===this.interpolation?ud.resizeNearestNeighbor(t,[e,a]):ud.resizeBilinear(t,[e,a])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Lx.className="UpSampling2D",hl(Lx);class zx extends Cx{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Gb(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Sy(e.depthwiseConstraint),this.depthwiseRegularizer=ux(e.depthwiseRegularizer)}build(e){if((e=qb(e)).length<4)throw new dm("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(e),"."));const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new dm("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(e[t],")."));const n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return oi((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",r=arguments.length>4?arguments[4]:void 0,o=arguments.length>5?arguments[5]:void 0;return oi((()=>{null==r&&(r="channelsLast"),Hm(r);let s=xx(e,r);if(4!==e.rank)throw new dm("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));if(4!==t.rank)throw new dm("depthwiseKernel is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));return s=Hc(s,t,n,"same"===a?"same":"valid","NHWC",o),"channelsFirst"===r&&(s=ch(s,[0,3,1,2])),s}))}(e=Kb(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=vb(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=qb(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=yx(t,this.kernelSize[0],this.padding,this.strides[0]),o=yx(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],a,r,o]:[e[0],r,o,a]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Vb(this.depthwiseInitializer),e.depthwiseRegularizer=lx(this.depthwiseRegularizer),e.depthwiseConstraint=wy(this.depthwiseRegularizer),e}}function Mx(e,t,n,a){if(Array.isArray(e)){if(null!=t||null!=n)throw new dm("When inputs is an array, neither initialState or constants should be provided");null!=a&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=r(t),constants:n=r(n)}}function Px(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4?arguments[4]:void 0,o=arguments.length>5?arguments[5]:void 0,s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return oi((()=>{const l=t.shape.length;if(l<3)throw new dm("Input should be at least 3D, but is ".concat(l,"D."));const c=[1,0].concat(ab(2,l));if(t=ch(t,c),null!=o)throw new pm("The rnn() functoin of the deeplearn.js backend does not support constants yet.");s&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&(r=Ji(Ji(r,"bool"),"float32"),r.rank===l-1&&(r=Jc(r,-1)),r=ch(r,c)),a&&(t=Uu(t,0),null!=r&&(r=Uu(r,0)));const u=[];let h,d=n;const p=t.shape[0],f=oh(t);let g,m;null!=r&&(g=oh(r));for(let t=0;t<p;++t){const n=f[t],a=oi((()=>e(n,d)));if(null==r)h=a[0],d=a[1];else{const e=oi((()=>{const e=g[t],n=bl(Fu(e),e),r=Qi(tl(a[0],e),tl(d[0],n)),o=d.map(((t,r)=>Qi(tl(a[1][r],e),tl(t,n))));return{output:r,newStates:o}}));h=e.output,d=e.newStates}i&&u.push(h)}if(i){m=eh(u,1)}return[h,m,d]}))}zx.className="DepthwiseConv2D",hl(zx);class Bx extends ry{constructor(e){let t;if(super(e),null==e.cell)throw new dm("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new qx({cells:e.cell}):e.cell,null==t.stateSize)throw new dm("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Zb({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return ab(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){jb(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let a;if(a=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const a of t)n.push([e[0],a]);return[a].concat(n)}return a}computeMask(e,t){return oi((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new pm("Constants support is not implemented in RNN yet.");jb(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Zb({shape:[t,null,...n]});const a=[e[0]].concat(e.slice(2));let r;if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Lt(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new dm("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=r.map((e=>new Zb({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];oi((()=>{if(!this.stateful)throw new um("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new dm("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>Ru([n,e]))):this.states_=[Ru([n,this.cell.stateSize])];else if(null==e)si(this.states_),null!=this.keptStates&&(si(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>Ru([n,e]))):this.states_[0]=Ru([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new dm("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));!0===t?this.keptStates.push(this.states_.slice()):si(this.states_);for(let t=0;t<this.states_.length;++t){const a=e[t],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,o=[n,r];if(!Lt(a.shape,o))throw new dm("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(o,", received shape=").concat(a.shape));this.states_[t]=a}}this.states_=this.states_.map((e=>ii(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=Mx(e,n,a,this.numConstants);e=r.inputs,n=r.initialState,a=r.constants;let o=[],s=[];if(null!=n){t.initialState=n,o=o.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new Zb({shape:e.shape}));s=s.concat(this.stateSpec)}null!=a&&(t.constants=a,o=o.concat(a),this.numConstants=a.length);if(o[0]instanceof ey){const n=[e].concat(o),a=this.inputSpec.concat(s),r=this.inputSpec;this.inputSpec=a;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return oi((()=>{const n=null==t?null:t.mask,a=null==t?null:t.training;let r=null==t?null:t.initialState;e=Kb(e),null==r&&(r=this.stateful?this.states_:this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==o)throw new dm("RNN Layer has ".concat(o," state(s) but was passed ")+"".concat(r.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const s={training:a},i=Px(((e,t)=>{const n=this.cell.call([e].concat(t),s);return[n[0],n.slice(1)]}),e,r,this.goBackwards,n,null,this.unroll,this.returnSequences),l=i[0],c=i[1],u=i[2];this.stateful&&this.resetStates(u,a);const h=this.returnSequences?c:l;return this.returnState?[h].concat(u):h}))}getInitialState(e){return oi((()=>{let t=Ru(e.shape);return t=iu(t,[1,2]),t=ib(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?pb(t,[1,e]):t)):this.cell.stateSize>1?[pb(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===Bx.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=Ly(t.cell,n);return new e(Object.assign(t,{cell:a}))}}Bx.className="RNN",hl(Bx);class Wx extends ry{}class Ux extends Wx{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Dm(this.units,"units"),this.activation=ax(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Gb(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Gb(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Gb(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ux(e.kernelRegularizer),this.recurrentRegularizer=ux(e.recurrentRegularizer),this.biasRegularizer=ux(e.biasRegularizer),this.kernelConstraint=Sy(e.kernelConstraint),this.recurrentConstraint=Sy(e.recurrentConstraint),this.biasConstraint=Sy(e.biasConstraint),this.dropout=tb([1,nb([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=tb([1,nb([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=qb(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return oi((()=>{if(2!==e.length)throw new dm("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length,"."));let n=e[1];e=e[0];const a=null!=t.training&&t.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Xx({ones:()=>Fu(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Xx({ones:()=>Fu(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,s=this.recurrentDropoutMask;r=gb(null!=o?tl(e,o):e,this.kernel.read()),null!=this.bias&&(r=vb(r,this.bias.read())),null!=s&&(n=tl(n,s));let i=Qi(r,gb(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:tx(this.activation),useBias:this.useBias,kernelInitializer:Vb(this.kernelInitializer),recurrentInitializer:Vb(this.recurrentInitializer),biasInitializer:Vb(this.biasInitializer),kernelRegularizer:lx(this.kernelRegularizer),recurrentRegularizer:lx(this.recurrentRegularizer),biasRegularizer:lx(this.biasRegularizer),activityRegularizer:lx(this.activityRegularizer),kernelConstraint:wy(this.kernelConstraint),recurrentConstraint:wy(this.recurrentConstraint),biasConstraint:wy(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}Ux.className="SimpleRNNCell",hl(Ux);class Vx extends Bx{constructor(e){e.cell=new Ux(e),super(e)}call(e,t){return oi((()=>{null!=this.cell.dropoutMask&&(si(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(si(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return new e(t)}}Vx.className="SimpleRNN",hl(Vx);class Gx extends Wx{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new dm("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Dm(this.units,"units"),this.activation=ax(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ax(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Gb(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Gb(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Gb(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ux(e.kernelRegularizer),this.recurrentRegularizer=ux(e.recurrentRegularizer),this.biasRegularizer=ux(e.biasRegularizer),this.kernelConstraint=Sy(e.kernelConstraint),this.recurrentConstraint=Sy(e.recurrentConstraint),this.biasConstraint=Sy(e.biasConstraint),this.dropout=tb([1,nb([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=tb([1,nb([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=qb(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return oi((()=>{if(2!==e.length)throw new dm("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=null!=t.training&&t.training;let a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Xx({ones:()=>Fu(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Xx({ones:()=>Fu(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,o=this.recurrentDropoutMask;let s,i,l;0<this.dropout&&this.dropout<1&&(e=tl(e,r[0]));let c=gb(e,this.kernel.read());this.useBias&&(c=vb(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=tl(a,o[0]));const u=this.recurrentKernel.read(),[h,d]=Qu(u,[2*this.units,this.units],u.rank-1),p=gb(a,h),[f,g,m]=Qu(c,3,c.rank-1),[b,y]=Qu(p,2,p.rank-1);s=this.recurrentActivation.apply(Qi(f,b)),i=this.recurrentActivation.apply(Qi(g,y));const v=gb(tl(i,a),d);l=this.activation.apply(Qi(m,v));const x=Qi(tl(s,a),tl(Qi(1,Nu(s)),l));return[x,x]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:tx(this.activation),recurrentActivation:tx(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Vb(this.kernelInitializer),recurrentInitializer:Vb(this.recurrentInitializer),biasInitializer:Vb(this.biasInitializer),kernelRegularizer:lx(this.kernelRegularizer),recurrentRegularizer:lx(this.recurrentRegularizer),biasRegularizer:lx(this.biasRegularizer),activityRegularizer:lx(this.activityRegularizer),kernelConstraint:wy(this.kernelConstraint),recurrentConstraint:wy(this.recurrentConstraint),biasConstraint:wy(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}Gx.className="GRUCell",hl(Gx);class jx extends Bx{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Gx(e),super(e)}call(e,t){return oi((()=>{null!=this.cell.dropoutMask&&(si(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(si(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}jx.className="GRU",hl(jx);class Hx extends Wx{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Dm(this.units,"units"),this.activation=ax(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ax(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Gb(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Gb(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Gb(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=ux(e.kernelRegularizer),this.recurrentRegularizer=ux(e.recurrentRegularizer),this.biasRegularizer=ux(e.biasRegularizer),this.kernelConstraint=Sy(e.kernelConstraint),this.recurrentConstraint=Sy(e.recurrentConstraint),this.biasConstraint=Sy(e.biasConstraint),this.dropout=tb([1,nb([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=tb([1,nb([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=qb(e))[e.length-1];let a;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;a=new((t=class extends Ib{apply(t,a){const r=e.apply([n]),o=(new Nb).apply([n]),s=e.apply([2*n]);return db(db(r,o),s)}}).className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return oi((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new dm("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));let a=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Xx({ones:()=>Fu(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Xx({ones:()=>Fu(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,s=this.recurrentDropoutMask;let i,l,c,u;0<this.dropout&&this.dropout<1&&(e=tl(e,o[0]));let h=gb(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=tl(a,s[0])),h=Qi(h,gb(a,this.recurrentKernel.read())),this.useBias&&(h=vb(h,this.bias.read()));const[d,p,f,g]=Qu(h,4,h.rank-1);i=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),c=Qi(tl(l,r),tl(i,this.activation.apply(f))),u=this.recurrentActivation.apply(g);const m=tl(u,this.activation.apply(c));return[m,m,c]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:tx(this.activation),recurrentActivation:tx(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Vb(this.kernelInitializer),recurrentInitializer:Vb(this.recurrentInitializer),biasInitializer:Vb(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:lx(this.kernelRegularizer),recurrentRegularizer:lx(this.recurrentRegularizer),biasRegularizer:lx(this.biasRegularizer),activityRegularizer:lx(this.activityRegularizer),kernelConstraint:wy(this.kernelConstraint),recurrentConstraint:wy(this.recurrentConstraint),biasConstraint:wy(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}Hx.className="LSTMCell",hl(Hx);class Kx extends Bx{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Hx(e),super(e)}call(e,t){return oi((()=>{null!=this.cell.dropoutMask&&(si(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(si(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Kx.className="LSTM",hl(Kx);class qx extends Wx{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return oi((()=>{let n=e.slice(1);const a=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?a.push(n.splice(0,e.stateSize.length)):a.push(n.splice(0,1));a.reverse();const r=[];let o;for(let s=0;s<this.cells.length;++s){const i=this.cells[s];n=a[s],o=0===s?[e[0]].concat(n):[o[0]].concat(n),o=i.call(o,t),r.push(o.slice(1))}n=[];for(const e of r.slice().reverse())n.push(...e);return[o[0]].concat(n)}))}build(e){let t;jb(e)&&(e=e[0]),this.cells.forEach(((n,a)=>{Ym("RNNCell_".concat(a),(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=[];for(const r of t.cells)a.push(Ly(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return $b(e)}setWeights(e){const t=[];for(const n of this.cells){const a=n.weights.length,r=e.splice(a);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],r[e]])}Qb(t)}}function Xx(e){const{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:o}=e,s=()=>null!=o?o(t(),n):xb(t(),n),i=()=>wb(s,t,a);if(!r||r<=1)return ii(i().clone());return Array(r).fill(void 0).map(i).map((e=>ii(e.clone())))}qx.className="StackedRNNCells",hl(qx);var Yx=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var r=0;for(a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]])}return n};class Jx extends Bx{constructor(e){if(e.unroll)throw new pm("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new pm("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Zb({ndim:5})]}call(e,t){return oi((()=>{if(null!=this.cell.dropoutMask&&(si(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(si(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new dm("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return oi((()=>{const{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=Ru([a[0],...a.slice(2)]);return Array.isArray(t)?Array(t.length).fill(r):[r]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];oi((()=>{if(!this.stateful)throw new um("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(null==n[0])throw new dm("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Ru(r))):this.states_=[Ru(r)];else if(null==e)si(this.states_),null!=this.keptStates&&(si(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Ru(r))):this.states_[0]=Ru(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new dm("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));t?this.keptStates.push(this.states_.slice()):si(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],a=r;if(!Lt(n.shape,a))throw new dm("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(a,", received shape=").concat(n.shape));this.states_[t]=n}}this.states_=this.states_.map((e=>ii(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:o,dilationRate:s}=this.cell,i="channelsFirst"===t,l=e[i?3:2],c=e[i?4:3],u=yx(l,a[0],r,o[0],s[0]),h=yx(c,a[1],r,o[1],s[1]);return[...e.slice(0,2),...i?[n,u,h]:[u,h,n]]}}Jx.className="ConvRNN2D";class $x extends Hx{constructor(e){const{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:o,dilationRate:s}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Dm(this.filters,"filters"),this.kernelSize=bx(n,2,"kernelSize"),this.kernelSize.forEach((e=>Dm(e,"kernelSize"))),this.strides=bx(a||1,2,"strides"),this.strides.forEach((e=>Dm(e,"strides"))),this.padding=r||"valid",Km(this.padding),this.dataFormat=o||"channelsLast",Hm(this.dataFormat),this.dilationRate=bx(s||1,2,"dilationRate"),this.dilationRate.forEach((e=>Dm(e,"dilationRate")))}build(e){var t;e=qb(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new dm("The channel dimension of the input should be defined. "+"Found ".concat(e[n]));const a=e[n],r=this.kernelSize.concat([a,4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,a=this.filters;e=new((t=class extends Ib{apply(e,t){return hb([n.apply([a]),Au([a]),n.apply([2*a])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return oi((()=>{if(3!==e.length)throw new dm("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=t.training||!1,a=e[0],r=e[1],o=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Xx({ones:()=>Fu(a),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=(e,t,n)=>t&&t[n]?tl(t[n],e):e;let l=i(a,s,0),c=i(a,s,1),u=i(a,s,2),h=i(a,s,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Xx({ones:()=>Fu(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=i(r,d,0),f=i(r,d,1),g=i(r,d,2),m=i(r,d,3);const[b,y,v,x]=Qu(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?Qu(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,b,w,this.padding),c=this.inputConv(c,y,k,this.padding),u=this.inputConv(u,v,S,this.padding),h=this.inputConv(h,x,I,this.padding);const[C,N,E,T]=Qu(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,C),f=this.recurrentConv(f,N),g=this.recurrentConv(g,E),m=this.recurrentConv(m,T);const R=this.recurrentActivation.apply(Qi(l,p)),A=this.recurrentActivation.apply(Qi(c,f)),F=Qi(tl(A,o),tl(R,this.activation.apply(Qi(u,g)))),D=tl(this.recurrentActivation.apply(Qi(h,m)),this.activation.apply(F));return[D,D,F]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=Yx(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){const r=Mc(e,t,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?vb(r,n,this.dataFormat):r}recurrentConv(e,t){return Mc(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}$x.className="ConvLSTM2DCell",hl($x);class Qx extends Jx{constructor(e){const t=new $x(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}Qx.className="ConvLSTM2D",hl(Qx);class Zx extends ry{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(null==this.noiseShape[a]?t[a]:this.noiseShape[a]);return n}call(e,t){return oi((()=>{this.invokeCallHook(e,t);const n=Kb(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,a=this.getNoiseShape(n);return wb((()=>xb(n,this.rate,a,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}Zx.className="Dropout",hl(Zx);class ew extends Zx{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}ew.className="SpatialDropout1D",hl(ew);class tw extends ry{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Dm(this.units,"units"),this.activation=ax(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Gb(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Gb(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Sy(e.kernelConstraint),this.biasConstraint=Sy(e.biasConstraint),this.kernelRegularizer=ux(e.kernelRegularizer),this.biasRegularizer=ux(e.biasRegularizer),this.activityRegularizer=ux(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=qb(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=qb(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return oi((()=>{this.invokeCallHook(e,t);const n=Kb(e),a=Om(this.activation.getClassName());let r;return null!=a?r=gb(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=gb(n,this.kernel.read()),null!=this.bias&&(r=vb(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r}))}getConfig(){const e={units:this.units,activation:tx(this.activation),useBias:this.useBias,kernelInitializer:Vb(this.kernelInitializer),biasInitializer:Vb(this.biasInitializer),kernelRegularizer:lx(this.kernelRegularizer),biasRegularizer:lx(this.biasRegularizer),activityRegularizer:lx(this.activityRegularizer),kernelConstraint:wy(this.kernelConstraint),biasConstraint:wy(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}tw.className="Dense",hl(tw);class nw extends ry{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=qb(e);for(const t of e.slice(1))if(null==t)throw new dm('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(e.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[e[0],eb(e,1)]}call(e,t){return oi((()=>{this.invokeCallHook(e,t);let n=Kb(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=ch(n,e)}return function(e){if(e.rank<=1)throw new dm("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank,"."));const t=[e.shape[0],eb(e.shape,1)];return Sc(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}nw.className="Flatten",hl(nw);class aw extends ry{constructor(e){super(e),this.supportsMasking=!0,this.activation=ax(e.activation)}call(e,t){return oi((()=>{this.invokeCallHook(e,t);const n=Kb(e);return this.activation.apply(n)}))}getConfig(){const e={activation:tx(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}aw.className="Activation",hl(aw);class rw extends ry{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return oi((()=>function(e,t){return oi((()=>{if(2!==e.shape.length)throw new dm("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(e.shape.length," tensor."));return pb(ib(e,1),[1,t,1])}))}(e=Kb(e),this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}rw.className="RepeatVector",hl(rw);class ow extends ry{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",a=t.slice();let r=1,o=null;for(let i=0;i<a.length;++i){const e=a[i];if(this.isUnknown(e)){if(null!==o)throw new dm("Can only specifiy one unknown dimension.");o=i}else r*=e}const s=eb(e);if(null!==o){if(0===r||s%r!==0)throw new dm(n);a[o]=s/r}else if(s!==r)throw new dm(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return oi((()=>{this.invokeCallHook(e,t);const n=Kb(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return Sc(n,r)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}ow.className="Reshape",hl(ow);class sw extends ry{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(e.dims," instead."));const t=ab(1,e.dims.length+1);if(!Lt(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Zb({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=qb(e)).slice();return this.dims.forEach(((n,a)=>{t[a+1]=e[n]})),t}call(e,t){return ch(Kb(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}sw.className="Permute",hl(sw);class iw extends ry{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=Kb(e);return sc(Eu(n,this.maskValue),-1)}call(e,t){return oi((()=>{this.invokeCallHook(e,t);const n=Kb(e),a=sc(Eu(n,this.maskValue),-1,!0);return tl(n,Ji(a,n.dtype))}))}}iw.className="Masking",hl(iw);class lw extends ry{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(xm(e.inputLength))}this.inputDim=e.inputDim,Dm(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Dm(this.outputDim,"outputDim"),this.embeddingsInitializer=Gb(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ux(e.embeddingsRegularizer),this.activityRegularizer=ux(e.activityRegularizer),this.embeddingsConstraint=Sy(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return oi((()=>this.maskZero?(e=Kb(e),Eu(e,rl(e))):null))}computeOutputShape(e){if(e=qb(e),null==this.inputLength)return[...e,this.outputDim];const t=xm(this.inputLength);if(t.length!==e.length-1)throw new dm('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));{let n=0;for(let a=0;a<t.length;++a){const r=t[a],o=e[a+1];if(null!=r&&null!=o&&r!==o)throw new dm('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));null==r&&(t[n]=o),n++}}return[e[0],...t,this.outputDim]}call(e,t){return oi((()=>{this.invokeCallHook(e,t);let n=Kb(e);"int32"!==n.dtype&&(n=sb(n,"int32"));const a=mb(this.embeddings.read(),Sc(n,[n.size]));return Sc(a,qb(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Vb(this.embeddingsInitializer),embeddingsRegularizer:lx(this.embeddingsRegularizer),activityRegularizer:lx(this.activityRegularizer),embeddingsConstraint:wy(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}lw.className="Embedding",hl(lw);class cw extends ry{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new pm}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){const r=e[e.length-t.length+a],o=t[a];if(null==r||null==o||r<0||o<0)n.push(null);else if(1===r)n.push(o);else if(1===o)n.push(r);else{if(r!==o)throw new dm("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[qb(e)]),e.length<2)throw new dm("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(e.length," input(s)."));let t=[];for(const r of e)null!=r&&null!==r[0]&&t.push(r[0]);if(t=Tm(t),t.length>1)throw new dm("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(e),"."));let n=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const t=null==e[r]?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const a=e.map((e=>e.length));-1===e.indexOf(null)&&1===Tm(a).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return oi((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const a=nb(n);for(let n of e){const e=n.rank;for(let t=0;t<a-e;++t)n=ib(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const o of e){const e=o.rank;if(null==e){const e=o.shape,a=e[0],r=e.slice(1).concat([a]);let s=Sc(o,[a].concat(eb(e.slice(1))));s=ch(s,[1,0]),s=Sc(s,r),t.push(s),n=!0}else if(e>1){const a=ab(1,e).concat([0]);t.push(ch(o,a)),n=!0}else t.push(o)}let a=this.mergeFunction(t);const r=a.rank;if(n)if(null==r){const e=a.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));a=Sc(ch(Sc(a,[-1,t]),[1,0]),n)}else if(r>1){const e=[r-1].concat(ab(0,r-1));a=ch(a,e)}return a}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const n=null==e[a]?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const a of e)null!=a&&null!==a[0]&&n.push(a[0]);return n=Tm(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return oi((()=>{if(null==t)return null;if(!Array.isArray(t))throw new dm("`mask` should be an Array");if(!Array.isArray(e))throw new dm("`inputs` should be an Array");if(t.length!==e.length)throw new dm("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(e.length," vs ").concat(t.length,")"));if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:Jc(e,0))))[0];for(let e=1;e<t.length-1;++e)n=yu(n,t[e]);return n}))}}class uw extends cw{constructor(e){super(e)}mergeFunction(e){return oi((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Qi(t,e[n]);return t}))}}uw.className="Add",hl(uw);class hw extends cw{constructor(e){super(e)}mergeFunction(e){return oi((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=tl(t,e[n]);return t}))}}hw.className="Multiply",hl(hw);class dw extends cw{constructor(e){super(e)}mergeFunction(e){return oi((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Qi(t,e[n]);return tl(1/e.length,t)}))}}dw.className="Average",hl(dw);class pw extends cw{constructor(e){super(e)}mergeFunction(e){return oi((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Sl(t,e[n]);return t}))}}pw.className="Maximum",hl(pw);class fw extends cw{constructor(e){super(e)}mergeFunction(e){return oi((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Iu(t,e[n]);return t}))}}fw.className="Minimum",hl(fw);class gw extends cw{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new dm("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const a of e)if(null!=a){t=!1;break}if(t)return;const n=[];for(let a=0;a<e.length;++a){const t=e[a].slice();t.splice(this.axis,1);let r=!1;for(const e of n)if(Lt(e,t)){r=!0;break}r||n.push(t)}if(n.length>1)throw new dm("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return oi((()=>hb(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new dm("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(const r of t.slice(1)){if(null==n[a]||null==r[a]){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new dm("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new dm("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new dm("Mismatch in the length of mask (".concat(t.length,") ")+"and the legnth of inputs (".concat(e.length,")"));return oi((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const a=[];for(let o=0;o<e.length;++o)null==t[o]?a.push(Ji(Fu(e[o]),"bool")):t[o].rank<e[o].rank?a.push(Jc(t[o],-1)):a.push(t[o]);const r=Dc(a,this.axis);return oc(r,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function mw(e,t){for(;e<0;)e+=t;return e}gw.className="Concatenate",hl(gw);class bw extends cw{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Ft(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new pm("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new dm("Dimension incompatibility: "+"".concat(t[a[0]]," !== ").concat(n[a[1]]))}mergeFunction(e){if(2!==e.length)throw new dm("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(e.length," input(s)."));let t,n=e[0],a=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>mw(t,e[n].shape.length))):[mw(this.axes,n.shape.length),mw(this.axes,a.shape.length)],this.normalize&&(n=zy(n,t[0]),a=zy(a,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new pm("batchDot is not implemented for tensors of 4D or higher rank yet");if(Ft(e.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(e.shape.length))),Ft(e.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(t.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new pm("batchDot is not implemented for complex64-type Tensors yet.");const a=e.shape.length,r=t.shape.length;null==n&&(n=[a-1,r-2]);const o=n;return oi((()=>{let n,s;if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=Sc(t,t.shape.concat(e))}else if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=Sc(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)s=o[0]===o[1]?iu(tl(e,t),o[0]):iu(tl(ch(e,[1,0]),t),o[1]);else{const n=o[0]!==e.shape.length-1,a=o[1]===t.shape.length-1;s=vu(e,t,n,a)}if(n>0){let e;e=a>r?a+r-3:a-1;const t=[];for(let a=e;a<e+n;++a)t.push(a);s=Zu(s,t)}return 1===s.shape.length&&(s=Jc(s,1)),s}))}(n,a,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[mw(this.axes,e.length),mw(this.axes,t.length)],n}computeOutputShape(e){Ft(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new pm("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);const r=t.concat(n);return 1===r.length&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}bw.className="Dot",hl(bw);class yw extends ry{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return oi((()=>{this.invokeCallHook(e,t);const n=Kb(e);return wb((()=>Qi(fb(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}yw.className="GaussianNoise",hl(yw);class vw extends ry{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return oi((()=>{this.invokeCallHook(e,t);const n=Kb(e);if(this.rate>0&&this.rate<1){return wb((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return tl(n,fb(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}vw.className="GaussianDropout",hl(vw);class xw extends ry{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Kb(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return oi((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),a=()=>{const t=Kb(e),a=-1.7580993408473766;let r=nu(Pu(n),this.rate);r=sb(r,"float32");const o=((1-this.rate)*(1+this.rate*a**2))**-.5,s=-o*a*this.rate,i=Qi(tl(t,r),tl(Qi(r,-1),a));return Qi(tl(i,o),s)};return wb(a,(()=>Kb(e)),t.training||!1)}return e}))}}function ww(e,t,n,a,r){let o,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)o=Ec(e,t,n,a,r,s);else if(3===e.rank)o=Tc(e,t,n,a,r,s);else{if(4!==e.rank)throw new pm("batchNormalization is not implemented for array of rank ".concat(e.rank," ")+"yet");o=Rc(e,t,n,a,r,s)}return o}function kw(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Lt(a.slice().sort(),ab(0,e.rank-1))?function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return oi((()=>{const o=Cu(e,a),s=o.mean,i=o.variance;return[ww(e,s,i,n,t,r),s,i]}))}(e,t,n,a,r):function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return oi((()=>{const o=Cu(e,a),s=o.mean,i=o.variance,l=[];for(const t of ab(0,e.rank))-1!==a.indexOf(t)?l.push(1):l.push(e.shape[t]);const c=Sc(s,l),u=Sc(i,l),h=null==t?null:Sc(t,l),d=null==n?null:Sc(n,l);return[ww(e,c,u,d,h,r),s,i]}))}(e,t,n,a,r)}xw.className="AlphaDropout",hl(xw);class Sw extends ry{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Gb(e.betaInitializer||"zeros"),this.gammaInitializer=Gb(e.gammaInitializer||"ones"),this.movingMeanInitializer=Gb(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Gb(e.movingVarianceInitializer||"ones"),this.betaConstraint=Sy(e.betaConstraint),this.gammaConstraint=Sy(e.gammaConstraint),this.betaRegularizer=ux(e.betaRegularizer),this.gammaRegularizer=ux(e.gammaRegularizer)}build(e){e=qb(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new dm("Axis ".concat(t," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(e),"."));this.inputSpec=[new Zb({ndim:e.length,axes:{[t]:n}})];const a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return oi((()=>{const n=null!=t.training&&t.training,a=Kb(e),r=a.shape,o=r.length,s=ab(0,o),i=this.axis>=0?this.axis:this.axis+o;s.splice(i,1);const l=mm(1,o);l[i]=r[i];const c=s.slice();c.sort();const u=!Lt(c,ab(0,o).slice(0,o-1));if(!n)return(()=>{if(u){const e=Sc(this.movingMean.read(),l),t=Sc(this.movingVariance.read(),l),n=this.center?Sc(this.beta.read(),l):null,r=this.scale?Sc(this.gamma.read(),l):null;return ww(a,e,t,n,r,this.epsilon)}return ww(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=kw(a,this.gamma.read(),this.beta.read(),s,this.epsilon),f=(e,t,n)=>{oi((()=>{const a=1-n,r=e.read(),o=tl(bl(r,t),a);e.write(bl(r,o))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Vb(this.betaInitializer),gammaInitializer:Vb(this.gammaInitializer),movingMeanInitializer:Vb(this.movingMeanInitializer),movingVarianceInitializer:Vb(this.movingVarianceInitializer),betaRegularizer:lx(this.betaRegularizer),gammaRegularizer:lx(this.gammaRegularizer),betaConstraint:wy(this.betaConstraint),gammaConstraint:wy(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Sw.className="BatchNormalization",hl(Sw);class Iw extends ry{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const e of this.axis)if(!Number.isInteger(e))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Gb(e.betaInitializer||"zeros"),this.gammaInitializer=Gb(e.gammaInitializer||"ones"),this.betaRegularizer=ux(e.betaRegularizer),this.gammaRegularizer=ux(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=qb(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(const r of this.axis)if(r<0||r>=t)throw new Error("Invalid axis: ".concat(r));if(this.axis.length!==Tm(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((t=>e[t])),a=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(e,t){const n=Kb(e),a=n.shape,r=a.length;return oi((()=>{let{mean:e,variance:t}=Cu(n,this.axis,!0);const o=mm(1,r);for(const n of this.axis)o[n]=a[n];const s=e=>null!=e&&e.shape.length!==r?Sc(e,o):e;let i=this.scale?s(this.gamma.read()):null,l=this.center?s(this.beta.read()):null;const c=[],u=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(c.push(a[n]),u.push(1)):(c.push(1),u.push(a[n]));return e=$c(e,c),t=$c(t,c),null!=i&&(i=$c(i,u)),null!=l&&(l=$c(l,u)),ww(n,e,t,l,i,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Vb(this.betaInitializer),gammaInitializer:Vb(this.gammaInitializer),betaRegularizer:lx(this.betaRegularizer),gammaRegularizer:lx(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}Iw.className="LayerNormalization",hl(Iw);class Cw extends ry{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new dm("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(e.padding.length," array."));let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new dm("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(e.padding[0].length," array."));if(t=e.padding[0],2!==e.padding[1].length)throw new dm("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(e.padding[1].length," array."));n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Zb({ndim:4})]}computeOutputShape(e){let t,n;return e=qb(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return oi((()=>{return t=Kb(e),n=this.padding,a=this.dataFormat,oi((()=>{if(4!==t.rank)throw new dm("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(t.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new dm("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==a&&(a="channelsLast"),"channelsLast"!==a&&"channelsFirst"!==a)throw new dm("Unknown data format: ".concat(a,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let e;return e="channelsFirst"===a?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Du(t,e)}));var t,n,a}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function Nw(e,t,n,a,r,o){return oi((()=>{let s;Hm(r),qm(o),Km(a),null==n&&(n=[1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==o&&(o="max"),e=xx(e,r);const i="same"===a?"same":"valid";return s="max"===o?xu(e,t,n,i):Ic(e,t,n,i),"channelsFirst"===r&&(s=ch(s,[0,3,1,2])),s}))}function Ew(e,t,n,a,r,o){return oi((()=>{let s;Hm(r),qm(o),Km(a),null==n&&(n=[1,1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==o&&(o="max"),e=wx(e,r);const i="same"===a?"same":"valid";return s="max"===o?wu(e,t,n,i):Cc(e,t,n,i),"channelsFirst"===r&&(s=ch(s,[0,4,1,2,3])),s}))}Cw.className="ZeroPadding2D",hl(Cw);class Tw extends ry{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new dm("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.poolSize)));this.poolSize=e.poolSize}if(Dm(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new dm("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.strides)));this.strides=e.strides}Dm(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,Km(this.padding),this.inputSpec=[new Zb({ndim:3})]}computeOutputShape(e){const t=yx((e=qb(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return oi((()=>{this.invokeCallHook(e,t),e=ib(Kb(e),2);const n=this.poolingFunction(Kb(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Zu(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class Rw extends Tw{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Hm(r),Km(a),Nw(e,t,n,a,r,"max")}}Rw.className="MaxPooling1D",hl(Rw);class Aw extends Tw{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Hm(r),Km(a),Nw(e,t,n,a,r,"avg")}}Aw.className="AveragePooling1D",hl(Aw);class Fw extends ry{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new dm("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides];Dm(this.poolSize,"poolSize"),Dm(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Hm(this.dataFormat),Km(this.padding),this.inputSpec=[new Zb({ndim:4})]}computeOutputShape(e){e=qb(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=yx(t,this.poolSize[0],this.padding,this.strides[0]),n=yx(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return oi((()=>(this.invokeCallHook(e,t),this.poolingFunction(Kb(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Dw extends Fw{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Hm(r),Km(a),Nw(e,t,n,a,r,"max")}}Dw.className="MaxPooling2D",hl(Dw);class _w extends Fw{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Hm(r),Km(a),Nw(e,t,n,a,r,"avg")}}_w.className="AveragePooling2D",hl(_w);class Ow extends ry{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new dm("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Dm(this.poolSize,"poolSize"),Dm(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Hm(this.dataFormat),Km(this.padding),this.inputSpec=[new Zb({ndim:5})]}computeOutputShape(e){e=qb(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[4]:e[3];return t=yx(t,this.poolSize[0],this.padding,this.strides[0]),n=yx(n,this.poolSize[1],this.padding,this.strides[1]),a=yx(a,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return oi((()=>(this.invokeCallHook(e,t),this.poolingFunction(Kb(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Lw extends Ow{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Hm(r),Km(a),Ew(e,t,n,a,r,"max")}}Lw.className="MaxPooling3D",hl(Lw);class zw extends Ow{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Hm(r),Km(a),Ew(e,t,n,a,r,"avg")}}zw.className="AveragePooling3D",hl(zw);class Mw extends ry{constructor(e){super(e),this.inputSpec=[new Zb({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new pm}}class Pw extends Mw{constructor(e){super(e||{})}call(e,t){return oi((()=>{const t=Kb(e);return ku(t,1)}))}}Pw.className="GlobalAveragePooling1D",hl(Pw);class Bw extends Mw{constructor(e){super(e||{})}call(e,t){return oi((()=>{const t=Kb(e);return su(t,1)}))}}Bw.className="GlobalMaxPooling1D",hl(Bw);class Ww extends ry{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Hm(this.dataFormat),this.inputSpec=[new Zb({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new pm}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Uw extends Ww{call(e,t){return oi((()=>{const t=Kb(e);return"channelsLast"===this.dataFormat?ku(t,[1,2]):ku(t,[2,3])}))}}Uw.className="GlobalAveragePooling2D",hl(Uw);class Vw extends Ww{call(e,t){return oi((()=>{const t=Kb(e);return"channelsLast"===this.dataFormat?su(t,[1,2]):su(t,[2,3])}))}}Vw.className="GlobalMaxPooling2D",hl(Vw);class Gw extends ry{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=Ly(t.layer,n);delete t.layer;const r={layer:a};return Object.assign(r,t),new e(r)}}class jw extends Gw{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=qb(e)).length<3)throw new dm("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(e)));this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=qb(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return oi((()=>Px(((e,n)=>[Kb(this.layer.call(e,t)),[]]),e=Kb(e),[],!1,null,null,!1,!0)[1]))}}jw.className="TimeDistributed",hl(jw);class Hw extends Gw{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Ly(n),t.goBackwards=!0!==t.goBackwards;const a={};var r;if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=Ly(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,r=this.mergeMode,Am(Gm,"BidirectionalMergeMode",r),e.weights)throw new pm("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,a,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState?(a=r.slice(1),t=r[0]):t=r[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(a).concat(a.slice()):[t].concat(a).concat(a.slice()):vm(n)}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=Mx(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==a)return super.apply(e,t);const o=[],s=[];if(null!=n){const e=n.length;if(e%2>0)throw new dm("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,o.push(...n);const a=n.map((e=>new Zb({shape:e.shape})));this.forwardLayer.stateSpec=a.slice(0,e/2),this.backwardLayer.stateSpec=a.slice(e/2),s.push(...a)}if(null!=a)throw new pm("Support for constants in Bidirectional layers is not implemented yet.");const i=o[0]instanceof ey;for(const l of o)if(l instanceof ey!==i)throw new dm("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[e].concat(o),a=this.inputSpec.concat(s),r=this.inputSpec;this.inputSpec=a;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return oi((()=>{const n=t.initialState;let a,r,o,s;if(null==n)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const o=n.slice(0,n.length/2),s=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return this.returnState&&(Array.isArray(a)&&(o=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=Uu(r,1)),"concat"===this.mergeMode?s=hb([a,r]):"sum"===this.mergeMode?s=Qi(a,r):"ave"===this.mergeMode?s=tl(.5,Qi(a,r)):"mul"===this.mergeMode?s=tl(a,r):null==this.mergeMode&&(s=[a,r]),this.returnState?null==this.mergeMode?s.concat(o):[s].concat(o):s}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Ym(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),Ym(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=Ly(t.layer);if(delete t.layer,null!=t.numConstants)throw new pm("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=t;return a.layer=n,new e(a)}}Hw.className="Bidirectional",hl(Hw);class Kw extends ry{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return oi((()=>("float32"!==(e=Kb(e)).dtype&&(e=sb(e,"float32")),Qi(tl(e,this.scale),this.offset))))}}Kw.className="Rescaling",hl(Kw);const{resizeBilinear:qw,cropAndResize:Xw}=ud;class Yw extends ry{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,a,r,o,s,i){return oi((()=>{let l,c=!1;const u=[t/o,n/s,(a+t)/o,(r+n)/s],h=[];3===e.rank?(c=!0,l=eh([e])):l=e;for(let e=0;e<l.shape[0];e++)h.push(u);const d=ei(h,[h.length,4]),p=Bu(0,h.length,1,"int32"),f=Xw(l,d,p,[a,r],"nearest");return sb(c?Kb(oh(f)):f,i)}))}upsize(e,t,n,a){return oi((()=>sb(qw(e,[t,n]),a)))}call(e,t){return oi((()=>{const t=Kb(e),n=t.dtype,a=t.shape,r=a[a.length-3],o=a[a.length-2];let s=0;r!==this.height&&(s=Math.floor((r-this.height)/2));let i=0;return o!==this.width&&(i=Math.floor((o-this.width)/2),0===i&&(i=1)),s>=0&&i>=0?this.centerCrop(t,s,i,this.height,this.width,r,o,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=qb(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}Yw.className="CenterCrop",hl(Yw);class Jw extends ry{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=qb(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return oi((()=>{let n;if("int32"!==(e=Kb(e)).dtype&&(e=sb(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new dm("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(t.countWeights));n=Kb(t.countWeights)}const a=su(e),r=Su(e),o=tu(this.numTokens,a).bufferSync().get(0),s=nu(r,0).bufferSync().get(0);if(!o||!s)throw new dm("Input values must be between 0 < values <="+" numTokens with numTokens=".concat(this.numTokens));return function(e,t,n,a){let r=Kb(e);if("int32"!==r.dtype&&(r=sb(r,"int32")),"int"===t)return r;const o=r.shape;if(0===r.rank&&(r=Jc(r,-1)),"oneHot"===t&&1!==r.shape[r.shape.length-1]&&(r=Jc(r,-1)),r.rank>2)throw new dm("When outputMode is not int, maximum output rank is 2"+" Received outputMode ".concat(t," and input shape ").concat(o)+" which would result in output rank ".concat(r.rank,"."));const s=["multiHot","oneHot"].includes(t),i=r;let l;if(l=jc(i,"undefined"!==typeof a&&"count"===t?a:[],n,s),"tfIdf"!==t)return l;if(a)return tl(l,a);throw new dm("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}Jw.className="CategoryEncoding",hl(Jw);const $w=new Set(["bilinear","nearest"]);class Qw extends ry{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!$w.has(e.interpolation))throw new dm("Invalid interpolation parameter: ".concat(e.interpolation," is not implemented"));this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=qb(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return oi((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return ud.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return ud.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error("Interpolation is ".concat(this.interpolation," but only ").concat([...$w]," are supported"))}))}}Qw.className="Resizing",hl(Qw);class Zw{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}Zw.className="RandomSeed";class ek extends ry{constructor(e){super(e),this.randomGenerator=new Zw(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}ek.className="BaseRandomLayer";const tk=new Set(["bilinear","nearest"]);class nk extends ek{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new dm("Invalid factor: ".concat(this.factor,". Must be positive number or tuple of 2 numbers"));this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new dm("factor must have values larger than -1. Got: ".concat(this.factor));if(this.widthUpper<this.widthLower)throw new dm("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(this.widthUpper,".\n        Got lower bound: ").concat(this.widthLower,"\n      "));if(n){if(!tk.has(n))throw new dm("Invalid interpolation parameter: ".concat(n," is not implemented"));this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=qb(e))[2];return[this.imgHeight,-1,t]}call(e,t){return oi((()=>{const t=Kb(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=Pu([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*n;a=Math.round(a);const r=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return ud.resizeBilinear(e,r);case"nearest":return ud.resizeNearestNeighbor(e,r);default:throw new Error("Interpolation is ".concat(this.interpolation,"\n          but only ").concat([...tk]," are supported"))}}))}}nk.className="RandomWidth",hl(nk);var ak,rk;dn().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(ak||(ak={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(rk||(rk={}));Error;new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function ok(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(ck(e)){const r=Array.isArray(e)?[]:{};a.add(e);for(const o in e){const s=ok(e[o],t,n,a);r[o]=s}return a.delete(e),e.__proto__&&(r.__proto__=e.__proto__),r}throw new Error("Can't recurse into non-iterable type: ".concat(e))}return n.set(e,r.value),r.value}function sk(e){return ik(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:lk)}function ik(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(ck(a)){const r=Array.isArray(a)?[]:{};n.add(a);for(const o in a){const a=ik(e.map((e=>e[o])),t,n);r[o]=a}return n.delete(a),r}throw new Error("Can't recurse into non-iterable type: ".concat(a))}return r.value}function lk(e){return null===e?null:ck(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function ck(e){let t=!1;if(dn().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:a}=n(551);t=e instanceof a}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof vs)&&!(e instanceof Promise)&&!t)}function uk(e){return function(e,t){return ok(e,t)}(e,hk)}function hk(e){return e instanceof vs?{value:e.clone(),recurse:!1}:ck(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class dk{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class pk extends dk{constructor(){super(pk.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let a=0;a<n;a++)t[a]=this.get(this.wrap(this.begin+a));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function fk(e){return new yk(e)}function gk(e,t){return new Rk(e,t)}pk.INITIAL_CAPACITY=32;class mk{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new Ck(this,e)}filter(e){return new Sk(this,e)}map(e){return new Ik(this,e)}mapAsync(e){return new Nk(this,e)}serialMapAsync(e){return new Nk(this,e).serial()}flatmap(e){return new Tk(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new kk(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:lk;return this.rowMajorBatch(e,t).map((e=>sk(e,n)))}concatenate(e,t){return new Rk(new bk([this,e]),t)}take(e){return e<0||null==e?this:new wk(this,e)}skip(e){return e<0||null==e?this:new xk(this,e)}prefetch(e){return new Fk(this,e)}shuffle(e,t){return new Dk(this,e,t)}serial(){return new vk(this)}}class bk extends mk{constructor(e){super(),this.items=e,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:uk(e),done:!1}}}class yk extends mk{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(IW){throw IW.message="Error thrown while iterating through a dataset: ".concat(IW.message),IW}}}class vk extends mk{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class xk extends mk{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;si(e.value)}return this.upstream.next()}}class wk extends mk{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class kk extends mk{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class Sk extends mk{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;si(e.value)}}}class Ik extends mk{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Os(e.value),n=this.transform(e.value),a=Os(n);for(const r of t)_s(r,a)||r.dispose();return{value:n,done:!1}}}class Ck extends mk{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(IW){if(!this.handler(IW))return{value:null,done:!0}}}}class Nk extends mk{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Os(e.value),n=await this.transform(e.value),a=Os(n);for(const r of t)_s(r,a)||r.dispose();return{value:n,done:!1}}}class Ek extends mk{constructor(){super(),this.outputQueue=new pk,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class Tk extends Ek{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Os(e.value),n=this.transform(e.value),a=Os(n);this.outputQueue.pushAll(n);for(const r of t)_s(r,a)||r.dispose();return!0}}class Rk extends mk{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var Ak;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(Ak||(Ak={}));class Fk extends mk{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new dk(t)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class Dk extends Fk{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Ou.alea(n||ns().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class _k{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let a;return Ft(e>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(e))),a=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),Ok((async()=>(await n.iterator()).columnMajorBatch(e,t,Lk)),a)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,Ok((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,Ok((async()=>(await t.iterator()).filter((t=>oi((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return Ok((async()=>(await t.iterator()).map((t=>oi((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return Ok((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return Ok((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,Ok((async()=>gk(fk((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,Ok((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const a=this,r=Ou.alea(t||ns().toString());return Ok((async()=>{let t=r.int32();return n&&(t+=r.int32()),(await a.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,Ok((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function Ok(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends _k{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function Lk(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof vs||os(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof vs?eh(e):ei(e)}(e),recurse:!1}}return{value:null,recurse:!0}}_k.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function zk(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Ft("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors in the CPU backend.")))}))}const Mk=Ip;class Pk extends Ct{nextDataId(){return Pk.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new It(this,ai())}write(e,t,n){this.firstUse&&(this.firstUse=!1,dn().get("IS_NODE")&&Ro("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&qt(n[0])){const r=n.map((e=>as(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,r){this.data.set(e,{values:t,dtype:a,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return Vd(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype ".concat(t))}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>rs(e)));return Yi(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Yi(e.shape,e.dtype,t)}makeOutput(e,t,n){return ai().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=ns();e();return{kernelMs:ns()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){zk([e],"where");const t=this.readSync(e.dataId);return Mk(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Pk.nextDataId=0;function Bk(e){return(t,n,a)=>{const r=jt(n,t.length);for(let o=0;o<t.length;++o)r[o]=e(t[o],a);return r}}function Wk(e,t,n){return Uk(e,Bk(t),n)}function Uk(e,t,n){return a=>{let{inputs:r,attrs:o,backend:s}=a;const{x:i}=r;zk(i,e);const l=s,c=l.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");u=kp(c)}else u=c;const h=n||i.dtype,d=t(u,h,o);return l.makeTensorInfo(i.shape,h,d)}}li("cpu",(()=>new Pk),1);const Vk=Wk(ga,(e=>e>=0?e:Math.exp(e)-1)),Gk={kernelName:ga,backendName:"cpu",kernelFunc:Vk};function jk(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const Hk={kernelName:Da,backendName:"cpu",kernelFunc:jk};function Kk(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:o}=a;zk([r],"leakyRelu");const s=Ot(r.shape),i=n.data.get(r.dataId).values,l=Gt("float32",s);for(let c=0;c<i.length;c++)l[c]=i[c]<0?o*i[c]:i[c];return n.makeTensorInfo(r.shape,"float32",l)}const qk={kernelName:Pa,backendName:"cpu",kernelFunc:Kk};function Xk(e){return(t,n,a,r,o)=>{const s=kl(t,n),i=s.length,l=Qt(s),c=Gt(o,Ot(s)),u=t.length,h=n.length,d=Qt(t),p=Qt(n),f=xl(t,s),g=xl(n,s);if(f.length+g.length===0)for(let m=0;m<c.length;++m)c[m]=e(a[m%a.length],r[m%r.length]);else for(let m=0;m<c.length;++m){const t=sn(m,i,l),n=t.slice(-u);f.forEach((e=>n[e]=0));const o=on(n,u,d),s=t.slice(-h);g.forEach((e=>s[e]=0));const b=on(s,h,p);c[m]=e(a[o],r[b])}return[c,s]}}const Yk=Xk(((e,t)=>e<0?t*e:e));function Jk(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t;zk([a,r],"prelu");const o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,[i,l]=Yk(a.shape,r.shape,o,s,"float32");return n.makeTensorInfo(l,"float32",i)}const $k={kernelName:vr,backendName:"cpu",kernelFunc:Jk},Qk=Wk(Er,(e=>Math.max(0,e))),Zk={kernelName:Er,backendName:"cpu",kernelFunc:Qk},eS=Wk(_r,(e=>Math.min(Math.max(0,e),6))),tS={kernelName:_r,backendName:"cpu",kernelFunc:eS},nS=Bk((e=>1/(1+Math.exp(-e)))),aS=Wk(Kr,(e=>1/(1+Math.exp(-e)))),rS={kernelName:Kr,backendName:"cpu",kernelFunc:aS};function oS(e,t,n,a,r){if("linear"===n)return jk({inputs:{x:t},backend:e});if("relu"===n)return Qk({inputs:{x:t},backend:e});if("elu"===n)return Vk({inputs:{x:t},backend:e});if("relu6"===n)return eS({inputs:{x:t},backend:e});if("prelu"===n)return Jk({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return Kk({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return aS({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function sS(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,i=n.makeTensorInfo(a.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",o),imag:n.makeTensorInfo(r.shape,"float32",s)},i}const iS={kernelName:Gn,backendName:"cpu",kernelFunc:sS};function lS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return sS({inputs:{real:lS(e,t,"float32"),imag:lS(e,t,"float32")},backend:e})}const a=nn(Ot(t),n);return e.makeTensorInfo(t,n,a)}function cS(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const uS={kernelName:Cr,backendName:"cpu",kernelFunc:cS};function hS(e,t,n,a){if("int32"===a){return[t,"int32",Int32Array.from(e)]}if("bool"===a){const a=ts([0],n),[r,o]=Xk(((e,t)=>e!==t?1:0))(t,[],e,a,"bool");return[o,"bool",r]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(a))}function dS(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:o}=a;if("complex64"===o){if("complex64"===r.dtype)return jk({inputs:{x:r},backend:n});const e=lS(n,r.shape,r.dtype),t=dS({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=sS({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===r.dtype){const e=cS({inputs:{input:r},backend:n}),t=dS({inputs:{x:e},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(e),t}if(!Ht(r.dtype,o)){const e=jk({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:o}}const s=n.data.get(r.dataId).values,[i,l,c]=hS(s,r.shape,r.dtype,o);return n.makeTensorInfo(i,l,c)}const pS={kernelName:Wn,backendName:"cpu",kernelFunc:dS};function fS(e,t,n,a){return null==n?n=>{let{inputs:r,backend:o}=n;const{a:s,b:i}=r,l=o;zk([s,i],e);const c=l.data.get(s.dataId).values,u=l.data.get(i.dataId).values,h="string"===s.dtype?kp(c):c,d="string"===s.dtype?kp(u):u,p=a||s.dtype,[f,g]=t(s.shape,i.shape,h,d,p);return l.makeTensorInfo(g,p,f)}:e=>{let{inputs:r,backend:o}=e;const{a:s,b:i}=r,l=o;if("complex64"===s.dtype||"complex64"===i.dtype){const e=dS({inputs:{x:s},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),a=t.complexTensorInfos.real,r=t.complexTensorInfos.imag,o=l.data.get(a.dataId).values,c=l.data.get(r.dataId).values,u=dS({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(u.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=l.data.get(d.dataId).values,g=l.data.get(p.dataId).values,[m,b,y]=n(s.shape,i.shape,o,c,f,g),v=l.makeTensorInfo(y,"float32",m),x=l.makeTensorInfo(y,"float32",b),w=sS({inputs:{real:v,imag:x},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(x),w}{const e=l.data.get(s.dataId).values,n=l.data.get(i.dataId).values,r=a||s.dtype,[o,c]=t(s.shape,i.shape,e,n,r);return l.makeTensorInfo(c,r,o)}}}function gS(e){return(t,n,a,r,o,s)=>{const i=kl(t,n),l=Ot(i),c=i.length,u=Qt(i),h=Gt("float32",l),d=Gt("float32",l),p=xl(t,i),f=xl(n,i),g=Vd(a,r),m=Vd(o,s),b=t.length,y=Qt(t),v=n.length,x=Qt(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%g.length,n=w%m.length,a=e(g[2*t],g[2*t+1],m[2*n],m[2*n+1]);h[w]=a.real,d[w]=a.imag}else for(let w=0;w<h.length;w++){const t=sn(w,c,u),n=t.slice(-b);p.forEach((e=>n[e]=0));const a=on(n,b,y),r=t.slice(-v);f.forEach((e=>r[e]=0));const o=on(r,v,x),s=e(g[2*a],g[2*a+1],m[2*o],m[2*o+1]);h[w]=s.real,d[w]=s.imag}return[h,d,i]}}const mS=Xk(((e,t)=>e+t)),bS=gS(((e,t,n,a)=>({real:e+n,imag:t+a}))),yS=fS(xn,mS,bS),vS={kernelName:xn,backendName:"cpu",kernelFunc:yS};function xS(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:o}=a,s=Ot(r.shape),i=Wt(o,s),l=Ot(i);Ft(s===l,(()=>"The new shape (".concat(i,") has ").concat(l," elements and the old ")+"shape (".concat(r.shape,") has ").concat(s," elements. The new shape and old ")+"shape must have the same number of elements.")),n.incRef(r.dataId);const c=n.data.get(r.dataId);if(null!=c.complexTensorInfos){const e=c.complexTensorInfos.real,t=c.complexTensorInfos.imag;e.shape=i,t.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const wS={kernelName:Tr,backendName:"cpu",kernelFunc:xS};function kS(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o}=t,{transposeA:s,transposeB:i}=a;zk([r,o],"matMul");const l=r.shape.length,c=o.shape.length,u=s?r.shape[l-2]:r.shape[l-1],h=i?o.shape[c-1]:o.shape[c-2],d=s?r.shape[l-1]:r.shape[l-2],p=i?o.shape[c-2]:o.shape[c-1],f=r.shape.slice(0,-2),g=o.shape.slice(0,-2),m=Ot(f),b=Ot(g),y=kl(r.shape.slice(0,-2),o.shape.slice(0,-2)).concat([d,p]);Ft(u===h,(()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(h,") of Tensors with shapes ").concat(r.shape," and ")+"".concat(o.shape," and transposeA=").concat(s)+" and transposeB=".concat(i," must match.")));const v=i?[b,p,h]:[b,h,p],x=xS({inputs:{x:r},backend:n,attrs:{shape:s?[m,u,d]:[m,d,u]}}),w=xS({inputs:{x:o},backend:n,attrs:{shape:v}}),k=s?x.shape[1]:x.shape[2],S=s?x.shape[2]:x.shape[1],I=i?w.shape[1]:w.shape[2],C=Math.max(m,b),N=n.data.get(x.dataId).values,E=n.data.get(w.dataId).values,T=Qt(x.shape),R=Qt(w.shape),[A,F,D]=s?[T[0],1,T[1]]:[T[0],T[1],1],[_,O,L]=i?[1,R[1],R[0]]:[R[1],1,R[0]],z=S*I,M=Yi([C,S,I],x.dtype),P=M.values,B=n.blockSize;for(let W=0;W<C;W++){const e=W%m,t=W%b;for(let n=0;n<S;n+=B){const a=Math.min(n+B,S);for(let r=0;r<I;r+=B){const o=Math.min(r+B,I);for(let s=0;s<k;s+=B){const i=Math.min(s+B,k);for(let l=n;l<a;l++)for(let n=r;n<o;n++){let a=0;for(let r=s;r<i;r++){a+=N[e*A+l*F+r*D]*E[r*_+n*O+t*L]}P[W*z+(l*I+n)]+=a}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,M.dtype,M.values)}const SS={kernelName:Ln,backendName:"cpu",kernelFunc:kS};const IS={kernelName:No,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o,bias:s,preluActivationWeights:i}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=a;let d,p,f;const g=[];d=kS({inputs:{a:r,b:o},attrs:{transposeA:l,transposeB:c},backend:n}),s&&(p=yS({inputs:{a:d,b:s},backend:n}),g.push(d),d=p),u&&(f=oS(n,d,u,i,h),g.push(d),d=f);for(const m of g)n.disposeIntermediateTensorInfo(m);return d}};function CS(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const NS={kernelName:bn,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;zk(t,"abs");let a=new Float32Array(Ot(t.shape));return a=CS(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,t.dtype)}},ES=Wk(yn,(e=>Math.acos(e))),TS={kernelName:yn,backendName:"cpu",kernelFunc:ES},RS=Wk(vn,(e=>Math.acosh(e))),AS={kernelName:vn,backendName:"cpu",kernelFunc:RS};const FS={kernelName:wn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;zk(t,"addN");const r=a.map((e=>n.data.get(e.dataId).values)),o=Yi(a[0].shape,a[0].dtype),s=o.values;for(let i=0;i<a.length;i++){const e=r[i];for(let t=0;t<s.length;t++)s[t]+=e[t]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}};function DS(e,t,n,a,r){const o=t.length,s=Ot(t),i=Qt(t),l=Qt(r),c=Gt(n,Ot(r));for(let u=0;u<s;++u){const t=sn(u,o,i),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[a[e]];c[on(n,o,l)]=e[u]}return c}function _S(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:o}=n;zk(r,"transpose");const s=r.shape.length,i=new Array(s);for(let c=0;c<i.length;c++)i[c]=r.shape[o[c]];const l=DS(a.data.get(r.dataId).values,r.shape,r.dtype,o,i);return{dataId:a.write(l,i,r.dtype),shape:i,dtype:r.dtype}}const OS={kernelName:yo,backendName:"cpu",kernelFunc:_S};const LS={kernelName:kn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;zk(r,"all");const i=Ut(o,r.shape);let l=i;const c=fu(l,r.shape.length);let u=r;null!=c&&(u=_S({inputs:{x:r},backend:n,attrs:{perm:c}}),l=mu(l.length,r.shape.length)),pu("all",l,u.shape.length);const[h,d]=hu(u.shape,l),p=Ot(d),f=nn(Ot(h),u.dtype),g=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=g[e];for(let n=0;n<p;++n){const a=g[e+n];t=t&&a}f[b]=t}null!=c&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(h,u.dtype,f);if(s){const e=xS({inputs:{x:m},backend:n,attrs:{shape:du(h,i)}});return n.disposeIntermediateTensorInfo(m),e}return m}};const zS={kernelName:Sn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;zk(r,"any");const i=Ut(o,r.shape);let l=i;const c=fu(l,r.shape.length);let u=r;null!=c&&(u=_S({inputs:{x:r},backend:n,attrs:{perm:c}}),l=mu(l.length,r.shape.length)),pu("any",l,u.shape.length);const[h,d]=hu(u.shape,l),p=Ot(d),f=nn(Ot(h),u.dtype),g=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=g[e];for(let n=0;n<p;++n){const a=g[e+n];t=t||a}f[b]=t}null!=c&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(h,u.dtype,f);if(s){const e=xS({inputs:{x:m},backend:n,attrs:{shape:du(h,i)}});return n.disposeIntermediateTensorInfo(m),e}return m}};const MS={kernelName:In,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;zk(r,"argMax");let s=Ut(o,r.shape);const i=fu(s,r.shape.length);let l=r;const c=[];null!=i&&(l=_S({inputs:{x:r},backend:n,attrs:{perm:i}}),c.push(l),s=mu(s.length,l.shape.length)),s=[s[0]],pu("argMax",s,l.shape.length);const[u,h]=hu(l.shape,s),d=nn(Ot(u),"int32"),p=Ot(h),f=n.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const e=g*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r>t&&(t=r,n=a)}d[g]=n}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",d)}};const PS={kernelName:Cn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;zk(r,"argMin");let s=Ut(o,r.shape);const i=fu(s,r.shape.length);let l=r;const c=[];null!=i&&(l=_S({inputs:{x:r},backend:n,attrs:{perm:i}}),c.push(l),s=mu(s.length,l.shape.length)),s=[s[0]],pu("argMin",s,l.shape.length);const[u,h]=hu(l.shape,s),d=nn(Ot(u),"int32"),p=Ot(h),f=n.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const e=g*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r<t&&(t=r,n=a)}d[g]=n}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",d)}},BS=Wk(Nn,(e=>Math.asin(e))),WS={kernelName:Nn,backendName:"cpu",kernelFunc:BS},US=Wk(En,(e=>Math.asinh(e))),VS={kernelName:En,backendName:"cpu",kernelFunc:US},GS=Wk(Tn,(e=>Math.atan(e))),jS={kernelName:Tn,backendName:"cpu",kernelFunc:GS},HS=Xk(((e,t)=>Math.atan2(e,t))),KS=fS(An,HS),qS={kernelName:An,backendName:"cpu",kernelFunc:KS},XS=Wk(Rn,(e=>Math.atanh(e))),YS={kernelName:Rn,backendName:"cpu",kernelFunc:XS};function JS(e,t,n,a,r,o){const s=r.strideHeight,i=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,u=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Yi(r.outShape,n),m=g.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],y=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let x=0;x<r.batchSize;++x){const t=x*b,n=x*a[0];for(let g=0;g<r.inChannels;++g)for(let b=0;b<r.outHeight;++b){const x=b*s-d,w=Math.max(0,x),k=Math.min(r.inHeight,u+x),S=t+b*y;for(let t=0;t<r.outWidth;++t){const s=t*i-p,u=Math.max(0,s),d=Math.min(r.inWidth,h+s);let b=f,y=0,x=0;for(let t=w;t<k;t+=l){const r=n+t*a[1];for(let t=u;t<d;t+=c){const n=e[r+t*a[2]+g];"max"===o&&n>b?b=n:"avg"===o&&(y+=n,x++)}if(isNaN(b))break}m[S+t*v+g]="avg"===o?y/x:b}}}return g}function $S(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=Yi(a.outShape,"int32"),i=a.strideHeight,l=a.strideWidth,c=a.dilationHeight,u=a.dilationWidth,h=a.effectiveFilterHeight,d=a.effectiveFilterWidth,p=a.padInfo.top,f=a.padInfo.left,g=Yi(t,n,e);for(let m=0;m<a.batchSize;++m)for(let e=0;e<a.inChannels;++e)for(let t=0;t<a.outHeight;++t){const n=t*i-p;let b=n;for(;b<0;)b+=c;const y=Math.min(a.inHeight,h+n);for(let i=0;i<a.outWidth;++i){const h=i*l-f;let p=h;for(;p<0;)p+=u;const v=Math.min(a.inWidth,d+h);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<y;t+=c){const s=t-n;for(let n=p;n<v;n+=u){const i=n-h,l=g.get(m,t,n,e);l>x&&(x=l,w=r?o?((m*a.inHeight+t)*a.inWidth+n)*a.inChannels+e:(t*a.inWidth+n)*a.inChannels+e:s*d+i)}}s.set(w,m,t,i,e)}}return s}function QS(e,t,n,a,r,o){const s=r.strideDepth,i=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,u=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,g=r.padInfo.front,m=r.padInfo.top,b=r.padInfo.left,y="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Yi(r.outShape,n),x=v.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],S=r.outShape[3]*r.outShape[4],I=r.outShape[4];for(let C=0;C<r.batchSize;++C){const t=C*w,n=C*a[0];for(let v=0;v<r.inChannels;++v)for(let w=0;w<r.outDepth;++w){const C=w*s-g;let N=C;for(;N<0;)N+=c;const E=Math.min(r.inDepth,d+C),T=t+w*k;for(let t=0;t<r.outHeight;++t){const s=t*i-m;let d=s;for(;d<0;)d+=u;const g=Math.min(r.inHeight,p+s),w=T+t*S;for(let t=0;t<r.outWidth;++t){const s=t*l-b;let i=s;for(;i<0;)i+=h;const p=Math.min(r.inWidth,f+s),m=w+t*I;let k=y,S=0,C=0;for(let t=N;t<E;t+=c){const r=n+t*a[1];for(let t=d;t<g;t+=u){const n=r+t*a[2];for(let t=i;t<p;t+=h){const r=e[n+t*a[3]+v];if("max"===o&&r>k?k=r:"avg"===o&&(S+=r,C++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[m+v]="avg"===o?S/Math.max(C,1):k}}}}return v}const ZS={kernelName:Fn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;zk(r,"avgPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:l}=a;Ft(vc(s,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const c=cc(r.shape,o,s,1,i,l);let u;if(1===c.filterWidth&&1===c.filterHeight&&Lt(c.inShape,c.outShape))u=jk({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Qt(r.shape),a=JS(e,r.shape,r.dtype,t,c,"avg");u=n.makeTensorInfo(c.outShape,r.dtype,a.values)}return u}};const eI={kernelName:_n,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:l,dataFormat:c}=a;zk(r,"avgPool3d");const u=uc(r.shape,o,s,1,i,l,c),h=QS(n.data.get(r.dataId).values,r.shape,r.dtype,Qt(r.shape),u,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const tI={kernelName:On,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,{filterSize:s,strides:i,pad:l,dimRoundingMode:c}=a;zk([r,o],"avgPool3DGrad");const u=uc(o.shape,s,i,1,l,c),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,g=u.filterHeight,m=u.filterWidth,b=u.dilationDepth,y=u.dilationHeight,v=u.dilationWidth,x=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,S=x-1-u.padInfo.front,I=k-1-u.padInfo.left,C=w-1-u.padInfo.top,N=Yi(o.shape,"float32"),E=1/(f*g*m),T=n.bufferSync(r);for(let R=0;R<u.batchSize;++R)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-S,o=n-C,s=a-I;let i=0;for(let t=0;t<x;t+=b){const n=(r+t)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=y){const a=(o+t)/d;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let t=0;t<k;t+=v){const r=(s+t)/p;if(r<0||r>=u.outWidth||Math.floor(r)!==r)continue;i+=T.get(R,n,a,r,e)}}}N.set(i*E,R,t,n,a,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};const nI={kernelName:Dn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o;zk([r,o],"avgPoolGrad");const{filterSize:i,strides:l,pad:c}=a,u=cc(s.shape,i,l,1,c),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,g=u.dilationHeight,m=u.dilationWidth,b=u.effectiveFilterHeight,y=u.effectiveFilterWidth,v=y-1-u.padInfo.left,x=b-1-u.padInfo.top,w=Yi(s.shape,"float32"),k=1/(p*f),S=n.data.get(r.dataId).values,I=Yi(r.shape,"float32",S);for(let C=0;C<u.batchSize;++C)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inHeight;++t)for(let n=0;n<u.inWidth;++n){const a=t-x,r=n-v;let o=0;for(let t=0;t<b;t+=g){const n=(a+t)/h;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let t=0;t<y;t+=m){const a=(r+t)/d;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;o+=I.get(C,n,a,e)}}w.set(o*k,C,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const aI={kernelName:Ea,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,scale:o,offset:s,mean:i,variance:l}=t;Ft(i.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Ft(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Ft(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),zk([r,i,l,o,s],"batchNorm");let{varianceEpsilon:c}=a;null==c&&(c=.001);const u=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,d=n.data.get(l.dataId).values,p=o?n.data.get(o.dataId).values:new Float32Array([1]),f=s?n.data.get(s.dataId).values:new Float32Array([0]),g=new Float32Array(u.length),m=f.length,b=p.length,y=d.length,v=h.length;let x=0,w=0,k=0,S=0;for(let I=0;I<u.length;++I)g[I]=f[x++]+(u[I]-h[w++])*p[k++]/Math.sqrt(d[S++]+c),x>=m&&(x=0),w>=v&&(w=0),k>=b&&(k=0),S>=y&&(S=0);return n.makeTensorInfo(r.shape,r.dtype,g)}};function rI(e,t,n,a,r){const o=ec(a,t,n),s=Ot(n),i=Qt(a);if(o){const n=tc(t,i);return"string"===r?e.slice(n,n+s):e.subarray(n,n+s)}const l=Yi(a,r,"string"===r?kp(e):e),c=Yi(n,r);for(let u=0;u<c.size;++u){const e=c.indexToLoc(u),n=e.map(((e,n)=>e+t[n]));c.set(l.get(...n),...e)}return"string"===r?Sp(c.values):c.values}function oI(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,size:s}=a;zk(r,"slice");const[i,l]=nc(r,o,s);Vl(r,i,l);const c=rI(n.data.get(r.dataId).values,i,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,c)}const sI={kernelName:Vr,backendName:"cpu",kernelFunc:oI};const iI={kernelName:zn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,crops:s}=a;zk([r],"batchToSpaceND");const i=o.reduce(((e,t)=>e*t)),l=Cd(r.shape,o,i),c=Nd(l.length,o.length),u=Ed(r.shape,o,i),h=Td(s,o.length),d=Rd(u,s,o.length),p=xS({inputs:{x:r},backend:n,attrs:{shape:l}}),f=_S({inputs:{x:p},backend:n,attrs:{perm:c}}),g=xS({inputs:{x:f},backend:n,attrs:{shape:u}}),m=oI({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}};function lI(e,t,n,a,r){const o=Ot(a),s=nn(r,n);for(let i=0;i<e.length;i++){const n=e[i];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(s[n]+=o>0?t[i]:1)}return s}function cI(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e.shape[0],o=e.shape[1],s=Yi([r,n],t.dtype);for(let i=0;i<r;i++)for(let r=0;r<o;r++){const o=e.get(i,r);if(o<0)throw new Error("Input x must be non-negative!");o>=n||(a?s.set(1,i,o):t.size>0?s.set(s.get(i,o)+t.get(i,r),i,o):s.set(s.get(i,o)+1,i,o))}return s}const uI={kernelName:Mn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s}=a,i=lI(n.data.get(r.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,i)}},hI=Xk(((e,t)=>e&t)),dI={kernelName:Pn,backendName:"cpu",kernelFunc:fS(Pn,hI)};const pI={kernelName:Bn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,i=kl(Array.from(o),Array.from(s));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},fI=Bk((e=>Math.ceil(e))),gI=Uk(Un,fI),mI={kernelName:Un,backendName:"cpu",kernelFunc:gI},bI=Wk(Vn,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),yI={kernelName:Vn,backendName:"cpu",kernelFunc:bI},vI={kernelName:jn,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(Ot(t.shape)),r=n.data.get(t.dataId),o=r.complexTensorInfos.real,s=r.complexTensorInfos.imag,i=n.data.get(o.dataId).values,l=n.data.get(s.dataId).values;for(let c=0;c<i.length;c++){const e=i[c],t=l[c];a[c]=Math.hypot(e,t)}return n.makeOutput(a,t.shape,"float32")}};function xI(e,t,n,a){const r=jt(n,Ot(t));if(a&&"string"!==n){let t=0;e.forEach((e=>{const n=Ot(e.shape);r.set(e.vals,t),t+=n}))}else{let a=0;e.forEach((e=>{const o="string"===n?kp(e.vals):e.vals;let s=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+a;for(let t=0;t<e.shape[1];++t)r[i+t]=o[s++]}a+=e.shape[1]}))}return r}function wI(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const kI={kernelName:Oa,backendName:"cpu",kernelFunc:wI};function SI(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,o=Ut(r,t[0].shape)[0],s=t.map((e=>e.shape));gd(s,o);let i=md(t.map((e=>e.shape)),o);if(0===Ot(i))return n.makeTensorInfo(i,t[0].dtype,[]);const l=t.filter((e=>Ot(e.shape)>0));if(1===l.length)return jk({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){const e=l.map((e=>cS({inputs:{input:e},backend:n}))),t=l.map((e=>wI({inputs:{input:e},backend:n}))),a=SI({inputs:e,backend:n,attrs:{axis:o}}),r=SI({inputs:t,backend:n,attrs:{axis:o}}),s=sS({inputs:{real:a,imag:r},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),s}const c=l.map((e=>{const t=Ot(e.shape.slice(o));return xS({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=c.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=md(c.map((e=>e.shape)),1);const h=1===c[0].shape[0],d=xI(u,i,t[0].dtype,h),p=md(l.map((e=>e.shape)),o),f=n.makeTensorInfo(p,t[0].dtype,d);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const II={kernelName:Hn,backendName:"cpu",kernelFunc:SI};function CI(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dataFormat:l,dilations:c,dimRoundingMode:u}=a;zk([r,o],"conv2d");const h=wc(l),d=hc(r.shape,o.shape,s,c,i,u,!1,h),p=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,m=d.dilationWidth,b=d.padInfo.left,y=d.padInfo.top,v="channelsLast"===d.dataFormat,x=new gs(d.outShape,r.dtype),w=Qt(r.shape),k=Qt(o.shape),S=w[0],I=v?w[1]:w[2],C=v?w[2]:1,N=v?1:w[1],E=x.strides[0],T=v?x.strides[1]:x.strides[2],R=v?x.strides[2]:1,A=v?1:x.strides[1],F=n.data.get(r.dataId).values,D=n.data.get(o.dataId).values,_=x.values;for(let O=0;O<d.batchSize;++O){const e=O*S,t=O*E;for(let n=0;n<d.outHeight;++n){const a=t+n*T,r=n*d.strideHeight-y;for(let t=0;t<p;++t){const n=r+t*g;if(n<0||n>=d.inHeight)continue;const o=t*k[0],s=e+n*I;for(let e=0;e<d.outWidth;++e){const t=a+e*R,n=e*d.strideWidth-b;for(let e=0;e<f;++e){const a=n+e*m;if(a<0||a>=d.inWidth)continue;const r=s+a*C;let i=o+e*k[1];for(let e=0;e<d.inChannels;++e){const n=F[r+e*N];for(let e=0;e<d.outChannels;++e)_[t+e*A]+=n*D[i+e];i+=d.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,_)}const NI={kernelName:Kn,backendName:"cpu",kernelFunc:CI};const EI={kernelName:qn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,dataFormat:l,dimRoundingMode:c,filterShape:u}=a;zk([r,o],"conv2dBackpropFilter");const h=wc(l),d=hc(r.shape,u,s,1,i,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=d,b="channelsLast"===d.dataFormat,y=new gs(d.filterShape,"float32"),v=d.padInfo.left,x=d.padInfo.top,w=n.data.get(r.dataId).values,k=n.data.get(o.dataId).values,S=new gs(r.shape,r.dtype,w),I=new gs(o.shape,o.dtype,k);for(let C=0;C<g;++C){const e=Math.max(0,Math.ceil((x-C)/p)),t=Math.min(d.outHeight,(d.inHeight+x-C)/p);for(let n=0;n<m;++n){const a=Math.max(0,Math.ceil((v-n)/f)),r=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let o=0;o<d.inChannels;++o)for(let s=0;s<d.outChannels;++s){let i=0;for(let l=0;l<d.batchSize;++l)for(let c=e;c<t;++c){const e=C+c*p-x;for(let t=a;t<r;++t){const a=n+t*f-v;i+=b?S.get(l,e,a,o)*I.get(l,c,t,s):S.get(l,o,e,a)*I.get(l,s,c,t)}}y.set(i,C,n,o,s)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const TI={kernelName:Xn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{inputShape:s,strides:i,pad:l,dataFormat:c,dimRoundingMode:u}=a;zk([r,o],"conv2dBackpropInput");const h=Qt(o.shape),d=Qt(r.shape);let p=wc(c);const f=hc(s,o.shape,i,1,l,u,!1,p),g=new gs(f.inShape,"float32"),m=g.values,b=n.data.get(r.dataId).values,y=n.data.get(o.dataId).values,[v,x,w]=h,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:C,inHeight:N,inWidth:E,outChannels:T,outHeight:R,outWidth:A,strideHeight:F,strideWidth:D}=f;p=f.dataFormat;const _=S-1-f.padInfo.top,O=I-1-f.padInfo.left,L="channelsLast"===p,z=g.strides[0],M=L?g.strides[1]:g.strides[2],P=L?g.strides[2]:1,B=L?1:g.strides[1],W=d[0],U=L?d[1]:d[2],V=L?d[2]:1,G=L?1:d[1];for(let j=0;j<k;++j)for(let e=0;e<C;++e)for(let t=0;t<N;++t){const n=t-_,a=Math.max(0,Math.ceil(n/F)),r=Math.min(R,(S+n)/F);for(let o=0;o<E;++o){const s=o-O,i=Math.max(0,Math.ceil(s/D)),l=Math.min(A,(I+s)/D);let c=0;for(let t=a;t<r;++t){const a=t*F-n;for(let n=i;n<l;++n){const r=W*j+U*t+V*n,o=v*(S-1-a)+x*(I-1-(n*D-s))+w*e;for(let e=0;e<T;++e){c+=b[r+G*e]*y[o+e]}}}m[z*j+M*t+P*o+B*e]=c}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const RI={kernelName:Yn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:l}=a;zk([r,o],"conv3d");const c=dc(r.shape,o.shape,s,l,i),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=c,b=m.front,y=m.left,v=m.top,x=new gs(c.outShape,r.dtype),w=n.data.get(r.dataId).values,k=n.data.get(o.dataId).values,S=x.values,I=Qt(r.shape),C=Qt(o.shape);for(let N=0;N<c.batchSize;++N){const e=N*I[0],t=N*x.strides[0];for(let n=0;n<c.outDepth;++n){const a=t+n*x.strides[1],r=n*c.strideDepth-b;for(let t=0;t<u;++t){const n=r+t*p;if(n<0||n>=c.inDepth)continue;const o=t*C[0],s=e+n*I[1];for(let e=0;e<c.outHeight;++e){const t=a+e*x.strides[2],n=e*c.strideHeight-v;for(let e=0;e<h;++e){const a=n+e*f;if(a<0||a>=c.inHeight)continue;const r=o+e*C[1],i=s+a*I[2];for(let e=0;e<c.outWidth;++e){const n=t+e*c.outChannels,a=e*c.strideWidth-y;for(let e=0;e<d;++e){const t=a+e*g;if(t<0||t>=c.inWidth)continue;const o=r+e*C[2],s=i+t*c.inChannels;let l=o;for(let e=0;e<c.inChannels;++e){const t=w[s+e];for(let e=0;e<c.outChannels;++e)S[n+e]+=t*k[l+e];l+=c.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const AI={kernelName:Jn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,filterShape:l}=a;zk([r,o],"conv3dBackpropFilterV2");const c=Qt(r.shape),u=Qt(o.shape),h=dc(r.shape,l,s,1,i),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,g=h.filterDepth,m=h.filterHeight,b=h.filterWidth,y=new gs(h.filterShape,"float32"),v=y.values,[x,w,k,S]=y.strides,I=n.data.get(o.dataId).values,[C,N,E,T]=u,R=n.data.get(r.dataId).values,[A,F,D,_]=c,O=h.padInfo.front,L=h.padInfo.left,z=h.padInfo.top;for(let M=0;M<g;++M){const e=Math.max(0,Math.ceil((O-M)/d)),t=Math.min(h.outDepth,(h.inDepth+O-M)/d),n=M*x;for(let a=0;a<m;++a){const r=Math.max(0,Math.ceil((z-a)/p)),o=Math.min(h.outHeight,(h.inHeight+z-a)/p),s=a*w+n;for(let n=0;n<b;++n){const i=Math.max(0,Math.ceil((L-n)/f)),l=Math.min(h.outWidth,(h.inWidth+L-n)/f),c=n*k+s;for(let s=0;s<h.inChannels;++s){const u=s*S+c;for(let c=0;c<h.outChannels;++c){let g=0;for(let u=0;u<h.batchSize;++u){const h=u*A,m=u*C;for(let u=e;u<t;++u){const e=(M+u*d-O)*F+h,t=u*N+m;for(let u=r;u<o;++u){const r=(a+u*p-z)*D+e,o=u*E+t;for(let e=i;e<l;++e){const t=e*T+o;g+=R[(n+e*f-L)*_+r+s]*I[t+c]}}}}v[u+c]=g}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const FI={kernelName:$n,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{pad:s,strides:i,inputShape:l}=a;zk([r],"conv3dBackpropInputV2");const c=Qt(r.shape),u=Qt(o.shape),h=dc(l,o.shape,i,1,s),d=new gs(h.inShape,"float32"),p=d.values,[f,g,m,b]=d.strides,y=n.data.get(r.dataId).values,[v,x,w,k]=c,S=n.data.get(o.dataId).values,[I,C,N,E]=u,{batchSize:T,filterDepth:R,filterHeight:A,filterWidth:F,inChannels:D,inDepth:_,inHeight:O,inWidth:L,outChannels:z,outDepth:M,outHeight:P,outWidth:B,strideDepth:W,strideHeight:U,strideWidth:V}=h,G=R-1-h.padInfo.front,j=A-1-h.padInfo.top,H=F-1-h.padInfo.left;for(let K=0;K<T;++K)for(let e=0;e<D;++e)for(let t=0;t<_;++t){const n=t-G,a=Math.max(0,Math.ceil(n/W)),r=Math.min(M,(R+n)/W);for(let o=0;o<O;++o){const s=o-j,i=Math.max(0,Math.ceil(s/U)),l=Math.min(P,(A+s)/U);for(let c=0;c<L;++c){const u=c-H,h=Math.max(0,Math.ceil(u/V)),d=Math.min(B,(F+u)/V);let T=0;for(let t=a;t<r;++t){const a=t*W-n;for(let n=i;n<l;++n){const r=n*U-s;for(let o=h;o<d;++o){const s=v*K+x*t+w*n+k*o,i=I*(R-1-a)+C*(A-1-r)+N*(F-1-(o*V-u))+E*e;for(let e=0;e<z;++e){T+=y[s+e]*S[i+e]}}}}p[f*K+g*t+m*o+b*c+e]=T}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},DI=Wk(Qn,(e=>Math.cos(e))),_I={kernelName:Qn,backendName:"cpu",kernelFunc:DI},OI=Wk(Zn,(e=>Math.cosh(e))),LI={kernelName:Zn,backendName:"cpu",kernelFunc:OI};const zI={kernelName:na,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:o,boxInd:s}=t,{cropSize:i,method:l,extrapolationValue:c}=a,[u,h,d,p]=r.shape,f=o.shape[0],[g,m]=i,b=Yi([f,g,m,p],"float32"),y=n.data.get(o.dataId).values,v=n.data.get(s.dataId).values,x=n.data.get(r.dataId).values,w=Qt(r.shape),k=Qt(b.shape);for(let S=0;S<f;S++){const e=4*S,t=y[e],n=y[e+1],a=y[e+2],r=y[e+3],o=v[S];if(o>=u)continue;const s=g>1?(a-t)*(h-1)/(g-1):0,i=m>1?(r-n)*(d-1)/(m-1):0;for(let u=0;u<g;u++){const e=g>1?t*(h-1)+u*s:.5*(t+a)*(h-1);if(e<0||e>h-1)for(let t=0;t<m;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];b.values[n]=c}else if("bilinear"===l){const t=Math.floor(e),a=Math.ceil(e),s=e-t;for(let e=0;e<m;e++){const l=m>1?n*(d-1)+e*i:.5*(n+r)*(d-1);if(l<0||l>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+S*k[0];b.values[n]=c}continue}const h=Math.floor(l),f=Math.ceil(l),g=l-h;for(let n=0;n<p;n++){let r=n+h*w[2]+t*w[1]+o*w[0];const i=x[r];r=n+f*w[2]+t*w[1]+o*w[0];const l=x[r];r=n+h*w[2]+a*w[1]+o*w[0];const c=x[r];r=n+f*w[2]+a*w[1]+o*w[0];const d=i+(l-i)*g,p=c+(x[r]-c)*g;r=n+e*k[2]+u*k[1]+S*k[0],b.values[r]=d+(p-d)*s}}}else for(let t=0;t<m;++t){const a=m>1?n*(d-1)+t*i:.5*(n+r)*(d-1);if(a<0||a>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];b.values[n]=c}continue}const s=Math.round(a),l=Math.round(e);for(let e=0;e<p;e++){const n=e+s*w[2]+l*w[1]+o*w[0],a=e+t*k[2]+u*k[1]+S*k[0];b.values[a]=x[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const MI={kernelName:ea,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;zk(r,"cumprod");const l=fu([o],r.shape.length);let c=r;null!=l&&(c=_S({inputs:{x:r},backend:n,attrs:{perm:l}}));const u=mu(1,r.shape.length)[0];if(u!==c.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(c.shape.length-1," but got axis=").concat(u));const h=Ts(c.dtype,"int32"),d=tn(Ot(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=g(b,e);if(0===e)d[t]=s?1:p[t];else{const n=g(b,e-1);d[t]=s?p[n]*d[n]:p[t]*d[n]}}const m=n.makeTensorInfo(c.shape,h,d);if(null!=l){const e=_S({inputs:{x:m},backend:n,attrs:{perm:gu(l)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),e}return m}};const PI={kernelName:ta,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;zk(r,"cumsum");const l=fu([o],r.shape.length);let c=r;null!=l&&(c=_S({inputs:{x:r},backend:n,attrs:{perm:l}}));const u=mu(1,r.shape.length)[0];if(u!==c.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(c.shape.length-1," but got axis=").concat(u));const h=Ts(c.dtype,"int32"),d=nn(Ot(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=g(b,e);if(0===e)d[t]=s?0:p[t];else{const n=g(b,e-1);d[t]=s?p[n]+d[n]:p[t]+d[n]}}const m=n.makeTensorInfo(c.shape,h,d);if(null!=l){const e=_S({inputs:{x:m},backend:n,attrs:{perm:gu(l)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),e}return m}};const BI={kernelName:aa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s,binaryOutput:i}=a;if(1===r.shape.length){const e=lI(n.data.get(r.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,e)}if(2===r.shape.length){const e=cI(n.bufferSync(r),n.bufferSync(o),s,i);return n.makeTensorInfo(e.shape,o.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};const WI={kernelName:ra,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:o,dataFormat:s}=a;Ft("NHWC"===s,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(s)));const i=r.shape[0],l=r.shape[1],c=r.shape[2],u=r.shape[3],h=l*o,d=c*o,p=u/(o*o),f=n.data.get(r.dataId).values,g=new Float32Array(i*h*d*p);let m=0;for(let b=0;b<i;++b)for(let e=0;e<h;++e){const t=Math.floor(e/o),n=e%o;for(let e=0;e<d;++e){const a=Math.floor(e/o),r=(n*o+e%o)*p;for(let e=0;e<p;++e){const n=e+r+u*(a+c*(t+l*b));g[m++]=f[n]}}}return n.makeTensorInfo([i,h,d,p],r.dtype,g)}};function UI(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:l,dimRoundingMode:c}=a;zk([r,o],"depthwiseConv2DNative");const u=Qt(r.shape),h=Qt(o.shape);let d=l;null==d&&(d=[1,1]),Ft(vc(s,d),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(s," and dilations '").concat(d,"'")));const p=hc(r.shape,o.shape,s,d,i,c,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:b,padInfo:y}=p,v=y.left,x=y.top,w=p.outChannels/p.inChannels,k=new gs(p.outShape,r.dtype),S=n.data.get(r.dataId).values,I=n.data.get(o.dataId).values,C=k.values;for(let N=0;N<p.batchSize;++N){const e=N*u[0],t=N*k.strides[0];for(let n=0;n<p.outHeight;++n){const a=t+n*k.strides[1],r=n*p.strideHeight-x;for(let t=0;t<f;++t){const n=r+t*m;if(n<0||n>=p.inHeight)continue;const o=t*h[0],s=e+n*u[1];for(let e=0;e<p.outWidth;++e){const t=a+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<g;++e){const a=n+e*b;if(a<0||a>=p.inWidth)continue;const r=o+e*h[1],i=s+a*p.inChannels;let l=t,c=r;for(let e=0;e<p.inChannels;++e){const t=S[i+e];for(let e=0;e<w;++e)C[l+e]+=t*I[c+e];l+=w,c+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const VI={kernelName:oa,backendName:"cpu",kernelFunc:UI};const GI={kernelName:sa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,dilations:i,pad:l,dimRoundingMode:c,filterShape:u}=a;zk([r,o],"depthwiseConv2dNativeBackpropFilter");const h=hc(r.shape,u,s,i,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:g}=h,m=new gs(h.filterShape,"float32"),b=h.padInfo.left,y=h.padInfo.top,v=h.outChannels/h.inChannels,x=n.data.get(r.dataId).values,w=new gs(r.shape,r.dtype,x),k=n.data.get(o.dataId).values,S=new gs(o.shape,o.dtype,k);for(let I=0;I<f;++I){const e=Math.max(0,Math.ceil((y-I)/d)),t=Math.min(h.outHeight,(h.inHeight+y-I)/d);for(let n=0;n<g;++n){const a=Math.max(0,Math.ceil((b-n)/p)),r=Math.min(h.outWidth,(h.inWidth+b-n)/p);for(let o=0;o<h.outChannels;++o){const s=Math.trunc(o/v),i=o%v;let l=0;for(let c=0;c<h.batchSize;++c)for(let i=e;i<t;++i){const e=I+i*d-y;for(let t=a;t<r;++t){const a=n+t*p-b;l+=w.get(c,e,a,s)*S.get(c,i,t,o)}}m.set(l,I,n,s,i)}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const jI={kernelName:ia,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{strides:s,dilations:i,pad:l,dimRoundingMode:c,inputShape:u}=a;zk([r,o],"depthwiseConv2DNativeBackpropInput");const h=Qt(r.shape),d=Qt(o.shape),p=hc(u,o.shape,s,i,l,c,!0),f=new gs(p.inShape,"float32"),g=f.values,[m,b,y]=f.strides,v=n.data.get(r.dataId).values,[x,w,k]=h,S=n.data.get(o.dataId).values,[I,C,N]=d,{batchSize:E,filterHeight:T,filterWidth:R,inChannels:A,inHeight:F,inWidth:D,outChannels:_,outHeight:O,outWidth:L,strideHeight:z,strideWidth:M}=p,P=T-1-p.padInfo.top,B=R-1-p.padInfo.left,W=_/A;for(let U=0;U<E;++U)for(let e=0;e<A;++e)for(let t=0;t<F;++t){const n=t-P,a=Math.max(0,Math.ceil(n/z)),r=Math.min(O,(T+n)/z);for(let o=0;o<D;++o){const s=o-B,i=Math.max(0,Math.ceil(s/M)),l=Math.min(L,(R+s)/M);let c=0;for(let t=a;t<r;++t){const a=t*z-n;for(let n=i;n<l;++n){const r=x*U+w*t+k*n,o=I*(T-1-a)+C*(R-1-(n*M-s))+N*e;for(let t=0;t<W;++t){c+=v[r+(e*W+t)]*S[o+t]}}}g[m*U+b*t+y*o+e]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const HI={kernelName:la,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=Ot(a.shape),o=n.data.get(a.dataId).values,s=Yi([r,r],a.dtype),i=s.values;for(let c=0;c<o.length;c++)i[c*r+c]=o[c];const l=[...a.shape,...a.shape];return n.makeTensorInfo(l,s.dtype,s.values)}},KI={kernelName:ca,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o}=t,{strides:s,pad:i,dilations:l}=a,c=n,u=c.data.get(r.dataId).values,h=r.shape.length,d=c.data.get(o.dataId).values,p=o.shape.length,{batchSize:f,inHeight:g,inWidth:m,inChannels:b,outHeight:y,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:C,dilationWidth:N,outShape:E}=lc(r.shape,o.shape,s,i,"NHWC",l),T=Ot(E),R=E.length,A=jt(r.dtype,T);for(let F=0;F<f;++F)for(let e=0;e<y;++e){const t=e*w-x.top;for(let n=0;n<v;++n){const a=n*k-x.left;for(let s=0;s<b;++s){let i=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*C;if(n>=0&&n<g)for(let t=0;t<I;++t){const l=a+t*N;if(l>=0&&l<m){const a=on([F,n,l,s],h,Qt(r.shape)),c=on([e,t,s],p,Qt(o.shape)),f=u[a]+d[c];f>i&&(i=f)}}}A[on([F,e,n,s],R,Qt(E))]=i}}}return{dataId:c.write(ts(A,r.dtype),E,r.dtype),shape:E,dtype:r.dtype}}},qI={kernelName:ha,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o,dy:s}=t,{strides:i,pad:l,dilations:c}=a,u=n,h=en(r.shape,u.data.get(r.dataId).values),d=en(o.shape,u.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:y,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:N}=lc(r.shape,o.shape,i,l,"NHWC",c);Ft(s.rank===N.length,(()=>"Error in ".concat(ha,", dy ")+"must have the same rank as output ".concat(N.length,", but got ")+"".concat(s.rank)));const E=en(N,u.data.get(s.dataId).values),T=an(o.shape,o.dtype);for(let R=0;R<p;++R)for(let e=0;e<b;++e){const t=e*x-v.top;for(let n=0;n<y;++n){const a=n*w-v.left;for(let r=0;r<m;++r){let o=Number.MIN_SAFE_INTEGER,s=0,i=0;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=a+t*C;if(l>=0&&l<g){const a=h[R][n][l][r]+d[e][t][r];a>o&&(o=a,s=e,i=t)}}}T[s][i][r]+=E[R][e][n][r]}}}return{dataId:u.write(ts(T,r.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},XI={kernelName:ua,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o,dy:s}=t,{strides:i,pad:l,dilations:c}=a,u=n,h=en(r.shape,u.data.get(r.dataId).values),d=en(o.shape,u.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:y,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:N}=lc(r.shape,o.shape,i,l,"NHWC",c);Ft(s.rank===N.length,(()=>"Error in ".concat(ua,", dy ")+"must have the same rank as output ".concat(N.length,", but got ")+"".concat(s.rank)));const E=en(N,u.data.get(s.dataId).values),T=an(r.shape,r.dtype);for(let R=0;R<p;++R)for(let e=0;e<b;++e){const t=e*x-v.top;for(let n=0;n<y;++n){const a=n*w-v.left;for(let r=0;r<m;++r){let o=Number.MIN_SAFE_INTEGER,s=t<0?0:t,i=a<0?0:a;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=a+t*C;if(l>=0&&l<g){const a=h[R][n][l][r]+d[e][t][r];a>o&&(o=a,s=n,i=l)}}}T[R][s][i][r]+=E[R][e][n][r]}}}return{dataId:u.write(ts(T,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const YI={kernelName:da,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:o,options:s}=a,{contextOptions:i,imageOptions:l}=s||{},c=(null===l||void 0===l?void 0:l.alpha)||1,u=(null===i||void 0===i?void 0:i.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(i.contextType," is not supported by the CPU backend."));const h=o.getContext(u,(null===i||void 0===i?void 0:i.contextAttributes)||{});if(null==h)throw new Error("Could not get the context with ".concat(u," type."));const[d,p]=r.shape.slice(0,2),f=2===r.shape.length?1:r.shape[2],g=n.data.get(r.dataId).values,m="float32"===r.dtype?255:1,b=new Uint8ClampedArray(p*d*4);for(let v=0;v<d*p;++v){const e=[0,0,0,255*c];for(let n=0;n<f;n++){const t=g[v*f+n];if("float32"===r.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===r.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===f?(e[0]=t*m,e[1]=t*m,e[2]=t*m):e[n]=t*m}const t=4*v;b[t+0]=Math.round(e[0]),b[t+1]=Math.round(e[1]),b[t+2]=Math.round(e[2]),b[t+3]=Math.round(e[3])}o.width=p,o.height=d;const y=new ImageData(b,p,d);return h.putImageData(y,0,0),r}},JI=Xk(((e,t)=>e*t)),$I=gS(((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n}))),QI=fS(lr,JI,$I),ZI={kernelName:lr,backendName:"cpu",kernelFunc:QI};function eC(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;let i;zk(r,"sum"),i="bool"===r.dtype?dS({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):jk({inputs:{x:r},backend:n});const l=i.shape.length,c=Ut(o,i.shape),u=fu(c,l);let h=c,d=i;null!=u&&(d=_S({inputs:{x:i},backend:n,attrs:{perm:u}}),h=mu(h.length,l)),pu("sum",h,d.shape.length);const[p,f]=hu(d.shape,h);let g=lS(n,p,Ts(d.dtype,"int32"));const m=Ot(f),b=n.data.get(g.dataId).values,y=n.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const e=v*m;let t=0;for(let n=0;n<m;++n)t+=y[e+n];b[v]=t}if(s){const e=g;g=xS({inputs:{x:g},backend:n,attrs:{shape:du(g.shape,c)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(i),null!=u&&n.disposeIntermediateTensorInfo(d),g}const tC={kernelName:Yr,backendName:"cpu",kernelFunc:eC};const nC={kernelName:fa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,o=t,{allDims:s,summedDims:i,idDims:l}=ep(r,o.length);np(s.length,l,o);const{path:c,steps:u}=ap(i,l),h=u.length;let d=null,p=s.length;const f=[];for(let g=0;g<h;++g){for(const e of u[g]){const{permutationIndices:t,expandDims:a}=tp(p,l[e]);let r;rp(t)?r=o[e]:(r=_S({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(r));const s=r.shape.slice();for(let e=0;e<a.length;++e)s.splice(a[e],0,1);Lt(r.shape,s)||(r=xS({inputs:{x:r},backend:n,attrs:{shape:s}}),f.push(r)),null===d?d=r:(d=QI({inputs:{a:r,b:d},backend:n}),f.push(d))}g<h-1&&(c[g]>=0&&(d=eC({inputs:{x:d},backend:n,attrs:{axis:c[g]-(s.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}};const aC={kernelName:ma,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t;zk([a,r],"eluGrad");const o=new Float32Array(Ot(r.shape)),s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values;for(let l=0;l<s.length;++l){const e=s[l];o[l]=e>=0?i[l]:i[l]*(e+1)}return n.makeTensorInfo(r.shape,"float32",o)}},rC=Xk(((e,t)=>e===t?1:0)),oC=fS(ya,rC,null,"bool"),sC={kernelName:ya,backendName:"cpu",kernelFunc:oC},iC=zd,lC=Md,cC=Pd,uC=Bd,hC=Wd,dC=Ud,pC=Wk(ba,(e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+iC*n);return t*(1-((((dC*a+hC)*a+uC)*a+cC)*a+lC)*a*Math.exp(-n*n))})),fC={kernelName:ba,backendName:"cpu",kernelFunc:pC},gC=Bk((e=>Math.exp(e))),mC=Uk(va,gC,"float32"),bC={kernelName:va,backendName:"cpu",kernelFunc:mC};function yC(e){const{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:o}=a,s=r.shape.length,i=r.shape.slice();let l=o;return o<0&&(Ft(-(s+1)<=o,(()=>"Axis must be in the interval [".concat(-(s+1),", ").concat(s,"]"))),l=s+o+1),i.splice(l,0,1),xS({inputs:{x:r},backend:n,attrs:{shape:i}})}const vC={kernelName:xa,backendName:"cpu",kernelFunc:yC},xC=Bk((e=>Math.expm1(e))),wC=Uk(wa,xC),kC={kernelName:wa,backendName:"cpu",kernelFunc:wC},SC=Xk(((e,t)=>e/t)),IC=fS(pa,SC),CC={kernelName:pa,backendName:"cpu",kernelFunc:IC},NC=Xk(((e,t)=>e-t)),EC=gS(((e,t,n,a)=>({real:e-n,imag:t-a}))),TC=fS(ho,NC,EC),RC={kernelName:ho,backendName:"cpu",kernelFunc:TC};function AC(e,t,n){const a=e.shape,r=a[0],o=a[1],s=n.data.get(e.dataId),i=s.complexTensorInfos.real,l=s.complexTensorInfos.imag,c=[r,o],u=Ot(c),h=Gt("float32",u),d=Gt("float32",u);for(let m=0;m<r;m++){const e=oI({inputs:{x:i},backend:n,attrs:{begin:[m,0],size:[1,o]}}),a=oI({inputs:{x:l},backend:n,attrs:{begin:[m,0],size:[1,o]}}),r=sS({inputs:{real:e,imag:a},backend:n}),{real:s,imag:c}=FC(r,t,n),u=Vd(s,c);for(let t=0;t<o;t++){const e=Kd(u,t);h[m*o+t]=e.real,d[m*o+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r)}const p=n.makeTensorInfo(c,"float32",h),f=n.makeTensorInfo(c,"float32",d),g=sS({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}function FC(e,t,n){const a=Ot(e.shape),r=n.data.get(e.dataId),o=n.data.get(r.complexTensorInfos.real.dataId).values,s=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0===((i=a)&i-1)){const r=DC(o,s,a,t,n),i=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(i,"float32",r.real),t=n.makeTensorInfo(i,"float32",r.imag),o=n.makeTensorInfo([],"float32",es(a,"float32")),s=jk({inputs:{x:o},backend:n}),l=CC.kernelFunc({inputs:{a:e,b:o},backend:n}),c=CC.kernelFunc({inputs:{a:t,b:s},backend:n}),u=n.data.get(l.dataId).values,h=n.data.get(c.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),{real:u,imag:h}}return r}{const e=function(e,t,n){const a=new Float32Array(2*t);for(let r=0;r<t;r++){let o=0,s=0;for(let a=0;a<t;a++){const i=Yd(r*a,t,n),l=Kd(e,a);o+=l.real*i.real-l.imag*i.imag,s+=l.real*i.imag+l.imag*i.real}n&&(o/=t,s/=t),qd(a,o,s,r)}return a}(Vd(o,s),a,t);return Gd(e)}var i}function DC(e,t,n,a,r){if(1===n)return{real:e,imag:t};const o=Vd(e,t),s=n/2,i=jd(o),l=i.real,c=i.imag,u=[l.length],h=r.makeTensorInfo(u,"float32",l),d=r.makeTensorInfo(u,"float32",c),p=sS({inputs:{real:h,imag:d},backend:r}),f=Hd(o),g=f.real,m=f.imag,b=[g.length],y=r.makeTensorInfo(b,"float32",g),v=r.makeTensorInfo(b,"float32",m),x=sS({inputs:{real:y,imag:v},backend:r}),w=DC(l,c,s,a,r),k=w.real,S=w.imag,I=[k.length],C=r.makeTensorInfo(I,"float32",k),N=r.makeTensorInfo(I,"float32",S),E=sS({inputs:{real:C,imag:N},backend:r}),T=DC(g,m,s,a,r),R=T.real,A=T.imag,F=[R.length],D=r.makeTensorInfo(F,"float32",R),_=r.makeTensorInfo(F,"float32",A),O=sS({inputs:{real:D,imag:_},backend:r}),L=Xd(n,a),z=[L.real.length],M=r.makeTensorInfo(z,"float32",L.real),P=r.makeTensorInfo(z,"float32",L.imag),B=sS({inputs:{real:M,imag:P},backend:r}),W=QI({inputs:{a:B,b:O},backend:r}),U=yS({inputs:{a:E,b:W},backend:r}),V=TC({inputs:{a:E,b:W},backend:r}),G=cS({inputs:{input:U},backend:r}),j=cS({inputs:{input:V},backend:r}),H=wI({inputs:{input:U},backend:r}),K=wI({inputs:{input:V},backend:r}),q=SI({inputs:[G,j],backend:r,attrs:{axis:0}}),X=SI({inputs:[H,K],backend:r,attrs:{axis:0}}),Y=r.data.get(q.dataId).values,J=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(X),{real:Y,imag:J}}const _C={kernelName:ka,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=Ot(a.shape),o=a.shape[a.shape.length-1],s=xS({inputs:{x:a},backend:n,attrs:{shape:[r/o,o]}}),i=AC(s,!1,n),l=xS({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),l}};function OC(e){const{backend:t,attrs:n}=e,{shape:a,value:r,dtype:o}=n,s=o||Yt(r),i=jt(s,Ot(a));return function(e,t){e.fill(t)}(i,r),t.makeTensorInfo(a,s,i)}const LC={kernelName:Sa,backendName:"cpu",kernelFunc:OC};const zC={kernelName:Ia,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,o=a,s=Gt(r.dtype,Ot(r.shape)),[i,l,c,u]=r.shape,h=o.data.get(r.dataId).values;for(let d=0;d<i;d++){const e=d*c*l*u;for(let t=0;t<l;t++){const n=t*(c*u);for(let t=0;t<c;t++){const a=t*u;for(let r=0;r<u;r++){const o=Math.round(c-t-1),i=e+n+a+r;let l=h[i];if(o>=0&&o<c){l=h[e+n+o*u+r]}s[i]=l}}}}return{dataId:o.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},MC=Bk((e=>Math.floor(e))),PC=Uk(Ca,MC),BC={kernelName:Ca,backendName:"cpu",kernelFunc:PC},WC=Xk(((e,t)=>Math.floor(e/t))),UC=fS(Na,WC,null,"int32"),VC={kernelName:Na,backendName:"cpu",kernelFunc:UC};const GC={kernelName:Eo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a;let g=CI({inputs:{x:r,filter:o},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(s){const e=g;if("NCHW"===u&&1===s.shape.length&&1!==s.shape[0]){const e=xS({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}});g=yS({inputs:{a:g,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else g=yS({inputs:{a:g,b:s},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=g;if("NCHW"===u&&"prelu"===p&&1===i.shape.length&&1!==i.shape[0]){const e=xS({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});g=oS(n,g,p,e,f),n.disposeIntermediateTensorInfo(e)}else g=oS(n,g,p,i,f);n.disposeIntermediateTensorInfo(e)}return g}};const jC={kernelName:To,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a;let g=UI({inputs:{x:r,filter:o},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(s){const e=g;g=yS({inputs:{a:g,b:s},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=g;g=oS(n,g,p,i,f),n.disposeIntermediateTensorInfo(e)}return g}};function HC(e,t,n,a,r,o,s,i,l){const c=Yi([a,o],n);for(let u=0;u<a;u++){const n=[];let a=0;for(let t=0;t<r;t++){const o=e[u*r+t];a+=o*s[t],n.push(o)}if(a<0||a>=l/o)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(i));for(let e=0;e<o;e++)c.values[u*o+e]=t.get(...t.indexToLoc(a*o+e))}return c}const KC={kernelName:Ra,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,o=Ot(a.shape),s=r.shape,i=s[s.length-1],[l,c,u,h]=Ad(a,r);if(0===c)return n.makeTensorInfo(l,a.dtype,[]);const d=HC(n.data.get(r.dataId).values,n.bufferSync(a),a.dtype,c,i,u,h,a.shape,o);return n.makeTensorInfo(l,a.dtype,d.values)}};function qC(e,t,n){const a=Yi(n,e.dtype);for(let r=0;r<a.size;++r){const n=a.indexToLoc(r).slice(),o=n[0],s=n[2],i=t.locToIndex([o,s]);n[2]=t.values[i];const l=e.locToIndex(n);0<=l&&l<e.values.length&&(a.values[r]=e.values[l])}return a}const XC={kernelName:Ta,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:o}=t,{axis:s,batchDims:i}=a;zk([r,o],"gatherV2");const l=Ut(s,r.shape)[0],c=n.data.get(o.dataId).values,u=r.shape[l];for(let v=0;v<c.length;++v){const e=c[v];Ft(e<=u-1&&e>=0,(()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(u-1,"]")))}let h=i;null==i&&(h=0);const d=Ot(o.shape),p=wp(r,o,l,h),f=xS({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=xS({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),m=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],b=n.bufferSync(g),y=qC(n.bufferSync(f),b,m);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},YC=Xk(((e,t)=>e>t?1:0)),JC=fS(Aa,YC,null,"bool"),$C={kernelName:Aa,backendName:"cpu",kernelFunc:JC},QC=Xk(((e,t)=>e>=t?1:0)),ZC=fS(Fa,QC,null,"bool"),eN={kernelName:Fa,backendName:"cpu",kernelFunc:ZC};const tN={kernelName:_a,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=Ot(a.shape),o=a.shape[a.shape.length-1],s=xS({inputs:{x:a},backend:n,attrs:{shape:[r/o,o]}}),i=AC(s,!0,n),l=xS({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),l}},nN=Wk(La,(e=>Number.isFinite(e)?1:0),"bool"),aN={kernelName:La,backendName:"cpu",kernelFunc:nN},rN=Wk(za,(e=>Math.abs(e)===1/0?1:0),"bool"),oN={kernelName:za,backendName:"cpu",kernelFunc:rN},sN=Wk(Ma,(e=>Number.isNaN(e)?1:0),"bool"),iN={kernelName:Ma,backendName:"cpu",kernelFunc:sN},lN=Xk(((e,t)=>e<t?1:0)),cN=fS(Ba,lN,null,"bool"),uN={kernelName:Ba,backendName:"cpu",kernelFunc:cN},hN=Xk(((e,t)=>e<=t?1:0)),dN=fS(Wa,hN,null,"bool"),pN={kernelName:Wa,backendName:"cpu",kernelFunc:dN};function fN(e,t,n){const a=(t-e)/(n-1),r=nn(n,"float32");r[0]=e;for(let o=1;o<r.length;o++)r[o]=r[o-1]+a;return r}const gN={kernelName:Ua,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:o}=n,s=fN(a,r,o);return t.makeTensorInfo([s.length],"float32",s)}},mN=Bk((e=>Math.log(e))),bN=Uk(Va,mN),yN={kernelName:Va,backendName:"cpu",kernelFunc:bN},vN=Wk(Ga,(e=>Math.log1p(e))),xN={kernelName:Ga,backendName:"cpu",kernelFunc:vN},wN=Xk(((e,t)=>e&&t)),kN=fS(ja,wN,null,"bool"),SN={kernelName:ja,backendName:"cpu",kernelFunc:kN},IN=Wk(Ha,(e=>e?0:1),"bool"),CN={kernelName:Ha,backendName:"cpu",kernelFunc:IN},NN=Xk(((e,t)=>e||t)),EN=fS(Ka,NN,null,"bool"),TN={kernelName:Ka,backendName:"cpu",kernelFunc:EN};const RN={kernelName:qa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:o,bias:s,alpha:i,beta:l}=a;zk(r,"LRN");const c=r.shape[3],u=c-1,h=n.data.get(r.dataId).values,d=Ot(r.shape),p=new Float32Array(d);function f(e){const t=e%c;let n=e-t+Math.max(0,t-o);const a=e-t+Math.min(t+o,u);let r=0;for(;n<=a;n++){const e=h[n];r+=e*e}return r}for(let g=0;g<d;g++){const e=f(g),t=h[g]*Math.pow(s+i*e,-l);p[g]=t}return n.makeTensorInfo(r.shape,r.dtype,p)}};const AN={kernelName:Xa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:o,dy:s}=t,{depthRadius:i,bias:l,alpha:c,beta:u}=a;zk(s,"LRNGrad");const h=Ot(s.shape),d=s.shape[3],p=n.data.get(s.dataId).values,f=n.data.get(r.dataId).values,g=n.data.get(o.dataId).values,m=new Float32Array(h),b=h;for(let y=0;y<b;y++){const e=y%d,t=y-e+Math.max(0,e-i),n=y-e+Math.min(d,e+i+1);let a=0;for(let r=t;r<n;r++)a+=Math.pow(f[r],2);a=c*a+l;for(let r=t;r<n;r++){let e=-2*c*u*f[r]*g[y]/a;y===r&&(e+=Math.pow(a,-u)),e*=p[y],m[r]+=e}}return n.makeTensorInfo(s.shape,r.dtype,m)}};function FN(e,t,n,a){const r=Gt(a,Ot(n));for(let o=0;o<r.length;++o){const n=o*t;let a=e[n];for(let r=0;r<t;++r){const t=e[n+r];(Number.isNaN(t)||t>a)&&(a=t)}r[o]=a}return r}function DN(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:o,keepDims:s}=a,i=n;let l=r.shape;const c=l.length,u=Ut(o,l);let h=u;const d=fu(h,c);let p=i.data.get(r.dataId).values;if(null!=d){const e=new Array(c);for(let t=0;t<e.length;t++)e[t]=l[d[t]];p=DS(p,l,r.dtype,d,e),h=mu(h.length,c),l=e}zk(r,"max"),pu("max",h,c);const[f,g]=hu(l,h),m=FN(p,Ot(g),f,r.dtype),b=i.write(m,f,r.dtype);let y=f;if(s){y=du(f,u)}return{dataId:b,shape:y,dtype:r.dtype}}const _N={kernelName:Ya,backendName:"cpu",kernelFunc:DN},ON=Xk(((e,t)=>Math.max(e,t))),LN=fS(Ja,ON),zN={kernelName:Ja,backendName:"cpu",kernelFunc:LN};const MN={kernelName:$a,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;zk(r,"maxPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:l}=a;Ft(vc(s,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const c=cc(r.shape,o,s,1,i,l);let u;if(1===c.filterWidth&&1===c.filterHeight&&Lt(c.inShape,c.outShape))u=jk({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Qt(r.shape),a=JS(e,r.shape,r.dtype,t,c,"max");u=n.makeTensorInfo(c.outShape,r.dtype,a.values)}return u}};const PN={kernelName:Za,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:l,dataFormat:c}=a;zk(r,"maxPool3d");const u=uc(r.shape,o,s,1,i,l,c),h=QS(n.data.get(r.dataId).values,r.shape,r.dtype,Qt(r.shape),u,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const BN={kernelName:er,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,{filterSize:s,strides:i,pad:l,dimRoundingMode:c}=a;zk([r,o],"maxPool3DGrad");const u=uc(o.shape,s,i,1,l,c),h=function(e,t){const n=Yi(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let m=0;m<t.inChannels;++m)for(let b=0;b<t.outDepth;++b){const y=b*a-d;let v=y;for(;v<0;)v+=s;const x=Math.min(t.inDepth,c+y);for(let a=0;a<t.outHeight;++a){const c=a*r-p;let d=c;for(;d<0;)d+=i;const w=Math.min(t.inHeight,u+c);for(let r=0;r<t.outWidth;++r){const p=r*o-f;let k=p;for(;k<0;)k+=l;const S=Math.min(t.inWidth,h+p);let I=Number.NEGATIVE_INFINITY,C=-1;for(let t=v;t<x;t+=s){const n=t-y;for(let a=d;a<w;a+=i){const r=a-c;for(let o=k;o<S;o+=l){const s=o-p,i=e.get(g,t,a,o,m);i>=I&&(I=i,C=n*u*h+r*u+s)}}}n.set(C,g,b,a,r,m)}}}return n}(n.bufferSync(o),u),d=u.strideDepth,p=u.strideHeight,f=u.strideWidth,g=u.dilationDepth,m=u.dilationHeight,b=u.dilationWidth,y=u.effectiveFilterDepth,v=u.effectiveFilterHeight,x=u.effectiveFilterWidth,w=y-1-u.padInfo.front,k=x-1-u.padInfo.left,S=v-1-u.padInfo.top,I=Yi(o.shape,"float32"),C=n.bufferSync(r);for(let N=0;N<u.batchSize;++N)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-w,o=n-S,s=a-k;let i=0;for(let t=0;t<y;t+=g){const n=(r+t)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let a=0;a<v;a+=m){const r=(o+a)/p;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let o=0;o<x;o+=b){const l=(s+o)/f;if(l<0||l>=u.outWidth||Math.floor(l)!==l)continue;const c=y*v*x-1-h.get(N,n,r,l,e)===t*v*x+a*x+o?1:0;if(0===c)continue;i+=C.get(N,n,r,l,e)*c}}}I.set(i,N,t,n,a,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const WN={kernelName:Qa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o,output:s}=t,i=o;zk([o,s],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=a,d=cc(i.shape,l,c,1,u,h),p=n.data.get(i.dataId).values,f=Yi(d.outShape,i.dtype,$S(p,i.shape,i.dtype,d).values),g=d.strideHeight,m=d.strideWidth,b=d.dilationHeight,y=d.dilationWidth,v=d.effectiveFilterHeight,x=d.effectiveFilterWidth,w=x-1-d.padInfo.left,k=v-1-d.padInfo.top,S=Yi(i.shape,"float32"),I=n.data.get(r.dataId).values,C=Yi(r.shape,"float32",I);for(let N=0;N<d.batchSize;++N)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const a=t-k,r=n-w;let o=0;for(let t=0;t<v;t+=b){const n=(a+t)/g;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let a=0;a<x;a+=y){const s=(r+a)/m;if(s<0||s>=d.outWidth||Math.floor(s)!==s)continue;const i=v*x-1-f.get(N,n,s,e)===t*x+a?1:0;if(0===i)continue;o+=C.get(N,n,s,e)*i}}S.set(o,N,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const UN={kernelName:tr,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:l}=n,c=a;zk(r,"MaxPoolWithArgmax");const u=c.data.get(r.dataId).values,h=cc(r.shape,o,s,[1,1],i),[d,p]=function(e,t,n,a,r){const o=JS(e,0,n,Qt(t),r,"max"),s=$S(e,t,n,r,!0,a);return[o.values,s.values]}(u,r.shape,r.dtype,l,h),f=c.write(d,h.outShape,r.dtype),g=c.write(p,h.outShape,r.dtype);return[{dataId:f,shape:h.outShape,dtype:r.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}};const VN={kernelName:nr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=Ut(o,r.shape),l=Ot(hu(r.shape,i)[1]),c=[],u=n.makeTensorInfo([],"float32",new Float32Array([l]));c.push(u);const h=dS({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});c.push(h);const d=IC({inputs:{a:h,b:u},backend:n});c.push(d);const p=eC({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:s}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const GN={kernelName:ar,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;zk(r,"min");const i=Ut(o,r.shape);let l=i;const c=fu(l,r.shape.length);let u=r;null!=c&&(u=_S({inputs:{x:r},backend:n,attrs:{perm:c}}),l=mu(l.length,r.shape.length)),pu("min",l,u.shape.length);const[h,d]=hu(u.shape,l),p=Ot(d),f=nn(Ot(h),u.dtype),g=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=g[e];for(let n=0;n<p;++n){const a=g[e+n];(Number.isNaN(a)||a<t)&&(t=a)}f[b]=t}null!=c&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(h,u.dtype,f);if(s){const e=xS({inputs:{x:m},backend:n,attrs:{shape:du(h,i)}});return n.disposeIntermediateTensorInfo(m),e}return m}},jN=Xk(((e,t)=>Math.min(e,t))),HN=fS(rr,jN),KN={kernelName:rr,backendName:"cpu",kernelFunc:HN};const qN={kernelName:or,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,mode:s}=a;zk(r,"mirrorPad");const i=o.map(((e,t)=>e[0]+r.shape[t]+e[1])),l=o.map((e=>e[0])),c=o.map(((e,t)=>e[0]+r.shape[t])),u="reflect"===s?0:1,h=n.data.get(r.dataId).values,d=r.shape.length,p=Qt(r.shape),f=Ot(i),g=i.length,m=Qt(i),b=Gt(r.dtype,f);for(let y=0;y<f;y++){let e=sn(y,g,m);for(let n=0;n<g;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-u:e[n]>=c[n]&&(e[n]=2*(c[n]-1)-e[n]+u);e=e.map(((e,t)=>e-l[t]));const t=on(e,d,p);b[y]=h[t]}return{dataId:n.write(b,i,r.dtype),shape:i,dtype:r.dtype}}},XN=Xk(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),YN=fS(sr,XN),JN={kernelName:sr,backendName:"cpu",kernelFunc:YN};function $N(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:o}=a,s=r.shape.length;let i=o;if(-1===i&&(i=s-1),i!==s-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(s," and dim was ").concat(i));const l=Ut([i],r.shape),c=DN({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),u=du(c.shape,l),h=xS({inputs:{x:c},backend:n,attrs:{shape:u}}),d=TC({inputs:{a:r,b:h},backend:n}),p=mC({inputs:{x:d},backend:n}),f=eC({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),g=xS({inputs:{x:f},backend:n,attrs:{shape:u}}),m=IC({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}const QN={kernelName:Qr,backendName:"cpu",kernelFunc:$N};const ZN={kernelName:ir,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:o,seed:s,normalized:i}=a;zk(r,"multinomial");const l=i?r:$N({inputs:{logits:r},backend:n,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=n.data.get(l.dataId).values,d=[c,o],p=nn(Ot(d),"int32");for(let f=0;f<c;++f){const e=f*u,t=new Float32Array(u-1);t[0]=h[e];for(let r=1;r<t.length;++r)t[r]=t[r-1]+h[e+r];const n=Ou.alea(s.toString()),a=f*o;for(let r=0;r<o;++r){const e=n();p[a+r]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[a+r]=n;break}}}return i||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function eE(e,t,n){const a=es(-1,n);return JI([],t,a,e,n)}const tE={kernelName:cr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;zk(a,"neg");const r=n.data.get(a.dataId).values,[o,s]=eE(r,a.shape,a.dtype);return n.makeTensorInfo(s,a.dtype,o)}},nE=zh;const aE={kernelName:hr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:l}=a;zk(r,"NonMaxSuppression");const c=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,{selectedIndices:h}=nE(c,u,s,i,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},rE=Mh;const oE={kernelName:dr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:c}=a;zk(r,"NonMaxSuppressionPadded");const u=n.data.get(r.dataId).values,h=n.data.get(o.dataId).values,{selectedIndices:d,validOutputs:p}=rE(u,h,s,i,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},sE=Ph;const iE={kernelName:pr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:l,softNmsSigma:c}=a;zk(r,"NonMaxSuppressionWithScore");const u=n.data.get(r.dataId).values,h=n.data.get(o.dataId).values,d=s,p=i,f=l,g=c,{selectedIndices:m,selectedScores:b}=sE(u,h,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},lE=Xk(((e,t)=>e!==t?1:0)),cE=fS(ur,lE,null,"bool"),uE={kernelName:ur,backendName:"cpu",kernelFunc:cE};const hE={kernelName:gr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:o,depth:s,onValue:i,offValue:l}=a;zk(r,"oneHot");const c=Ot(r.shape),u=new Float32Array(c*s);u.fill(l);const h=n.data.get(r.dataId).values;for(let d=0;d<c;++d)h[d]>=0&&h[d]<s&&(u[d*s+h[d]]=i);return n.makeTensorInfo([...r.shape,s],o,u)}};function dE(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=cS({inputs:{input:a},backend:n}),t=dE({inputs:{x:e},backend:n}),r=wI({inputs:{input:a},backend:n}),o=dE({inputs:{x:r},backend:n}),s=sS({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),s}return OC({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const pE={kernelName:ko,backendName:"cpu",kernelFunc:dE};const fE={kernelName:fr,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=cS({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),o=wI({inputs:{input:r},backend:a}),s=dE({inputs:{x:o},backend:a}),i=sS({inputs:{real:n,imag:s},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}return OC({backend:a,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function gE(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return yC({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const o=t[0].shape,s=t[0].dtype;t.forEach((e=>{Dt(o,e.shape,"All tensors passed to stack must have matching shapes"),Ft(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=t.map((e=>{const t=yC({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),c=SI({inputs:l,backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const mE={kernelName:mr,backendName:"cpu",kernelFunc:gE};const bE={kernelName:br,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,constantValue:s}=a;zk(r,"pad");const i=o.map(((e,t)=>e[0]+r.shape[t]+e[1])),l=o.map((e=>e[0])),c=n.data.get(r.dataId).values,u=Ot(r.shape),h=r.shape.length,d=Qt(r.shape),p=Ot(i),f=i.length,g=Qt(i),m=Gt(r.dtype,p);0!==s&&m.fill(s);for(let b=0;b<u;b++){const e=sn(b,h,d).map(((e,t)=>e+l[t]));m[on(e,f,g)]=c[b]}return{dataId:n.write(m,i,r.dtype),shape:i,dtype:r.dtype}}},yE=Xk(((e,t)=>Math.pow(e,t))),vE=fS(yr,yE),xE={kernelName:yr,backendName:"cpu",kernelFunc:vE};function wE(e,t,n,a){const[r,o]=hu(e,a),s=Ts(t,"int32"),i=nn(Ot(r),s),l=Ot(o);for(let c=0;c<i.length;++c){const e=c*l;let t=1;for(let a=0;a<l;++a)t*=n[e+a];i[c]=t}return{outVals:i,outShape:r,outDtype:s}}const kE={kernelName:xr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;zk(r,"prod");const i=r.shape.length,l=Ut(o,r.shape),c=fu(l,i);let u=l,h=r;const d=[];null!=c&&(h=_S({inputs:{x:r},backend:n,attrs:{perm:c}}),d.push(h),u=mu(u.length,i));const p=n.data.get(h.dataId).values,{outVals:f,outShape:g,outDtype:m}=wE(h.shape,h.dtype,p,u);let b=g;return s&&(b=du(g,l)),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(b,m,f)}};function SE(e,t,n,a){const r=[];let o=0;const s=t.length-1+n.length,i=new Array(s).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const a=e[n],r=n===e.length-1?t:e[n+1].length;if(0===a.length)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let e=1;e<a.length;++e)if(a[e-1]>a[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,a);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];const e=t[c+1];for(let t=1;t<l+1;++t)i[c].push(t*e)}for(let c=0;c<e.length;++c){let a=e[c],s=e[c]+1;for(let e=0;e<n.length;++e){const r=n[e],o=e+t.length-1;if(o>=0){const e=i[o],t=e[e.length-1]-r[a];for(let n=a;n<s;++n)i[o].push(r[n+1]+t)}a=r[a],s=r[s]}s!==a&&(r.push([a,s]),o+=s-a)}return{outSplits:i,valueSlices:r,numValues:o}}function IE(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function CE(e,t,n,a,r){const o=t.slice();o[0]=r;const s=jt(n,Ot(o)),i=e.length;return function(e,t,n,a,r,o){const s=IE(t,2)[1],i=IE(o,2)[1];let l=0;for(const c of n)for(let t=c[0];t<c[1];++t){for(let n=0;n<a;++n)r[l*i+n]=e[t*s+n];++l}}(e,t,a,0===i?0:i/t[0],s,o),[s,o]}function NE(e,t,n,a,r,o,s,i){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,a)=>{if(e<0||e>=n){const r=sn(a,t.length,Qt(t)).join(",");throw new Error("indices[".concat(r,"] = ").concat(e," is not in [0, ").concat(n,")"))}}))}(o,s,t[0][0]-1),0===a.length)throw new Error("params.rank must be nonzero");const l=a[0],{outSplits:c,valueSlices:u,numValues:h}=SE(o,s,e,l),d=function(e){const t=[];for(let n=0;n<e.length;++n){const a=jt("int32",e[n].length);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(c),p=CE(n,a,r,u,h);return[d,p[0],p[1]]}const EE={kernelName:wr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:o,indices:s}=t,{outputRaggedRank:i}=a,l=r.map((e=>n.data.get(e.dataId).values)),c=r.map((e=>e.shape)),u=n.data.get(o.dataId).values,h=n.data.get(s.dataId).values,[d,p,f]=NE(l,c,u,o.shape,o.dtype,h,s.shape),g=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),m=n.makeTensorInfo(f,o.dtype,p);return g.concat([m])}},TE=2147483647;function RE(e,t,n,a,r,o,s){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(s.length>1)throw new Error("deltas must be a scalar or vector");const i=0===t.length,l=0===r.length,c=0===s.length,u=[];i||u.push(t[0]),l||u.push(r[0]),c||u.push(s[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===u.length?1:u[0],d=jt("int32",h+1);d[0]=0;for(let g=0;g<h;++g){const t=i?e[0]:e[g],n=l?a[0]:a[g],r=c?o[0]:o[g];if(0===r)throw new Error("Requires delta != 0");let s;if(r>0&&n<t||r<0&&n>t)s=0;else if(s=Math.ceil(Math.abs((n-t)/r)),s>TE)throw new Error("Requires ((limit - start) / delta) <= ".concat(TE));d[g+1]=d[g]+s}const p=jt(n,d[h]);let f=0;for(let g=0;g<h;++g){const t=d[g+1]-d[g];let n=i?e[0]:e[g];const a=c?o[0]:o[g];for(let e=0;e<t;++e)p[f++]=n,n+=a}return[d,p]}const AE={kernelName:kr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:o}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,[c,u]=RE(s,a.shape,a.dtype,i,r.shape,l,o.shape);return[n.makeTensorInfo([c.length],"int32",c),n.makeTensorInfo([u.length],a.dtype,u)]}};var FE=bd;class DE{constructor(e,t,n,a,r,o,s,i,l,c){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=a,this.valuesDType=r,this.defaultValue=o,this.defaultValueShape=s,this.rowPartitionValues=i,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=vd(c),this.raggedRank=xd(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===FE.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===FE.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case FE.VALUE_ROWIDS:return DE.getMaxWidthValueRowID(t);case FE.ROW_SPLITS:return DE.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(FE[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let a=0;a<t-1;++a){const t=e[a+1]-e[a];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,a=e[0],r=0;for(let o=1;o<t;++o){const t=e[o];t!==a&&(a=t,r=Math.max(o-n,r),n=o)}return Math.max(t-n,r)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return OE(e,n)}calculateOutputSize(e){const t=this.valuesShape;wd(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=yd(this.raggedRank,n,t);a[0]<0&&(a[0]=e);for(let r=1;r<=this.raggedRank;++r)a[r]<0&&(a[r]=this.getMaxWidth(r));return a}calculateFirstParentOutputIndex(e,t,n){const a=Math.min(e,n),r=[];let o=0;for(let s=0;s<a;++s,o+=t)r.push(o);for(let s=a;s<e;++s)r.push(-1);return Ft(r.length===e,(()=>"Final length of result must be equal to firstDimension.")),r}calculateOutputIndexRowSplit(e,t,n,a){const r=e.length,o=[];for(let s=0;s<r-1;++s){const r=e[s+1]-e[s];let i=Math.min(a,r),l=t[s];-1===l&&(i=0);for(let e=0;e<i;++e)o.push(l),l+=n;for(let e=0;e<r-i;++e)o.push(-1)}if(r>0&&o.length!==e[r-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,n,a){const r=e.length,o=[];if(0===r)return[];let s=0,i=e[0];if(i>=t.length)throw new Error("Got currentValueRowId=".concat(i,", which is not less than ").concat(t.length));let l=t[i];o.push(l);for(let c=1;c<r;++c){const r=e[c];if(r===i)l>=0&&(++s,s<a?l+=n:l=-1);else{if(s=0,i=r,r>=t.length)throw new Error("Got nextValueRowId=".concat(r," which is not less than ").concat(t.length));l=t[r]}o.push(l)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,n,a){const r=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case FE.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,n,a);case FE.ROW_SPLITS:if(r.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(r.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(r,t,n,a);default:throw new Error("Unsupported partition type: ".concat(FE[o]))}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case FE.FIRST_DIM_SIZE:return e[0];case FE.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case FE.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(FE[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let o=n.length-2;o>=0;--o)n[o]=n[o+1]*t[o+1];const a=OE(t,!1),r=jt(this.valuesDType,Ot(a));if(n[0]*t[0]>0){let o=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){o=this.calculateOutputIndex(e-1,o,n[e],t[e])}this.setOutput(this.raggedRank,o,r,a)}return[a,r]}setOutput(e,t,n,a){if(0===n.length)return;const r=this.values,o=n;let s=a.slice();s=s.slice(e+1);const i=Ot(s),l=t.length;let c=this.defaultValue;if(c.length!==i&&1!==c.length){const e=this.defaultValueShape;oi((()=>{const t=Sc(c,e),n=Ac(t,s);c=n.dataSync()}))}let u=0,h=0,d=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==d){if(h<d){const e=r.subarray(u*i);_E(o.subarray(h*i),e,(d-h)*i)}if(p>=l){const t=n.length;e=Math.floor(t/i)}if(e>d)if(1===this.defaultValue.length)o.subarray(d*i,e*i).fill(this.defaultValue[0]),d=e;else for(;e>d;){_E(o.slice(d*i),c,i),++d}e<0?(u=p+1,h=d):(u=p,h=d,d=h+1)}else++d}}}function _E(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function OE(e,t){const n=[];for(let a of e){if(a<0){if(!t)throw new Error("Dimension ".concat(a," must be >= 0"));if(a<-1)throw new Error("Dimension ".concat(a," must be >= -1"));a=-1}n.push(a)}return n}function LE(e,t,n,a,r,o,s,i,l,c){return new DE(e,t,n,a,r,o,s,i,l,c).compute()}const zE={kernelName:Sr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:o,defaultValue:s,rowPartitionTensors:i}=t,{rowPartitionTypes:l}=a,c=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,h=n.data.get(s.dataId).values,d=i.map((e=>n.data.get(e.dataId).values)),p=i.map((e=>e.shape)),[f,g]=LE(c,r.shape,u,o.shape,o.dtype,h,s.shape,d,p,l);return n.makeTensorInfo(f,o.dtype,g)}};function ME(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return nn(0,a);const r=nn(Math.abs(Math.ceil((t-e)/n)),a);t<e&&1===n&&(n=-1),r[0]=e;for(let o=1;o<r.length;o++)r[o]=r[o-1]+n;return r}const PE={kernelName:Ir,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,dtype:o,step:s}=n,i=ME(a,r,s,o);return t.makeTensorInfo([i.length],o,i)}},BE=Wk(Nr,(e=>1/e)),WE={kernelName:Nr,backendName:"cpu",kernelFunc:BE};const UE={kernelName:Fr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a;zk(r,"resizeBilinear");const l=Qt(r.shape),[c,u]=i,[h,d,p,f]=r.shape,g=n.data.get(r.dataId).values,m=new Float32Array(Ot([h,c,u,f])),b=[o&&c>1?d-1:d,o&&u>1?p-1:p],y=[o&&c>1?c-1:c,o&&u>1?u-1:u];let v=0;const x=b[0]/y[0],w=b[1]/y[1];for(let k=0;k<h;k++)for(let e=0;e<c;e++){let t;t=s?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),a=t-n,r=Math.min(d-1,Math.ceil(t)),o=k*l[0]+n*l[1],i=k*l[0]+r*l[1];for(let e=0;e<u;e++){let t;t=s?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,c=Math.min(p-1,Math.ceil(t)),u=o+n*l[2],h=i+n*l[2],d=o+c*l[2],b=i+c*l[2];for(let e=0;e<f;e++){const t=g[u+e],n=g[h+e],o=t+(g[d+e]-t)*r,s=o+(n+(g[b+e]-n)*r-o)*a;m[v++]=s}}}return n.makeTensorInfo([h,c,u,f],"float32",m)}};const VE={kernelName:Dr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a;zk([o,r],"resizeBilinearGrad");const i=Qt(r.shape),[l,c,u,h]=r.shape,[,d,p]=o.shape,f=new Float32Array(l*c*u*h),g=[s&&d>1?c-1:c,s&&p>1?u-1:u],m=[s&&d>1?d-1:d,s&&p>1?p-1:p],b=g[0]/m[0],y=g[1]/m[1],v=n.data.get(o.dataId).values;let x=0;for(let w=0;w<l;w++){const e=w*i[0];for(let t=0;t<d;t++){const n=t*b,a=Math.floor(n),r=Math.min(Math.ceil(n),c-1),o=e+a*i[1],s=e+r*i[1],l=n-a,d=1-l;for(let e=0;e<p;e++){const t=e*y,n=Math.floor(t),a=Math.min(Math.ceil(t),u-1),r=t-n,c=1-r,p=o+n*i[2],g=o+a*i[2],m=s+n*i[2],b=s+a*i[2],w=d*c,k=d*r,S=l*c,I=l*r;for(let e=0;e<h;e++){const t=v[x++];f[p+e]+=t*w,f[g+e]+=t*k,f[m+e]+=t*S,f[b+e]+=t*I}}}}return n.makeTensorInfo([l,u,c,h],"float32",f)}};const GE={kernelName:Rr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a;zk(r,"resizeNearestNeighbor");const l=Qt(r.shape),[c,u]=i,[h,d,p,f]=r.shape,g=n.data.get(r.dataId).values,m=new Float32Array(h*c*u*f),b=[o&&c>1?d-1:d,o&&u>1?p-1:p],y=[o&&c>1?c-1:c,o&&u>1?u-1:u],v=b[0]/y[0],x=b[1]/y[1];let w=0;for(let k=0;k<h;k++){const e=k*l[0];for(let t=0;t<c;t++){const n=s?v*(t+.5):v*t;let a=Math.min(d-1,o?Math.round(n):Math.floor(n));s&&(a=Math.max(0,a));const r=e+a*l[1];for(let e=0;e<u;e++){const t=s?x*(e+.5):x*e;let n=Math.min(p-1,o?Math.round(t):Math.floor(t));s&&(n=Math.max(0,n));const a=r+n*l[2];for(let e=0;e<f;e++){const t=g[a+e];m[w++]=t}}}}return n.makeTensorInfo([h,c,u,f],r.dtype,m)}};const jE={kernelName:Ar,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a;zk([o,r],"resizeNearestNeighborGrad");const i=Qt(r.shape),l=Qt(o.shape),[c,u,h,d]=r.shape,[,p,f]=o.shape,g=new Float32Array(c*u*h*d),m=n.data.get(o.dataId).values,b=[s&&p>1?u-1:u,s&&f>1?h-1:h],y=[s&&p>1?p-1:p,s&&f>1?f-1:f],v=b[0]/y[0],x=b[1]/y[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let C=0;C<c;C++){const e=C*i[0];for(let t=0;t<u;t++){const n=e+t*i[1],a=Math.floor(t*w),r=Math.floor(a-S/2);for(let o=0;o<h;o++){const a=n+o*i[2],c=Math.floor(o*k),b=Math.floor(c-I/2);for(let n=0;n<d;n++){let i=0;for(let a=0;a<S;a++){const c=a+r;if(c<0||c>=p)continue;const d=e+c*l[1],g=c*v;if(t===Math.min(u-1,s?Math.round(g):Math.floor(g)))for(let e=0;e<I;e++){const t=e+b;if(t<0||t>=f)continue;const a=d+t*l[2],r=t*x;o===Math.min(h-1,s?Math.round(r):Math.floor(r))&&(i+=m[a+n])}}g[a+n]=i}}}}return n.makeTensorInfo(r.shape,r.dtype,g)}};const HE={kernelName:Or,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:o}=a;zk(r,"reverse");const s=r.shape.length,i=Ut(o,r.shape);if(0===s)return jk({inputs:{x:r},backend:n});const l=new gs(r.shape,r.dtype),c=n.bufferSync(r);for(let u=0;u<l.size;u++){const e=l.indexToLoc(u),t=e.slice();i.forEach((e=>t[e]=r.shape[e]-1-t[e])),l.set(c.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},KE={kernelName:Co,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:o,fillValue:s,center:i}=n,l=a,c=Gt(r.dtype,Ot(r.shape)),[u,h,d,p]=r.shape,[f,g]=Id(i,h,d),m=Math.sin(o),b=Math.cos(o),y=l.data.get(r.dataId).values;for(let v=0;v<u;v++){const e=v*d*h*p;for(let t=0;t<h;t++){const n=t*(d*p);for(let a=0;a<d;a++){const r=a*p;for(let o=0;o<p;o++){const i=[u,t,a,o],l=i[2],v=i[1];let x=(l-f)*b-(v-g)*m,w=(l-f)*m+(v-g)*b;x=Math.round(x+f),w=Math.round(w+g);let k=s;if("number"!==typeof s&&(k=3===o?255:s[o]),x>=0&&x<d&&w>=0&&w<h){k=y[e+w*(d*p)+x*p+o]}c[e+n+r+o]=k}}}}return{dataId:l.write(c,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},qE=Wk(Lr,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),XE={kernelName:Lr,backendName:"cpu",kernelFunc:qE},YE=Bk((e=>1/Math.sqrt(e))),JE=Uk(zr,YE),$E={kernelName:zr,backendName:"cpu",kernelFunc:JE};function QE(e,t,n,a,r,o,s,i,l,c){const u=[a/r,r],h=e.values,d=t.values;if(0===a)return Yi(n,t.dtype);const p=l instanceof gs?l:Yi(u,t.dtype);"string"===typeof l||"number"===typeof l?p.values.fill(l):"boolean"===typeof l&&p.values.fill(+l);for(let f=0;f<o;f++){const e=[];let o=0;for(let t=0;t<s;t++){const n=h[f*s+t];e.push(n),o+=n*i[t]}if(o<0||o>=a/r)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<r;n++)c?p.values[o*r+n]+=d[f*r+n]:p.values[o*r+n]=0===t.rank?d[0]:d[f*r+n]}return p}const ZE={kernelName:Mr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:o}=t,{shape:s}=a,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=_d(0,r,s),d=QE(n.bufferSync(r),n.bufferSync(o),s,h,c,l,i,u,0,!0);return n.makeTensorInfo(s,d.dtype,d.values)}};function eT(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function tT(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}const nT={kernelName:Br,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:o}=t,{side:s}=a,i=function(e,t,n,a,r,o){const s=jt("int32",n*r);for(let i=0;i<n;++i){const n=e.slice(i*a,(i+1)*a),l=i*r;for(let e=0;e<r;++e)s[l+e]="left"===o?eT(n,t[e+l]):tT(n,t[e+l])}return s}(n.data.get(r.dataId).values,n.data.get(o.dataId).values,r.shape[0],r.shape[1],o.shape[1],s);return n.makeTensorInfo(o.shape,"int32",i)}};const aT={kernelName:Wr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:o}=t;zk([a,r,o],"select");const s=a.shape.length,i=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,u=Ts(r.dtype,o.dtype),h=nn(Ot(r.shape),u);let d=0;const p=0===s||s>1||1===r.shape.length?1:Ot(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let e=0;e<p;e++)1===i[f]?h[d++]=l[f]:h[d++]=c[f];return n.makeTensorInfo(r.shape,u,h)}},rT=Od,oT=Ld,sT=Wk(Ur,(e=>e>=0?oT*e:rT*(Math.exp(e)-1))),iT={kernelName:Ur,backendName:"cpu",kernelFunc:sT},lT=Wk(Hr,(e=>e<0?-1:e>0?1:0)),cT={kernelName:Hr,backendName:"cpu",kernelFunc:lT},uT=Wk(Gr,(e=>Math.sin(e))),hT={kernelName:Gr,backendName:"cpu",kernelFunc:uT},dT=Wk(jr,(e=>Math.sinh(e))),pT={kernelName:jr,backendName:"cpu",kernelFunc:dT},fT=Math.log(1.1920928955078125e-7)+2,gT=Wk(qr,(e=>{const t=e>-fT,n=e<fT,a=Math.exp(e);let r;return r=n?a:t?e:Math.log(1+a),r})),mT={kernelName:qr,backendName:"cpu",kernelFunc:gT};const bT={kernelName:Jr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,paddings:s}=a;zk([r],"spaceToBatchND");const i=Ot(o),l=[[0,0]];l.push(...s);for(let m=1+o.length;m<r.shape.length;++m)l.push([0,0]);const c=bE.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),u=Cd(c.shape,o,i,!1),h=Nd(u.length,o.length,!1),d=Ed(c.shape,o,i,!1),p=xS({inputs:{x:c},backend:n,attrs:{shape:u}}),f=_S({inputs:{x:p},backend:n,attrs:{perm:h}}),g=xS({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}};function yT(e,t,n,a,r,o,s){const i=t[0],l=o[0],c=new Array(l),u=new Array(i),h=t[1];if(0===l){if(0!==i)throw new Error(ip(i));return[jt(n,0),[0,h],jt(r,0),c,u]}let d=!0,p=0;const f=new Array(l).fill(0);for(let m=0;m<i;++m){const t=e[m*h];if(t<0)throw new Error(lp(m,t));if(t>=l)throw new Error(cp(m,t,l));++f[t],d=d&&t>=p,p=t}let g=!0;for(let m=0;m<l;++m){const e=0===f[m];c[m]=e,g=g&&!e,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&d){const t=e,n=a;for(let e=0;e<i;++e)u[e]=e;return[t,[i,h],n,c,u]}{const t=f[l-1],o=jt(n,t*h),d=jt(r,t),p=new Array(l).fill(0);for(let n=0;n<i;++n){const t=e[n*h],r=p[t],s=(0===t?0:f[t-1])+r;p[t]++;for(let a=0;a<h;++a)o[s*h+a]=e[n*h+a];d[s]=a[n],u[n]=s}for(let e=0;e<l;++e){if(0===p[e]){const t=0===e?0:f[e-1];o[t*h+0]=e;for(let e=1;e<h;++e)o[t*h+e]=0;d[t]=s}}return[o,[t,h],d,c,u]}}const vT={kernelName:Zr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:o,defaultValue:s}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(o.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(r.shape));if(0!==s.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(s.shape));const i=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,u=n.data.get(s.dataId).values[0],[h,d,p,f,g]=yT(i,a.shape,a.dtype,l,r.dtype,c,u);return[n.makeTensorInfo(d,a.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([g.length],a.dtype,new Int32Array(g))]}};function xT(e,t,n,a,r){const o=Ot(a),s=t[0],i=r.length,l=[];let c=1,u=-1;for(let g=0;g<i;++g){const e=r[g];if(-1===e){if(-1!==u)throw new Error(up(u,g));u=g,l.push(1)}else{if(e<0)throw new Error(hp(g,e));c*=e,l.push(e)}}if(-1!==u){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(o/c);if(c*e!==o)throw new Error(pp(a,l));l[u]=e}if(Ot(l)!==o)throw new Error(fp(a,l));const h=a.length,d=[];if(h>0){d[h-1]=1;for(let e=h-2;e>=0;--e)d[e]=d[e+1]*a[e+1]}const p=[];if(i>0){p[i-1]=1;for(let e=i-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=jt(n,s*i);for(let g=0;g<s;++g){let t=0;for(let n=0;n<h;++n)t+=e[g*h+n]*d[n];for(let e=0;e<i;++e)f[g*i+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[s,i],l]}const wT={kernelName:eo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:o}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const s=Array.from(n.data.get(r.dataId).values),i=n.data.get(a.dataId).values,l=Array.from(n.data.get(o.dataId).values),[c,u,h]=xT(i,a.shape,a.dtype,s,l);return[n.makeTensorInfo(u,a.dtype,c),n.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}};function kT(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const i=a.length,l=[t[0],e.length/t[0]],c=l[1],u=i>0?r[i-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=u;const d=jt(n,h.reduce(((e,t)=>e*t),1));if(0===i)return u>0&&d.fill(s),[d,h];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,g=0,m=r[p];for(;;){let t=0;if(f<i){if(t=r[f],m===t){++f;continue}if(m>=t)throw new Error("segment ids are not increasing")}if(m<0||m>=u)throw new Error(bp(m,u));m>g&&d.fill(s,g*c,m*c);for(let n=p;n<f;++n){const t=a[n];if(t<0||t>=l[0])throw new Error(yp(n,a[n],l[0]));for(let n=0;n<c;n++)d[m*c+n]+=e[t*c+n]}if(o)for(let e=0;e<c;e++)d[m*c+e]/=f-p;if(p=f,++f,g=m+1,m=t,f>i)break}return g<u&&d.fill(s,g*c,u*c),[d,h]}const ST={kernelName:to,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(o.shape));if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,[c,u]=kT(s,a.shape,a.dtype,i,l,!0);return n.makeTensorInfo(u,a.dtype,c)}};const IT={kernelName:no,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(o.shape));if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,[c,u]=kT(s,a.shape,a.dtype,i,l);return n.makeTensorInfo(u,a.dtype,c)}};const CT={kernelName:ao,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:o,defaultValue:s}=t,{outputShape:i}=a,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=_d(0,r,i),p=!1,f=n.bufferSync(r);let g;switch(o.dtype){case"bool":g=QE(f,n.bufferSync(o),i,d,u,c,l,h,Boolean(n.data.get(s.dataId).values[0]),p);break;case"float32":g=QE(f,n.bufferSync(o),i,d,u,c,l,h,n.data.get(s.dataId).values[0],p);break;case"int32":g=QE(f,n.bufferSync(o),i,d,u,c,l,h,n.data.get(s.dataId).values[0],p);break;case"string":g=QE(f,n.bufferSync(o),i,d,u,c,l,h,rs(n.data.get(s.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(o.dtype))}return n.makeTensorInfo(i,g.dtype,g.values)}};const NT={kernelName:$r,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:o,axis:s}=a,i=Ut(s,r.shape)[0],l=sp(r,o,i),c=new Array(r.shape.length).fill(0),u=r.shape.slice();return l.map((e=>{const t=[...u];t[i]=e;const a=oI({inputs:{x:r},backend:n,attrs:{begin:c,size:t}});return c[i]+=e,a}))}},ET=Bk((e=>Math.sqrt(e))),TT=Wk(Xr,(e=>Math.sqrt(e))),RT={kernelName:Xr,backendName:"cpu",kernelFunc:TT},AT={kernelName:oo,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:a}=t,r=n;zk(a,"square");const o=r.data.get(a.dataId).values,s=new Float32Array(o.length);for(let i=0;i<o.length;++i){const e=o[i];s[i]=e*e}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},FT=Xk(((e,t)=>{const n=e-t;return n*n})),DT=fS(ro,FT),_T={kernelName:ro,backendName:"cpu",kernelFunc:DT},OT=Bk(((e,t)=>{const{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?"g":""),r)})),LT=Uk(so,OT),zT={kernelName:so,backendName:"cpu",kernelFunc:LT},MT=Wk(So,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),PT={kernelName:So,backendName:"cpu",kernelFunc:MT};function BT(e,t,n,a){const r=Yi(e,t.dtype);for(let o=0;o<r.size;o++){const e=r.indexToLoc(o),s=new Array(e.length);for(let t=0;t<s.length;t++)s[t]=e[t]*n[t]+a[t];r.set(t.get(...s),...e)}return r}const WT={kernelName:io,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,end:s,strides:i,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a;zk(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:y,end:v,strides:x}=ac(r.shape,o,s,i,l,c,u,h,d);let w;if(g)w=xS({inputs:{x:r},backend:n,attrs:{shape:f}});else if(m||b){Ft(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=jl(y,v,x),t=oI({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});w=xS({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=BT(p,n.bufferSync(r),x,y);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class UT{constructor(e,t,n,a,r,o){this.separator=as(e),this.nGramWidths=t,this.leftPad=as(n),this.rightPad=as(a),this.padWidth=r,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,o){for(let s=0;s<r;++s){const i=this.getPadWidth(o),l=Math.max(0,i-s),c=Math.max(0,i-(r-(s+1))),u=o-(l+c),h=t+(l>0?0:s-i);let d=0;d+=l*this.leftPad.length;for(let t=0;t<u;++t)d+=e[h+t].length;d+=c*this.rightPad.length;d+=(l+c+u-1)*this.separator.length,n[a+s]=new Uint8Array(d);const p=n[a+s];let f=0;const g=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)g(this.leftPad),g(this.separator);for(let t=0;t<u-1;++t)g(e[h+t]),g(this.separator);if(u>0){g(e[h+u-1]);for(let e=0;e<c;++e)g(this.separator),g(this.rightPad)}else{for(let e=0;e<c-1;++e)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){const n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let r=1;r<a;++r){let a=t[r]>=e;if(a=a&&t[r]<=n,!a)throw new Error("Invalid split value ".concat(t[r],", must be in [").concat(e,", ").concat(n,"]"));e=t[r]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}const r=a-1,o=jt("int32",a);if(0===n||0===a){const e=new Array(n);for(let t=0;t<=r;++t)o[t]=0;return[e,o]}o[0]=0;for(let i=1;i<=r;++i){const e=t[i]-t[i-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),o[i]=o[i-1]+n}const s=new Array(o[r]);for(let i=0;i<r;++i){const n=t[i];let a=o[i];if(this.nGramWidths.forEach((r=>{const o=t[i+1]-t[i],l=this.getNumNGrams(o,r);this.createNGrams(e,n,s,a,l,r),a+=l})),this.preserveShort&&a===o[i]){const r=t[i+1]-t[i];if(0===r)continue;const o=r+2*this.padWidth,l=1;this.createNGrams(e,n,s,a,l,o)}}return[s,o]}}function VT(e,t,n,a,r,o,s,i){return new UT(n,a,r,o,s,i).compute(e,t)}const GT={kernelName:lo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:s,rightPad:i,padWidth:l,preserveShortSequences:c}=a,{data:u,dataSplits:h}=t,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,g]=VT(d,p,r,o,s,i,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",g)]}};function jT(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let o=e.indexOf(r);for(;-1!==o;){const t=e.subarray(0,o);n&&0===t.length||a.push(t),o=(e=e.subarray(o+1)).indexOf(r)}return void(n&&0===e.length||a.push(e))}let r=0;for(let o=0;o<e.length+1;o++)if(o===e.length||-1!==t.indexOf(e[o])){const t=e.subarray(r,o);n&&0===t.length||a.push(t),r=o+1}}function HT(e,t,n){const a=e.length,r=[];let o=0,s=0;const i=new Array(a);for(let d=0;d<a;++d){const a=r.length;jT(e[d],t,n,r);const l=r.length-a;i[d]=l,o+=l,s=Math.max(s,l)}const l=jt("int32",2*o),c=new Array(o),u=[a,s];let h=0;for(let d=0;d<a;++d)for(let e=0;e<i[d];++e)l[2*h]=d,l[2*h+1]=e,c[h]=r[h],++h;return[l,c,u]}const KT={kernelName:co,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:s}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==s.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(s.shape));const i=n.data.get(o.dataId).values,l=n.data.get(s.dataId).values[0],[c,u,h]=HT(i,l,r),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function qT(e,t){const n=jt("int32",e.length);for(let a=0;a<e.length;++a)n[a]=Zo(e[a]).modulo(t).getLowBitsUnsigned();return n}const XT={kernelName:uo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const s=qT(n.data.get(o.dataId).values,r);return n.makeTensorInfo(o.shape,"int32",s)}},YT=Wk(po,(e=>Math.tan(e))),JT={kernelName:po,backendName:"cpu",kernelFunc:YT},$T=Wk(fo,(e=>Math.tanh(e)));const QT={kernelName:Pr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:o}=t,{sliceRank:s,numUpdates:i,sliceSize:l,strides:c,outputSize:u}=_d(0,r,a.shape),h=n.bufferSync(r),d=n.bufferSync(o),p=n.bufferSync(a),f=QE(h,d,a.shape,u,l,i,s,c,p,!1);return n.makeTensorInfo(a.shape,f.dtype,f.values)}};function ZT(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const a=Yi(n,e.dtype);for(let r=0;r<a.values.length;++r){const t=a.indexToLoc(r),n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=t[a]%e.shape[a];const o=e.locToIndex(n);a.values[r]=e.values[o]}return a}const eR={kernelName:go,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:o}=a;zk(r,"tile");const s=ZT(n.bufferSync(r),o);return n.makeTensorInfo(s.shape,s.dtype,s.values)}},tR=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function nR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;a>n;){if(a-n>600){const r=a-n+1,o=t-n+1,s=Math.log(r),i=.5*Math.exp(2*s/3),l=.5*Math.sqrt(s*i*(r-i)/r)*Math.sign(o-r/2);nR(e,t,Math.max(n,Math.floor(t-o*i/r+l)),Math.min(a,Math.floor(t+(r-o)*i/r+l)))}const r=e[t];let o=n,s=a;for(At(e,n,t),tR(e[a],r)>0&&At(e,n,a);o<s;){for(At(e,o,s),o++,s--;tR(e[o],r)<0;)o+=1;for(;tR(e[s],r)>0;)s-=1}0===tR(e[n],r)?At(e,n,s):(s+=1,At(e,s,a)),s<=t&&(n=s+1),t<=s&&(a=s-1)}}function aR(e,t,n,a,r){const o=t[t.length-1],[s,i]=[e.length/o,o],l=Gt(n,s*a),c=Gt("int32",s*a);for(let h=0;h<s;h++){const t=h*i,n=e.subarray(t,t+i);let o=new Array(n.length);n.forEach(((e,t)=>o[t]={value:e,index:t})),a<o.length&&(nR(o,a),o=o.slice(0,a)),r&&o.sort(tR);const s=h*a,u=l.subarray(s,s+a),d=c.subarray(s,s+a);for(let e=0;e<a;e++)u[e]=o[e].value,d[e]=o[e].index}const u=t.slice();return u[u.length-1]=a,[Yi(u,n,l),Yi(u,"int32",c)]}const rR={kernelName:mo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:o,sorted:s}=a;zk(r,"topk");const i=n.data.get(r.dataId).values,[l,c]=aR(i,r.shape,r.dtype,o,s);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}};const oR={kernelName:bo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:o}=t,{interpolation:s,fillMode:i,fillValue:l,outputShape:c}=n,[u,h,d,p]=r.shape,[f,g]=null!=c?c:[h,d],m=[u,f,g,p],b=Qt(r.shape),y=b[0],v=b[1],x=b[2],w=Qt(m),k=w[0],S=w[1],I=w[2],C=Gt(r.dtype,Ot(m));C.fill(l);const N=a.data.get(r.dataId).values,E=a.data.get(o.dataId).values;for(let T=0;T<u;++T){const e=1===o.shape[0]?E:E.subarray(8*T,8*T+8);for(let t=0;t<f;++t)for(let n=0;n<g;++n)for(let a=0;a<p;++a){let r;const o=e[6]*n+e[7]*t+1;if(0===o)continue;const c=(e[0]*n+e[1]*t+e[2])/o,u=(e[3]*n+e[4]*t+e[5])/o,p=sR(c,d,i),f=sR(u,h,i);switch(s){case"nearest":r=lR(N,h,d,y,v,x,T,f,p,a,l);break;case"bilinear":r=cR(N,h,d,y,v,x,T,f,p,a,l);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(s))}C[T*k+t*S+n*I+a]=r}return a.makeTensorInfo(m,r.dtype,C)}return{dataId:a.write(C,m,r.dtype),shape:r.shape,dtype:r.dtype}}};function sR(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Tt(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return Tt(0,n,t-1)}(e,t);case"nearest":return function(e,t){return Tt(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function iR(e,t,n,a,r,o,s,i,l,c,u){return 0<=i&&i<t&&0<=l&&l<n?e[s*a+i*r+l*o+c]:u}function lR(e,t,n,a,r,o,s,i,l,c,u){return iR(e,t,n,a,r,o,s,Math.round(i),Math.round(l),c,u)}function cR(e,t,n,a,r,o,s,i,l,c,u){const h=Math.floor(i),d=Math.floor(l),p=h+1,f=d+1;return(p-i)*((f-l)*iR(e,t,n,a,r,o,s,h,d,c,u)+(l-d)*iR(e,t,n,a,r,o,s,h,f,c,u))+(i-h)*((f-l)*iR(e,t,n,a,r,o,s,p,d,c,u)+(l-d)*iR(e,t,n,a,r,o,s,p,f,c,u))}function uR(e,t,n,a){const r=Ut(t,n)[0],o=[1,n[0],1];for(let f=0;f<r;f++)o[0]*=n[f];o[1]=n[r];for(let f=r+1;f<n.length;f++)o[2]*=n[f];const s=new Map,i=new Int32Array(n[r]),l=new gs(o,a,e),c=[],u=1===o[0]&&1===o[2];for(let f=0;f<n[r];f++){let t;if(u)t=e[f].toString();else{const e=[];for(let t=0;t<o[0];t++)for(let n=0;n<o[2];n++)e.push(l.get(t,f,n));t=e.join(",")}const n=s.get(t);if(null!=n)i[f]=n;else{const e=s.size;s.set(t,e),i[f]=e,c.push(f)}}const h=o.slice();h[1]=s.size;const d=new gs(h,a);c.forEach(((e,t)=>{for(let n=0;n<o[0];n++)for(let a=0;a<o[2];a++)d.set(l.get(n,e,a),n,t,a)}));const p=n.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:i}}const hR={kernelName:vo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:o}=t;zk(o,"unique");const s=a.data.get(o.dataId).values,{outputValues:i,outputShape:l,indices:c}=uR(s,r,o.shape,o.dtype);return[a.makeTensorInfo(l,o.dtype,i),a.makeTensorInfo([c.length],"int32",c)]}};const dR={kernelName:xo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:o}=a;o<0&&(o+=r.shape.length);const s=r.shape.length,i=r.shape[o],l=new Array(s-1);let c=0;for(let p=0;p<s;p++)p!==o&&(l[c++]=r.shape[p]);const u=new Array(s).fill(0),h=r.shape.slice();h[o]=1;const d=new Array(i);for(let p=0;p<d.length;p++){u[o]=p;const e=oI({inputs:{x:r},backend:n,attrs:{begin:u,size:h}});d[p]=xS({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return d}};const pR={kernelName:wo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:o}=t,{numSegments:s}=a;zk(r,"unsortedSegmentSum");const i=[],l=[],c=r.shape.length-o.shape.length;let u=o;for(let d=0;d<c;++d){const e=yC({inputs:{input:u},backend:n,attrs:{dim:d+1}});u=e,l.push(e)}for(let d=0;d<s;++d){const e=es(d,"int32"),t=n.makeTensorInfo([],"int32",e),a=oC({inputs:{a:t,b:u},backend:n}),o=dS({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),s=QI({inputs:{a:o,b:r},backend:n}),c=eC({inputs:{x:s},backend:n,attrs:{axis:0,keepDims:!1}});i.push(c),l.push(t),l.push(a),l.push(o),l.push(s),l.push(c)}const h=gE({inputs:i,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},fR=[IS,NS,TS,AS,vS,FS,LS,zS,MS,PS,WS,VS,jS,qS,YS,ZS,eI,tI,nI,SS,aI,iI,uI,dI,pI,pS,mI,yI,iS,vI,II,NI,EI,TI,RI,AI,FI,_I,LI,zI,MI,PI,BI,WI,VI,GI,jI,HI,KI,qI,XI,YI,nC,Gk,aC,sC,fC,bC,vC,kC,_C,LC,zC,BC,VC,GC,jC,KC,XC,$C,eN,Hk,tN,kI,aN,oN,iN,qk,uN,pN,gN,yN,xN,SN,CN,TN,RN,AN,_N,zN,MN,PN,BN,WN,UN,VN,GN,KN,qN,JN,ZN,ZI,tE,aE,oE,iE,uE,hE,fE,mE,bE,xE,$k,kE,EE,AE,zE,PE,uS,CC,WE,Zk,tS,wS,UE,VE,GE,jE,HE,KE,XE,$E,ZE,nT,aT,iT,rS,cT,hT,pT,sI,QN,mT,bT,vT,wT,ST,IT,CT,NT,RT,AT,_T,zT,PT,WT,GT,KT,XT,RC,tC,JT,{kernelName:fo,backendName:"cpu",kernelFunc:$T},QT,eR,rR,oR,OS,hR,dR,pR,pE];for(const n of fR)zo(n);const gR={},mR={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function bR(e,t){if(!(e in gR)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(dn().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete gR[e]}),!1),dn().getBool("SOFTWARE_WEBGL_ENABLED")&&(mR.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",mR)||n.getContext("experimental-webgl",mR);return n.getContext("webgl2",mR)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;gR[e]=n}const n=gR[e];return null==n||n.isContextLost()?(delete gR[e],bR(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),gR[e])}var yR,vR,xR;function wR(e,t){return[t,e]}function kR(e){const t=Ot(e);return Mt(Math.ceil(t/4))}function SR(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function IR(e,t){const n=e;let a,r,o,s,i,l,c,u,h,d;return 2===dn().getNumber("WEBGL_VERSION")?(a=n.R32F,r=n.R16F,o=n.RGBA16F,s=n.RGBA32F,i=n.RED,c=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(a=e.RGBA,r=e.RGBA,o=e.RGBA,s=n.RGBA,i=e.RGBA,c=4,u=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,l=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function CR(e,t){const n=t();return dn().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(yR||(yR={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(vR||(vR={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(xR||(xR={}));function NR(e){return!!(dn().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function ER(e,t){return zR(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const TR=/ERROR: [0-9]+:([0-9]+):/g;function RR(e,t){const n=TR.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);const a=+n[1],r=e.split("\n"),o=r.length.toString().length+2,s=r.map(((e,t)=>Pt((t+1).toString(),o)+e));let i=0;for(let h=0;h<s.length;h++)i=Math.max(s[h].length,i);const l=s.slice(0,a-1),c=s.slice(a-1,a),u=s.slice(a);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(Pt(c[0],i)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function AR(e,t){if(CR(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function FR(e,t,n,a,r,o,s){const i=e.getAttribLocation(t,n);return-1!==i&&(CR(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,a))),CR(e,(()=>e.vertexAttribPointer(i,r,e.FLOAT,!1,o,s))),CR(e,(()=>e.enableVertexAttribArray(i))),!0)}function DR(e,t,n,a){CR(e,(()=>function(e,t,n){MR(e,n),CR(e,(()=>e.activeTexture(e.TEXTURE0+n))),CR(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,a))),CR(e,(()=>e.uniform1i(n,a)))}function _R(e,t,n){CR(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),CR(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function OR(e,t){CR(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),CR(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function LR(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}(e,t))}function zR(e,t,n){const a=CR(e,(()=>t()));if(null==a)throw new Error(n);return a}function MR(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){const e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function PR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Ot(e.slice(0,e.length-t))}function BR(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function WR(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[PR(e),...BR(e)]),t}function UR(e){return e%2===0}function VR(e,t){if(Lt(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],a=t[t.length-1];if(n===a)return!0;if(UR(n)&&UR(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&UR(e[0])&&UR(t[0])}let GR,jR;function HR(e,t){return null!=e.getExtension(t)}function KR(e){try{if(null!=bR(e))return!0}catch(IW){return console.log("Error when getting WebGL context: ",IW),!1}return!1}function qR(e){if(0===e)return!1;const t=bR(e);if(1!==e){if(HR(t,"EXT_color_buffer_float"))return XR(t);const e="EXT_color_buffer_half_float";if(HR(t,e)){const n=t.getExtension(e);return function(e,t){const n=IR(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const r=1,o=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,r,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(s),i}(t,n)}return!1}if(!HR(t,"OES_texture_float"))return!1;if(!HR(t,"WEBGL_color_buffer_float"))return!1;return XR(t)}function XR(e){const t=IR(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function YR(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Ft("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors ")+"in the WebGL backend."))}))}const JR=dn();function $R(){let e,t,n,a,r,o,s,i,l,c;return 2===dn().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",r="texture",o="outputColor",s="out vec4 outputColor;",i=dn().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",r="texture2D",o="gl_FragColor",s="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:o,defineOutput:s,defineSpecialNaN:i,defineSpecialInf:l,defineRound:c}}function QR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=Qt(t);return a.map(((t,r)=>{const o="int ".concat(e[r]," = ").concat(n," / ").concat(t),s=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * ").concat(t):"index -= ".concat(e[r]," * ").concat(t);return"".concat(o,"; ").concat(s,";")})).join("")}function ZR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=Qt(t);return a.map(((t,r)=>{const o="int ".concat(e[r]," = ").concat(n," / outShapeStrides[").concat(r,"]"),s=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * outShapeStrides[").concat(r,"]"):"index -= ".concat(e[r]," * outShapeStrides[").concat(r,"]");return"".concat(o,"; ").concat(s,";")})).join("")}function eA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=e.map(((e,t)=>t)),r=function(e,t){const n=e.length,a=e.map((e=>"".concat(t,"[").concat(e,"]"))),r=new Array(n-1);r[n-2]=a[n-1];for(let o=n-3;o>=0;--o)r[o]="(".concat(r[o+1]," * ").concat(a[o+1],")");return r}(a,t);return r.map(((t,a)=>{const o="int ".concat(e[a]," = ").concat(n," / ").concat(r[a]),s=a===r.length-1?"int ".concat(e[a+1]," = ").concat(n," - ").concat(e[a]," * ").concat(r[a]):"index -= ".concat(e[a]," * ").concat(r[a]);return"".concat(o,"; ").concat(s,";")})).join("")}function tA(e){const t=Qt(e).map((e=>e.toString()));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}JR.registerFlag("HAS_WEBGL",(()=>JR.getNumber("WEBGL_VERSION")>0)),JR.registerFlag("WEBGL_VERSION",(()=>KR(2)?2:KR(1)?1:0)),JR.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),JR.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===JR.get("WEBGL_VERSION"))),JR.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),JR.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),JR.registerFlag("WEBGL_PACK",(()=>JR.getBool("HAS_WEBGL"))),JR.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>JR.getBool("WEBGL_PACK"))),JR.registerFlag("WEBGL_PACK_CLIP",(()=>JR.getBool("WEBGL_PACK"))),JR.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>JR.getBool("WEBGL_PACK"))),JR.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>JR.getBool("WEBGL_PACK"))),JR.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>JR.getBool("WEBGL_PACK"))),JR.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>JR.getBool("WEBGL_PACK"))),JR.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>JR.getBool("WEBGL_PACK"))),JR.registerFlag("WEBGL_PACK_REDUCE",(()=>JR.getBool("WEBGL_PACK"))),JR.registerFlag("WEBGL_LAZILY_UNPACK",(()=>JR.getBool("WEBGL_PACK"))),JR.registerFlag("WEBGL_CONV_IM2COL",(()=>JR.getBool("WEBGL_PACK"))),JR.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>JR.getBool("WEBGL_PACK"))),JR.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==GR){const t=bR(e);GR=t.getParameter(t.MAX_TEXTURE_SIZE)}return GR}(JR.getNumber("WEBGL_VERSION")))),JR.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==jR){const t=bR(e);jR=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,jR)}(JR.getNumber("WEBGL_VERSION")))),JR.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=JR.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=bR(e);return t=HR(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:HR(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),JR.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>JR.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Gs())),JR.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=bR(e);if(1===e){if(!HR(t,"OES_texture_float"))return!1}else if(!HR(t,"EXT_color_buffer_float"))return!1;return XR(t)}(JR.getNumber("WEBGL_VERSION")))),JR.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!JR.getBool("WEBGL_FORCE_F16_TEXTURES")&&JR.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),JR.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>qR(JR.getNumber("WEBGL_VERSION")))),JR.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=JR.getNumber("WEBGL_VERSION"))&&null!=bR(e).fenceSync;var e})),JR.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>JR.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),JR.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))})),JR.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Gs()?1:-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))})),JR.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),JR.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),JR.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),JR.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),JR.registerFlag("WEBGL_EXP_CONV",(()=>!1)),JR.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>JR.getBool("IS_TEST"))),JR.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),JR.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),JR.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),JR.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const nA="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:aA}=a;function rA(e,t,n){const a=[];if(e.forEach((e=>{const t=Ot(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(a.push("uniform sampler2D ".concat(e.name,";")),a.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){const{uniformShape:t}=fA(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:a.push("uniform int ".concat(e.name,"Shape;"));break;case 2:a.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:a.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:a.push("uniform ivec4 ".concat(e.name,"Shape;"))}a.push("uniform ivec2 ".concat(e.name,"TexShape;"))}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{a.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))}));const r=a.join("\n"),o=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0,r="";r+=n?sA(e,a):oA(e,a);const o=e.shapeInfo.logicalShape,s=t.logicalShape;o.length<=s.length&&(r+=n?function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",o=e.shapeInfo.logicalShape.length,s=t.logicalShape.length,i=aA(e.shapeInfo.logicalShape,t.logicalShape),l=pA(s),c=s-o;let u;const h=["x","y","z","w","u","v"];u=0===o?"":s<2&&i.length>=1?"coords = 0;":i.map((e=>"coords.".concat(h[e+c]," = 0;"))).join("\n");let d="";d=s<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(h[t+c]))).join(", ");let p="return outputValue;";const f=1===Ot(e.shapeInfo.logicalShape),g=Ot(t.logicalShape),m=1===g;if(1!==o||f||m){if(f&&!m)p=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=o-2,t=o-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?p="return vec4(outputValue.x);":i.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(r,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(a,"(").concat(d,");\n      ").concat(p,"\n    }\n  ")}(e,t):function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",o=t.texShape,s=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===l&&null==e.shapeInfo.flatOffset&&Lt(s,o))return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const c=pA(l),u=aA(e.shapeInfo.logicalShape,t.logicalShape),h=l-i;let d;const p=["x","y","z","w","u","v"];d=0===i?"":l<2&&u.length>=1?"coords = 0;":u.map((e=>"coords.".concat(p[e+h]," = 0;"))).join("\n");let f="";f=l<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(p[t+h]))).join(", ");return"\n    float ".concat(r,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(d,"\n      return get").concat(a,"(").concat(f,");\n    }\n  ")}(e,t));return r}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),s=t.texShape,i=$R(),l=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(i);let c,u,h=function(e){const t="".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(iA,"\n    ").concat(lA,"\n    ").concat(cA,"\n  ");return t}(i);t.isPacked?(c=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===a[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(a[1],".0);\n      }\n    ");if(1===a[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(a[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      return 2 * (resTexRC.x * ").concat(a[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Lt(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(a[0],", ").concat(a[1],"));\n      }\n    ");const r=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),o=r*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),o=r*Math.ceil(e[e.length-2]/2);let s=o,i="",l="b, r, c";for(let c=2;c<e.length-1;c++)s*=e[e.length-c-1],i="\n      int b".concat(c," = index / ").concat(s,";\n      index -= b").concat(c," * ").concat(s,";\n    ")+i,l="b".concat(c,", ")+l;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      ").concat(i,"\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec").concat(e.length,"(").concat(l,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,s,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(i)):(c=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){if(Lt(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n){const t=ZR(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(t,"\n    return ivec3(r, c, d);\n  }\n")}const a=QR(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n){const t=ZR(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const a=QR(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){const n=QR(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){const n=QR(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,s,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(i)),n.packedInputs&&(h+=uA);return[h,l,u,r,c,o,n.userCode].join("\n")}function oA(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(a,"() {return ").concat(n,";}");const[r,o]=e.shapeInfo.texShape;if(1===r&&1===o)return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const s=hA(n);if(t)return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[i,l]=e.shapeInfo.texShape;return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(i,", ").concat(l,", ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int index) {\n        ").concat(dA(e),"\n      }\n    ");const r=e.shapeInfo.texShape,o=r[0],s=r[1];if(1===s&&1===o)return"\n      float ".concat(a,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=hA(n);if(1===s)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / ").concat(o,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===o)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / ").concat(s,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(t)return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(o,", ").concat(s,", index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape;if(null!=o&&Lt(n,o)){if(t)return"\n      float ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const e=o[0],n=o[1];return"\n    float ".concat(r,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}const{newShape:s,keptDims:i}=Vt(n),l=s;if(l.length<n.length){const n=gA(e,l),a=["row","col"];return"\n      ".concat(oA(n,t),"\n      float ").concat(r,"(int row, int col) {\n        return ").concat(r,"(").concat(mA(a,i),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(dA(e),"\n      }\n    ");const c=o[0],u=o[1],h=hA(a);if(1===u)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(c,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(1===c)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(t)return"\n      float ".concat(r,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(h,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");return"\n  float ".concat(r,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(h,";\n    vec2 uv = uvFromFlat(").concat(c,", ").concat(u,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=n[1]*n[2],s=n[2],{newShape:i,keptDims:l}=Vt(n),c=i;if(c.length<n.length){const n=gA(e,c),a=["row","col","depth"];return"\n        ".concat(oA(n,t),"\n        float ").concat(r,"(int row, int col, int depth) {\n          return ").concat(r,"(").concat(mA(a,l),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(o,", ").concat(s,", 1)));\n        ").concat(dA(e),"\n      }\n    ");const u=e.shapeInfo.texShape,h=u[0],d=u[1],p=e.shapeInfo.flatOffset;if(d===o&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(r,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(s,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(d,".0, ").concat(h,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(d===s&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(d,".0, ").concat(h,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");const f=hA(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    ");return"\n      float ".concat(r,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(o," + col * ").concat(s," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(h,", ").concat(d,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=n[3],s=n[2]*o,i=n[1]*s,{newShape:l,keptDims:c}=Vt(n);if(l.length<n.length){const n=gA(e,l),a=["row","col","depth","depth2"];return"\n      ".concat(oA(n,t),"\n      float ").concat(r,"(int row, int col, int depth, int depth2) {\n        return ").concat(r,"(").concat(mA(a,c),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(i,", ").concat(s,", ").concat(o,", 1)));\n        ").concat(dA(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f="int stride2 = ".concat(a,"Shape[3];"),g="int stride1 = ".concat(a,"Shape[2] * stride2;"),m="int stride0 = ".concat(a,"Shape[1] * stride1;");if(p===i&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(g,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(s,", ").concat(o,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(p===o&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const b=hA(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(g,"\n      ").concat(m,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(b,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(s," +\n          depth * ").concat(o," + depth2;\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index + ").concat(b,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],o=t[3]*r,s=t[2]*o,i=t[1]*s,{newShape:l,keptDims:c}=Vt(t);if(l.length<t.length){const t=gA(e,l),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(oA(t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(mA(n,c),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(i,", ").concat(s,", ").concat(o,", ").concat(r,")) +\n          depth3;\n        ").concat(dA(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===i&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(s,", ").concat(o,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===r&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=hA(n);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(s," + depth * ").concat(o," +\n          depth2 * ").concat(r," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:o}=Vt(t);if(r.length<t.length){const t=gA(e,r),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(oA(t),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(mA(n,o),");\n      }\n    ")}const s=t[5],i=t[4]*s,l=t[3]*i,c=t[2]*l,u=t[1]*c;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(c,", ").concat(l,", ").concat(i,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(s,", 1)));\n        ").concat(dA(e),"\n      }\n    ");const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(c,", ").concat(l,", ").concat(i,", ").concat(s,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===s&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const g=hA(n);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(c," + depth * ").concat(l," +\n          depth2 * ").concat(i," + depth3 * ").concat(s," + depth4 + ").concat(g,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function sA(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=$R();return"\n    vec4 ".concat(n,"() {\n      return ").concat(a.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,o=$R();if(t)return"\n    vec4 ".concat(a,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ");const s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return"\n    vec4 ".concat(a,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(s[0],", ").concat(s[1],", index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,s=o[0],i=o[1],l=$R();if(null!=o&&Lt(n,o))return t?"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(l.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(i,".0, ").concat(s,".0);\n\n        return ").concat(l.texture2D,"(").concat(a,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(r,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(l.texture2D,"(").concat(a,", uv);\n    }\n  ");const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(c[0],", ").concat(c[1],", row, col);\n      return ").concat(l.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,s=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===n[0]){const a=[1,2],o=gA(e,n.slice(1)),s=["b","row","col"];return"\n        ".concat(sA(o,t),"\n        vec4 ").concat(r,"(int b, int row, int col) {\n          return ").concat(r,"(").concat(mA(s,a),");\n        }\n      ")}const i=$R();if(t)return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ");const l=s[0],c=s[1],u=Math.ceil(n[2]/2),h=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(l,", ").concat(c,", ").concat(h,", ").concat(u,", b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);default:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=$R();if(t)return"\n    vec4 ".concat(a,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ");const o=e.shapeInfo.logicalShape,s=o.length,i=e.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=l[0],u=l[1],h=Math.ceil(o[s-1]/2);let d=h*Math.ceil(o[s-2]/2),p="int b, int row, int col",f="b * ".concat(d," + (row / 2) * ").concat(h," + (col / 2)");for(let g=2;g<s-1;g++)p="int b".concat(g,", ")+p,d*=o[s-g-1],f="b".concat(g," * ").concat(d," + ")+f;return"\n    vec4 ".concat(a,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(c,");\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}const iA="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",lA="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",cA="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",uA="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function hA(e){return"offset".concat(e)}function dA(e){const t=e.name,n=Ot(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function pA(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function fA(e,t,n){const{newShape:a,keptDims:r}=Vt(t),o=t.length,s=e&&3===o&&1===t[0],i=s?t.slice(1):a,l=!e&&o>1&&!Lt(t,n)&&a.length<o||s;return{useSqueezeShape:l,uniformShape:l?i:t,keptDims:r}}function gA(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function mA(e,t){return t.map((t=>e[t])).join(", ")}function bA(e,t,n,a){const r=n.map(((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}})),o=r.map((e=>e.shapeInfo)),s={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},i=rA(r,s,t),l=function(e,t){const n=zR(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(CR(e,(()=>e.shaderSource(n,t))),CR(e,(()=>e.compileShader(n))),dn().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw RR(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,i),c=e.createProgram(l);return dn().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:i,webGLProgram:c,inShapeInfos:o,outShapeInfo:s,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(c),Object.assign({program:t,fragmentShader:l,source:i,webGLProgram:c,inShapeInfos:o,outShapeInfo:s},yA(e,t,c)))}function yA(e,t,n){const a=[],r=[];let o,s,i,l=null,c=null;c=e.getUniformLocation(n,"NAN",!1),1===dn().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const h of t.variableNames){const r={name:h,uniform:e.getUniformLocation(n,h,u),offset:e.getUniformLocation(n,"offset".concat(h),u)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,"".concat(h,"Shape"),u),r.texShape=e.getUniformLocation(n,"".concat(h,"TexShape"),u)),a.push(r)}if(t.enableShapeUniforms&&(o=e.getUniformLocation(n,"outShape",u),i=e.getUniformLocation(n,"outShapeStrides",u),s=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(const h of t.customUniforms)r.push(e.getUniformLocation(n,h.name,u));return{variablesLocations:a,customUniformLocations:r,infLoc:l,nanLoc:c,outShapeLocation:o,outShapeStridesLocation:i,outTexShapeLocation:s}}function vA(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(t.length," inputs"));e.forEach(((e,n)=>{const a=e.logicalShape,r=t[n],o=r.shape;if(!Lt(a,o))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(a," and ").concat(o," must match"));if(e.isUniform&&r.isUniform)return;const s=e.texShape,i=r.isUniform?null:r.texData.texShape;if(!Lt(s,i))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(s," and ").concat(i," must match"))}))}function xA(e){return dn().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class wA{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=yR.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=$R();this.outputShape=e,this.enableShapeUniforms=xA(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?ZR(["r","c","d"],e):QR(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class kA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=yR.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=$R();this.outputShape=e,this.enableShapeUniforms=xA(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?ZR(["r","c","d"],e):QR(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class SA{constructor(e){this.variableNames=["A"],this.outTexUsage=vR.DOWNLOAD;const t=$R();this.outputShape=e,this.userCode="\n      ".concat(nA,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class IA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=vR.DOWNLOAD;const t=$R();this.outputShape=e,this.userCode="\n      ".concat(nA,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}const CA={R:0,G:1,B:2,A:3};class NA{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=$R();this.outputShape=e,this.enableShapeUniforms=xA(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let o="";for(let s=0;s<n.length;s++){const e=n[s];o+="\n          if(offset == ".concat(s,") {\n            result = values[").concat(CA[e],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":tA(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(a.texture2D,"(A, uv);\n          ").concat(o,"\n        }\n        ").concat(a.output," = vec4(").concat(r,", 0., 0., 0.);\n      }\n    ")}}class EA{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=$R();this.outputShape=e,this.enableShapeUniforms=xA(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let t=0;t<=1;t++){const r=2*o+t;a+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(o," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(o,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(r,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(r,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(r,"] = values[2];\n            } else {\n              result[").concat(r,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":tA(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a,"\n\n          ").concat(n.output," = ").concat(r,";\n        }\n    ")}}function TA(e){const t=$R();return function(e,t){const n=zR(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(CR(e,(()=>e.shaderSource(n,t))),CR(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function RA(e){return function(e,t){const n=zR(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return CR(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),CR(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function AA(e){return function(e,t){const n=zR(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return CR(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),CR(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function FA(e,t,n,a,r,o){!function(e,t){const n=dn().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const a="[".concat(e,"x").concat(t,"]"),r="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}(t,n);const s=function(e){return zR(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),i=e.TEXTURE_2D;return CR(e,(()=>e.bindTexture(i,s))),CR(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),CR(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),CR(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),CR(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===dn().getNumber("WEBGL_VERSION")?CR(e,(()=>e.texImage2D(i,0,a,t,n,0,r,o,null))):CR(e,(()=>e.texStorage2D(i,1,a,t,n))),CR(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:s,texShape:[n,t]}}function DA(e){return e.internalFormatFloat}function _A(e){return e.internalFormatHalfFloat}function OA(e){return e.downloadTextureFormat}function LA(e){return e.internalFormatPackedFloat}function zA(e){return e.internalFormatPackedHalfFloat}function MA(e,t,n,a,r,o,s,i){const l=e,c=new Float32Array(function(e,t){const[n,a]=SR(e,t);return n*a*4}(o,s));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}class PA{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=dn().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){gR[e]=t}(t,e)):this.gl=bR(t),e=this.gl,2===dn().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>CR(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>CR(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>CR(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>CR(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>CR(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>CR(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>CR(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>CR(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===dn().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=ER(this.gl,e),HR(this.gl,t))this.textureHalfFloatExtension=ER(this.gl,t);else if(dn().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),HR(this.gl,a))this.colorBufferHalfFloatExtension=ER(this.gl,a);else if(dn().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",HR(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!HR(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=RA(this.gl),this.indexBuffer=AA(this.gl),this.framebuffer=function(e){return zR(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=IR(this.gl,this.textureHalfFloatExtension)}get debug(){return dn().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;CR(e,(()=>e.finish())),CR(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),CR(e,(()=>e.deleteFramebuffer(this.framebuffer))),CR(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),CR(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),CR(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=wR(t,n);return FA(e,r,o,DA(a),a.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=wR(t,n);return FA(e,r,o,_A(a),a.textureFormatFloat,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=wR(t,n);return FA(e,r,o,OA(a),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){CR(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===dn().getNumber("WEBGL_VERSION")?CR(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):CR(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===dn().getNumber("WEBGL_VERSION")?CR(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):CR(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),CR(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),function(e,t,n,a,r,o){let s,i,l;CR(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),r instanceof Uint8Array?(s=new Uint8Array(n*a*4),i=e.UNSIGNED_BYTE,l=e.RGBA):(s=new Float32Array(n*a*4),i=e.FLOAT,l=o.internalFormatPackedFloat),s.set(r),2===dn().getNumber("WEBGL_VERSION")?CR(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,i,s))):CR(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,a,0,e.RGBA,i,s))),CR(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=SR(t,n);return FA(e,r,o,zA(a),e.RGBA,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=SR(t,n);return FA(e,r,o,LA(a),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(OR(this.gl,this.framebuffer),this.outputTexture=null),CR(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,a){const[r,o]=wR(t,n),s=new Uint8Array(t*n*4);return CR(e,(()=>e.readPixels(0,0,r,o,a.downloadTextureFormat,e.UNSIGNED_BYTE,s))),new Float32Array(s.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,a,r,o){return MA(this.gl,e,0,0,0,r,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=function(e,t,n){const a=e.createBuffer();CR(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));const r=16*t*n;return CR(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,r,e.STREAM_READ))),CR(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),CR(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(dn().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(r,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=r}else dn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,dn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const a=new Float32Array(t*n*4);return CR(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a))),a}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=TA(t));const n=function(e){return zR(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);CR(t,(()=>t.attachShader(n,this.vertexShader))),CR(t,(()=>t.attachShader(n,e))),function(e,t){if(CR(e,(()=>e.linkProgram(t))),!dn().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&AR(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;CR(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){CR(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),FR(e,t,"clipSpacePos",n,3,20,0)&&FR(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(CR(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&AR(this.gl,this.program),CR(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return zR(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),CR(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),DR(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,r]=SR(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&AR(this.gl,this.program),LR(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}CR(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),CR(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=ER(this.gl,2===dn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===dn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===dn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Bt((()=>this.disposed||this.isQueryAvailable(e,dn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,dn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in dn().platform&&(n=dn().platform.setTimeoutCustom.bind(dn().platform)),Bt((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),_R(this.gl,e,this.framebuffer),this.debug&&LR(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(_R(this.gl,this.outputTexture,this.framebuffer),this.debug&&LR(this.gl)):OR(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;_R(a,e,this.framebuffer),this.debug&&LR(a),this.outputTexture=e,CR(a,(()=>a.viewport(0,0,t,n))),CR(a,(()=>a.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),CR(this.gl,(()=>this.gl.scissor(e,t,n,a)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:BA,XI:WA,Nk:UA,f6:VA,ct:GA,YG:jA,hH:HA,z3:KA,sG:qA,uM:XA,vS:YA,qB:JA,GG:$A,rq:QA,lg:ZA,WR:eF,cu:tF,GE:nF,px:aF,jC:rF,He:oF,hE:sF,BF:iF,Dk:lF,cl:cF,_B:uF,ub:hF,_f:dF,Ku:pF,qy:fF,Zy:gF,bu:mF,zv:bF,dH:yF,HS:vF,yH:xF,l3:wF,z9:kF,x6:SF,_m:IF,eW:CF,GK:NF,SP:EF,yr:TF,dl:RF,Dw:AF,xT:FF,_X:DF,wz:_F}=r;function OF(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>"".concat(e,".").concat(t)))}function LF(e,t){return 1===t?[e]:OF(e,t)}class zF{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=xA(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=LF("rc",this.rank),t=pA(this.rank),n=this.getOutOfBoundsCondition(e),a=this.getSetup(e),r=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(a,"\n\n            setOutput(vec4(").concat(r,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r="".concat(0===n?"r":"rp1",", ").concat(0===a?"c":"cp1");for(let t=2;t<this.rank;t++)r="".concat(e[e.length-1-t],",")+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(a,";\n    ")}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(e," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}class MF{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=xA(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(a>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(a,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(a>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){const n=t?eA(["r","c","d"],"inputShape"):QR(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":tA(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class PF{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const a=WF(t,n),r=UF(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const o=BF(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[r].pop();return this.usedTextures[r].push(e),e}let s;return a===xR.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===xR.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===xR.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===xR.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===xR.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(s),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),s}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const r=WF(n,a),o=UF(t,r,a);o in this.freeTextures||(this.freeTextures[o]=[]);const s=BF(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),i=dn().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=s):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=s),this.numUsedTextures--;const l=this.usedTextures[o],c=l&&l.indexOf(e);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function BF(e,t,n,a,r){const o=function(e,t){switch(e){case xR.PACKED_2X2_FLOAT32:return LA(t);case xR.PACKED_2X2_FLOAT16:return zA(t);case xR.UNPACKED_FLOAT32:return DA(t);case xR.UNPACKED_FLOAT16:return _A(t);case xR.PACKED_4X1_UNSIGNED_BYTE:return OA(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,a);let s;if(r){const[t,n]=SR(e[0],e[1]);s=t*n}else{const[t,n]=wR(e[0],e[1]);s=t*n}const i=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,o);return s*i}function WF(e,t){if(e===vR.UPLOAD)return xR.PACKED_2X2_FLOAT32;if(e===vR.RENDER||null==e)return function(e){return dn().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?xR.PACKED_2X2_FLOAT32:xR.UNPACKED_FLOAT32:e?xR.PACKED_2X2_FLOAT16:xR.UNPACKED_FLOAT16}(t);if(e===vR.DOWNLOAD||e===vR.PIXELS)return xR.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function UF(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}class VF{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=xA(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const GF="if (isnan(x)) return x;",jF="return abs(x);";const HF=GF+"\n  return (x < 0.0) ? 0.0 : x;\n",KF=GF+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",qF="return x;";class XF{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=xA(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class YF{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=xA(this.outputShape.length);const t=e.length,n=LF("rc",t),a=pA(t),r=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),s=t<=1?"rc":"vec2(".concat(o.join(","),")");this.userCode="\n      void main() {\n        ".concat(a," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r,");\n\n        setOutput(getChannel(packedInput, ").concat(s,"));\n      }\n    ")}}const JF=Ip,$F={};const QF=dn().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class ZF extends Ct{nextDataId(){return ZF.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!dn().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof PA)t=e;else{const n=bR(dn().getNumber("WEBGL_VERSION"),e);t=new PA(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=bR(dn().getNumber("WEBGL_VERSION"));t=new PA(e),this.binaryCache=((n=dn().getNumber("WEBGL_VERSION"))in $F||($F[n]={}),$F[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new PF(this.gpgpu),this.numMBBeforeWarning=null==dn().global.screen?1024:dn().global.screen.height*dn().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new It(this,ai())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,r,o){const s=this.makeTensorInfo(t,n),i=this.texData.get(s.dataId);i.isPacked=!1,i.texture={texture:e,texShape:[a,r]},i.texShape=[a,r];const l=WR(t),c=new NA(l,!1,o),u=this.runWebGLProgram(c,[s],n,[[a,r]]);return u.shape=t,i.texture=null,this.disposeIntermediateTensorInfo(s),u.dataId}write(e,t,n){if((dn().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||dn().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:vR.UPLOAD,refCount:1}),a}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,a,r){if(dn().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:vR.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:r,slice:o,shape:s,isPacked:i}=t;if(null!=o){let t;t=i?new XF(s,qF):new VF(s,qF);const n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:a}],a),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;const l=null!=this.activeTimers;let c,u;if(l&&(c=ns()),"complex64"===a){u=Vd(this.readSync(r.real.dataId),this.readSync(r.imag.dataId))}else u=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=ns()-c),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:a,slice:r,dtype:o,complexTensorInfos:s,isPacked:i}=t;if(null!=r){let t;t=i?new XF(a,qF):new VF(a,qF);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:o}],o),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(dn().getBool("DEBUG")&&!dn().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===dn().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,u=null;if("complex64"!==o&&dn().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...kR(a))}if(this.pendingRead.set(e,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const e=await Promise.all([this.read(s.real.dataId),this.read(s.imag.dataId)]);c=Vd(e[0],e[1])}else if(null==u)c=this.getValuesFromTexture(e);else{const e=Ot(a);c=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=u){const e=this.gpgpu.gl;CR(e,(()=>e.deleteBuffer(u)))}const h=this.convertAndCacheOnCPU(e,c),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ai().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:a,shape:r,slice:o,dtype:s,isPacked:i,texture:l}=n;if("complex64"===s)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let n;n=i?new XF(r,qF):new VF(r,qF);const a=this.runWebGLProgram(n,[{dataId:e,shape:r,dtype:s}],s),o=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),o}if(null==l)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),u=ai().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:u},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>rs(e)));return Yi(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Yi(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!NR(n)){if(dn().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),r=Ot(t);if(dn().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...kR(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),o}const o=dn().getBool("WEBGL_PACK")&&!0===a,s=o?WR(t):t,i=o?new IA(s):new SA(s),l=this.runWebGLProgram(i,[{shape:s,dtype:n,dataId:e}],"float32"),c=this.texData.get(l.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(l),u}timerAvailable(){return dn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=ss(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),o=ss(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,a&&(this.programTimersStack=null);const s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(dn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(r);s.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),s.getExtraProfileInfo=()=>e.map(((e,t)=>({name:o[t],ms:e}))).map((e=>"".concat(e.name,": ").concat(e.ms))).join(", ")}else s.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,s})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return dn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ns(),endMs:null}}endTimer(e){return dn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=ns(),e)}async getQueryTime(e){if(dn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:r,isPacked:o,slice:s}=this.texData.get(e),i=s&&s.origDataId||e,l=this.dataRefCount.get(i);l>1?this.dataRefCount.set(i,l-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,r,o)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:QF;return dn().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Ot(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){Ro("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return JF(e.shape,t)}packedUnaryOp(e,t,n){const a=new XF(e.shape,t),r=this.compileAndRun(a,[e],n);return ai().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=yF(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(dn().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,jF,e.dtype);const t=new VF(e.shape,jF),n=this.compileAndRun(t,[e]);return ai().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&qt(n[0])){const r=n.map((e=>as(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){return ai().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new YF(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new zF(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[PR(e.shape),...BR(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},r=[PR(t),...BR(t)],o=new MF(r,n),s=[n],i=this.runWebGLProgram(o,[a],e.dtype,s,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:a,shape:r,dtype:o}=n;if(null!=t){Ft(Ot(r)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const s=WR(r);let i;i=a?new kA(s):new wA(s);const l=[null!=t?t:kR(s)];return{dtype:o,shape:r,dataId:this.runWebGLProgram(i,[{shape:s,dtype:o,dataId:e}],o,l,!0,t).dataId}}runWebGLProgram(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5?arguments[5]:void 0;const s=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(s.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===yR.DENSE){const t=null!=o?o:kR(e.outputShape);i.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===Ot(s.shape))return i.values=Gt(s.dtype,0),s;const l=[],c=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Ot(t.shape)<=dn().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!VR(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),l.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(s.dataId);const u={shape:s.shape,texData:i,isUniform:!1},h=function(e,t,n){let a="";t.concat(n).forEach((t=>{const r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const o=t.texData.texShape,{useSqueezeShape:s,uniformShape:i,keptDims:l}=fA(e.packedInputs,t.shape,o);let c="",u="",h="";if(1===i.length&&e.packedInputs){const e=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];c="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==i.length||e.packedInputs){if(i.length>2&&!e.packedInputs){const e=Qt(i);h="".concat(e[0]===o[1],"_").concat(e[e.length-1]===o[1])}}else u="".concat(i[0]>1,"_").concat(i[1]>1);const d=t.shape.length,p=2===i.length&&Lt(t.shape,o),f=1===Ot(t.shape),g=xl(t.shape,n.shape),m=!e.packedInputs&&d===n.shape.length&&Lt(o,n.texData.texShape),b=e.packedInputs||i.length>2?"":"".concat(o[0]>1,"_").concat(o[1]>1);a+="".concat(d,"_").concat(m,"_").concat(s?l:"","_").concat(i.length,"_").concat(f,"_").concat(g,"_").concat(p,"_").concat(c,"_").concat(u,"_").concat(h,"_").concat(b,"_").concat(r)}else{const e=t.isUniform?"uniform":t.texData.texShape;a+="".concat(t.shape,"_").concat(e,"_").concat(r)}}));const r=e.userCode;let o=e.constructor.name;return o+="_"+a+"_"+r+"".concat(dn().getNumber("WEBGL_VERSION")),o}(e,c,u),d=this.getAndSaveBinary(h,(()=>bA(this.gpgpu,e,c,u))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),dn().get("ENGINE_COMPILE_ONLY")||function(e,t,n,a,r){t.program.enableShapeUniforms||(vA(t.inShapeInfos,n),vA([t.outShapeInfo],[a]));const o=a.texData.texture,s=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(o.texture,s[0],s[1]):e.setOutputMatrixTexture(o.texture,s[0],s[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===dn().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const a=n[l],{uniform:r,offset:o,shape:s,texShape:i}=t.variablesLocations[l];if(s){const{uniformShape:n}=fA(t.program.packedInputs,a.shape,a.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(s,new Int32Array(n));break;case 2:e.gl.uniform2iv(s,new Int32Array(n));break;case 3:e.gl.uniform3iv(s,new Int32Array(n));break;case 4:e.gl.uniform4iv(s,new Int32Array(n))}}if(i&&e.gl.uniform2i(i,a.texData.texShape[0],a.texData.texShape[1]),null!=r)if(a.isUniform)if(Ot(a.shape)<2)e.gl.uniform1f(r,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(r,t)}else null!=a.texData.slice&&null!=o&&e.gl.uniform1i(o,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,r,l)}const i=t.outShapeLocation;if(i)switch(a.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(a.shape))}if(t.outShapeStridesLocation){const n=Qt(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let l=0;l<t.program.customUniforms.length;++l){const n=t.program.customUniforms[l],a=t.customUniformLocations[l],o=r[l];if("float"===n.type)e.gl.uniform1fv(a,o);else if("vec2"===n.type)e.gl.uniform2fv(a,o);else if("vec3"===n.type)e.gl.uniform3fv(a,o);else if("vec4"===n.type)e.gl.uniform4fv(a,o);else if("int"===n.type)e.gl.uniform1iv(a,o);else if("ivec2"===n.type)e.gl.uniform2iv(a,o);else if("ivec3"===n.type)e.gl.uniform3iv(a,o);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(a,o)}}e.executeProgram()}(this.gpgpu,d,c,u,a),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const g=dn().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const e=ns();e-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!dn().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===r){const e=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),e}return s}compileAndRun(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!dn().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=oi((()=>{if(!dn().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=dn().getBool("DEBUG");dn().set("DEBUG",!1);const t=this.abs(sl(1e-8)).dataSync()[0];if(dn().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:r,texture:o,usage:s,isPacked:i}=t;if(null!=o)return;const l=null!=this.activeTimers;let c;l&&(c=ns());let u=t.texShape;if(null==u&&(u=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=dn().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=dn().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(a===1/0&&dn().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n*=2,a*=2,e=e.map(((t,n)=>n>=e.length-2?Rt(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length){const t=Vt(e);e=t.newShape}let r=Ot(e),o=null;e.length<=1&&r<=n?o=[1,r]:2===e.length&&e[0]<=n&&e[1]<=n?o=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?o=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?o=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?o=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(o=[e[0],e[1]*e[2]*e[3]]);const s=null!=o&&Math.max(...o)>a&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||s)if(t){const t=PR(e);let n=2,a=2;e.length&&([n,a]=BR(e)),r=t*(n/2)*(a/2),o=Mt(r).map((e=>2*e))}else o=Mt(r);return o}(n,i),t.texShape=u),null!=r){const e=WR(n);let o,s=u[1],h=u[0];const d=r instanceof Uint8Array||r instanceof Uint8ClampedArray;!i&&d||([s,h]=SR(u[0],u[1])),o=i?new EA(e,d):new NA(e,d);const p=d?[h,s]:u,f=this.makeTensorInfo(p,a),g=this.texData.get(f.dataId);g.usage=d?vR.PIXELS:vR.UPLOAD,g.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),s,h,r);const m=[[h,s]],b=!0,y=this.runWebGLProgram(o,[f],a,m,b),v=this.texData.get(y.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,dn().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=ns()-c)}else{const e=this.acquireTexture(u,s,a,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*Kt(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await fd(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw RR(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:a,nanLoc:r,outShapeLocation:o,outShapeStridesLocation:s,outTexShapeLocation:i}=yA(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=r,e.outShapeLocation=o,e.outShapeStridesLocation=s,e.outTexShapeLocation=i}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:a,height:r,width:o,channels:s}=e,i=ai().backend;if(!i.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=i.writeTexture(a,t,n,r,o,s);return ai().makeTensorFromDataId(l,t,n,i)}}ZF.nextDataId=0;js()&&li("webgl",(()=>new ZF),2);const eD="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class tD{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=kl(t,n),this.enableShapeUniforms=xA(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const nD="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class aD{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=kl(t,n);const r=this.outputShape.length;this.enableShapeUniforms=xA(r);let o="";if(a)if(0===r||1===Ot(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=pA(r);if(o="\n          ".concat(e," coords = getOutputCoords();\n        "),1===r)this.enableShapeUniforms?o+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":o+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const e=LF("coords",r);this.enableShapeUniforms?o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= outShape[").concat(r," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= outShape[").concat(r," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= ").concat(this.outputShape[r-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= ").concat(this.outputShape[r-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(o,"\n\n        setOutput(result);\n      }\n    ")}}function rD(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const oD={kernelName:Da,backendName:"webgl",kernelFunc:rD};function sD(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,o=n.makeTensorInfo(a.shape,"complex64"),s=n.texData.get(o.dataId),i=rD({inputs:{x:a},backend:n}),l=rD({inputs:{x:r},backend:n});return s.complexTensorInfos={real:i,imag:l},o}const iD={kernelName:Gn,backendName:"webgl",kernelFunc:sD},lD="return (a < 0.) ? b * a : a;",cD="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const uD={kernelName:Pa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:o}=a,s=n.makeTensorInfo([],"float32",es(o,"float32")),i=dn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new aD(cD,r.shape,s.shape):new tD(lD,r.shape,s.shape),l=n.runWebGLProgram(i,[r,s],"float32");return n.disposeIntermediateTensorInfo(s),l}},hD="return (a < 0.) ? b * a : a;",dD="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const pD={kernelName:vr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,o=dn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new aD(dD,a.shape,r.shape):new tD(hD,a.shape,r.shape);return n.runWebGLProgram(o,[a,r],"float32")}},fD="if (isnan(x)) return x;";function gD(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:a,dtype:r}=e;return e=>{let{inputs:o,backend:s}=e;const{x:i}=o,l=s,c=r||i.dtype;if(l.shouldExecuteOnCPU([i])&&null!=a){const e=l.texData.get(i.dataId),t=a(e.values,c);return l.makeTensorInfo(i.shape,c,t)}let u;return u=dn().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new XF(i.shape,n):new VF(i.shape,t),l.runWebGLProgram(u,[i],c)}}function mD(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:s}=e;return e=>{let{inputs:i,backend:l}=e;const{a:c,b:u}=i,h=l;if(r&&"complex64"===c.dtype){const e=h.texData.get(c.dataId),n=h.texData.get(u.dataId),[a,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,a]=e,r={dataId:n.dataId,dtype:n.dtype,shape:c.shape},o={dataId:a.dataId,dtype:a.dtype,shape:u.shape},s=new tD(t,c.shape,u.shape);return h.runWebGLProgram(s,[r,o],Ts(n.dtype,a.dtype))})),o=sD({inputs:{real:a,imag:r},backend:h});return h.disposeIntermediateTensorInfo(a),h.disposeIntermediateTensorInfo(r),o}const d=s||Ts(c.dtype,u.dtype);if(("string"===c.dtype||"string"===u.dtype||h.shouldExecuteOnCPU([c,u]))&&null!=o){const e=h.texData.get(c.dataId).values,t=h.texData.get(u.dataId).values,n="string"===c.dtype?kp(e):e,a="string"===c.dtype?kp(t):t,[r,s]=o(c.shape,u.shape,n,a,d),i=h.makeTensorInfo(s,d);return h.texData.get(i.dataId).values=r,i}let p;return p=dn().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new aD(n,c.shape,u.shape,a):new tD(t,c.shape,u.shape),h.runWebGLProgram(p,[c,u],d)}}function bD(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":HF;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":KF;if("prelu"===e)return t?dD:hD;if("leakyrelu"===e)return t?cD:lD;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}class yD{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=xA(this.outputShape.length);const c=a?e[1]:e[2],u=Math.ceil(c/2),h=a?"i * 2, rc.y":"rc.y, i * 2",d=r?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",m="";s&&(g=i?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(s,"\n        }"):l?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(s,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(s,"\n        }"),m="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",v="rc.x";e[0]<t[0]?y="imod(rc.x, ".concat(e[0],")"):t[0]<e[0]&&(v="imod(rc.x, ".concat(t[0],")")),this.userCode="\n      ".concat(g,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(y,";\n        int batchB = ").concat(v,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(h,");\n          vec4 b = getMatrixB(batchB, ").concat(d,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(b,"\n\n        ").concat(m,"\n\n        setOutput(result);\n      }\n    ")}}const vD="return areal * breal - aimag * bimag;",xD="return areal * bimag + aimag * breal;";class wD{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=kl(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const kD="return a * b;";function SD(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,o=Ts(a.dtype,r.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),o=new wD(vD,a.shape,r.shape),s=new wD(xD,a.shape,r.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],l=n.runWebGLProgram(o,i,"float32"),c=n.runWebGLProgram(s,i,"float32"),u=sD({inputs:{real:l,imag:c},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),u}if(n.shouldExecuteOnCPU([a,r])){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),[s,i]=iF(a.shape,r.shape,e.values,t.values,o),l=n.makeTensorInfo(i,o);return n.texData.get(l.dataId).values=s,l}let s;return s=dn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new aD(kD,a.shape,r.shape):new tD(kD,a.shape,r.shape),n.runWebGLProgram(s,[a,r],o)}const ID={kernelName:lr,backendName:"webgl",kernelFunc:SD};function CD(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:o}=a,s=n,i=Ot(r.shape),l=Wt(o,i),c=Ot(l);Ft(i===c,(()=>"The new shape (".concat(l,") has ").concat(c," elements and the old ")+"shape (".concat(r.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."));const u=s.texData.get(r.dataId);return!u.isPacked||VR(r.shape,l)||null!==u.texture&&VR(u.shape,l)?(s.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype}):function(e,t,n){const a=[PR(e.shape),...BR(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},o=[PR(t),...BR(t)],s=new MF(o,a),i=[a],l=n.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(r,l,s)}const ND={kernelName:Tr,backendName:"webgl",kernelFunc:CD};class ED{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:o}=e;this.outputShape=[a,o];const s=4*Math.floor(n/4),i=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l="sumValue += dot(values * ".concat(zt(e)?e.toPrecision(2):e,", ones);")}let c="";r%n>0&&(c="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(c,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(s,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(s,";\n        if (").concat(1===i,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(l,"\n        } else if (").concat(2===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(l,"\n        } else if (").concat(3===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(l,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class TD{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:o}=e;this.outputShape=[a,o];let s="0.0",i="";"prod"===t?s="1.0":"min"===t?(s="1.0 / 1e-20",i="min"):"max"===t&&(s="-1.0 / 1e-20",i="max");let l="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const c=4*Math.floor(n/4),u=n%4;let h="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(i,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(i,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),d="vec4";"all"===t?(s="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(s="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";r%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(s,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(s,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(c,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h,"\n        }\n\n        int inIdx = inOffset + ").concat(c,";\n        if (").concat(1===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(2===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(3===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h,"\n        }\n        setOutput(").concat(l,");\n      }\n    ")}}function RD(e,t,n,a){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],a=Sd(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}(e.shape);let o=e;for(let s=0;s<r.length;s++){const{inSize:i,windowSize:l,outSize:c}=r[s];let u,h;u="mean"===n?0===s?new ED({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:c},i):new ED({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:c}):new TD({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:c},n),h=o,o=a.runWebGLProgram(u,[o],t),h.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(h)}return o}class AD{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.rank=n.length;const a=pA(this.rank),r=function(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}(t);this.userCode="\n    void main() {\n      ".concat(a," resRC = getOutputCoords();\n      setOutput(getA(").concat(r,"));\n    }\n    ")}}class FD{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let c=0;c<n.length;c++)n[c]=e[t[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const a=pA(this.rank),r=OF("rc",this.rank),o=new Array(this.rank);for(let c=0;c<t.length;c++)o[t[c]]=r[c];const s="vec2(".concat(o.slice(-2).join(),")"),i="++".concat(r[this.rank-1]," < ").concat(n[this.rank-1]),l="getChannel(getA(".concat(o.join(),"), ").concat(s,")");this.userCode="\n    void main() {\n      ".concat(a," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(l,";\n      if(").concat(i,") {\n        result[1] = ").concat(l,";\n      }\n      --").concat(r[this.rank-1],";\n      if(++").concat(r[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(l,";\n        if(").concat(i,") {\n          result[3] = ").concat(l,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function DD(e,t,n){const a=dn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new FD(e.shape,t):new AD(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function _D(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;return function(e,t,n,a){const r=t,o=e.shape.length,s=Ut(r,e.shape);let i=s;const l=fu(i,o),c=null!=l;let u=e;c&&(u=DD(e,l,a),i=mu(i.length,o)),pu("sum",i,o);const[h,d]=hu(u.shape,i);let p=h;n&&(p=du(h,s));const f=Ot(d),g=CD({inputs:{x:u},attrs:{shape:[Ot(e.shape)/f,f]},backend:a}),m=RD(g,Rs(e.dtype),"sum",a),b=CD({inputs:{x:m},attrs:{shape:p},backend:a});return a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(m),c&&a.disposeIntermediateTensorInfo(u),b}(r,o,s,n)}const OD={kernelName:Yr,backendName:"webgl",kernelFunc:_D};function LD(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:o}=a,s=n,i=r.shape.length,l=new Array(i);for(let u=0;u<l.length;u++)l[u]=r.shape[o[u]];let c;if(s.shouldExecuteOnCPU([r])){const e=s.texData.get(r.dataId).values,t=DF(e,r.shape,r.dtype,o,l);c=s.makeTensorInfo(l,r.dtype);s.texData.get(c.dataId).values=t}else c=DD(r,o,s);return c}const zD={kernelName:yo,backendName:"webgl",kernelFunc:LD};function MD(e){let{a:t,b:n,transposeA:a,transposeB:r,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:l=0,activation:c=null}=e;const u=t.shape.length,h=n.shape.length,d=a?t.shape[u-2]:t.shape[u-1],p=r?n.shape[h-1]:n.shape[h-2],f=a?t.shape[u-1]:t.shape[u-2],g=r?n.shape[h-2]:n.shape[h-1],m=t.shape.slice(0,-2),b=n.shape.slice(0,-2),y=Ot(m),v=Ot(b),x=kl(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,g]);Ft(d===p,(()=>"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const w=a?[y,d,f]:[y,f,d],k=r?[v,g,p]:[v,p,g],S=CD({inputs:{x:t},backend:o,attrs:{shape:w}}),I=CD({inputs:{x:n},backend:o,attrs:{shape:k}}),C=[S,I],N=Math.max(y,v),E=a?S.shape[1]:S.shape[2],T=null!=s,R=null!=i,A="leakyrelu"===c,F=null!=c?bD(c,!0):null;let D;if((1===f||1===g)&&E>1e3&&!1===(T||R||A||null!=F)){let e=S,t=I;a&&(e=LD({inputs:{x:S},backend:o,attrs:{perm:[0,2,1]}}),C.push(e)),r&&(t=LD({inputs:{x:I},backend:o,attrs:{perm:[0,2,1]}}),C.push(t));const n=1===g;let s=e;1!==g&&(s=CD({inputs:{x:e},backend:o,attrs:{shape:[N,E,1]}}),C.push(s));const i=1===g?2:1;let l=t;n&&(l=CD({inputs:{x:t},backend:o,attrs:{shape:[N,1,E]}}),C.push(l));const c=SD({inputs:{a:s,b:l},backend:o});D=_D({inputs:{x:c},backend:o,attrs:{axis:i,keepDims:!0}}),C.push(c)}else{const e=Ts(t.dtype,n.dtype),c=new yD(w,k,[N,f,g],a,r,T,F,R,A),u=[S,I];if(null!=s&&u.push(s),R&&u.push(i),A){const e=o.makeTensorInfo([],"float32",es(l,"float32"));u.push(e),C.push(e)}D=o.runWebGLProgram(c,u,e)}const _=CD({inputs:{x:D},backend:o,attrs:{shape:x}});C.push(D);for(const O of C)o.disposeIntermediateTensorInfo(O);return _}const PD={kernelName:No,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o,bias:s,preluActivationWeights:i}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=a;return MD({a:r,b:o,transposeA:l,transposeB:c,backend:n,bias:s,preluActivationWeights:i,leakyreluAlpha:h,activation:u})}},BD="return abs(x);";const WD={kernelName:bn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=yF(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let r;return r=dn().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new XF(a.shape,BD):new VF(a.shape,BD),n.runWebGLProgram(r,[a],a.dtype)}},UD=gD({opSnippet:GF+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),VD={kernelName:yn,backendName:"webgl",kernelFunc:UD},GD=gD({opSnippet:GF+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),jD={kernelName:vn,backendName:"webgl",kernelFunc:GD},HD="return a + b;",KD=mD({opSnippet:HD,packedOpSnippet:HD,supportsComplex:!0,cpuKernelImpl:BA}),qD={kernelName:xn,backendName:"webgl",kernelFunc:KD};class XD{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}class YD{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}const JD={kernelName:wn,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,r=n;if(1===r.length)return rD({inputs:{x:r[0]},backend:a});if(r.length>dn().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:a}),o=e({inputs:r.slice(t),backend:a});return e({inputs:[n,o],backend:a})}const o=r.map((e=>e.dtype)).reduce(((e,t)=>Ts(e,t))),s=r.map((e=>e.shape)),i=dn().getBool("WEBGL_PACK")?new YD(r[0].shape,s):new XD(r[0].shape,s);return a.runWebGLProgram(i,r,o)}};const $D={kernelName:kn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,l=Ut(o,r.shape);let c=l;const u=fu(c,i);let h=r;null!=u&&(h=LD({inputs:{x:r},backend:n,attrs:{perm:u}}),c=mu(c.length,i)),pu("all",c,i);const[d,p]=hu(h.shape,c),f=CD({inputs:{x:h},backend:n,attrs:{shape:[-1,Ot(p)]}}),g=RD(f,f.dtype,"all",n);let m;if(s){m=CD({inputs:{x:g},backend:n,attrs:{shape:du(d,l)}})}else m=CD({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),m}};const QD={kernelName:Sn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,l=Ut(o,r.shape);let c=l;const u=fu(c,i);let h=r;null!=u&&(h=LD({inputs:{x:r},backend:n,attrs:{perm:u}}),c=mu(c.length,i)),pu("any",c,i);const[d,p]=hu(h.shape,c),f=CD({inputs:{x:h},backend:n,attrs:{shape:[-1,Ot(p)]}}),g=RD(f,f.dtype,"any",n);let m;if(s){m=CD({inputs:{x:g},backend:n,attrs:{shape:du(d,l)}})}else m=CD({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),m}};class ZD{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:r,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,o];const s="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          int inIdx = ").concat(i,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(s," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class e_{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Ft(e.length>2,(()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2.")));const r=e[e.length-1],o=Math.ceil(r/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),a||this.variableNames.push("bestIndicesA");const s=this.outputShape,i=s.length,l=pA(i),c=LF("coords",i);let u,h;if(1===o){h=i+1;const e=pA(h);u="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(c.join(),", 0);\n        ++").concat(c[i-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(c.join(),", 0);\n        ++").concat(c[i-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(c.join(),", 0);\n        --").concat(c[i-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(c.join(),", 0);\n        --").concat(c[i-2],";")}else h=i,u="\n        ".concat(l," sourceLocR = coords;\n        ++").concat(c[i-1],";\n        ").concat(l," sourceLocG = coords;\n        ++").concat(c[i-2],";\n        ").concat(l," sourceLocA = coords;\n        --").concat(c[i-1],";\n        ").concat(l," sourceLocB = coords;\n        --").concat(c[i-2],";");const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((e=>"int "+e)),g=LF("sourceLocR",h-1).concat("inIdx.r"),m=LF("sourceLocG",h-1).concat("inIdx.g"),b=LF("sourceLocB",h-1).concat("inIdx.b"),y=LF("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=a?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),")));"),w="vec4(\n            getAChannel(".concat(g.join(),"),\n            hasNextCol ? getAChannel(").concat(m.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(b.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(y.join(),") : 0.)"),k=a?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(d.join(),"),\n                                          vec2(").concat(d.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(d.join(),"),\n                               vec2(").concat(d.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(l," coords = getOutputCoords();\n        bool hasNextCol = ").concat(c[i-1]," < ").concat(s[i-1]-1,";\n        bool hasNextRow = ").concat(c[i-2]," < ").concat(s[i-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(x,"\n          vec4 candidate = ").concat(w,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(v,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function t_(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=t.shape[0],o=t.shape[1];null!=a&&(r=a.shape[0],o=a.shape[1]);const s=Sd(o),i={windowSize:s,inSize:o,batchSize:r,outSize:Math.ceil(o/s)},l=new ZD(i,n,null==a),c=[t];null!=a&&c.push(a);const u=e.runWebGLProgram(l,c,"int32");if(1===u.shape[1])return u;const h=t_(e,t,n,u);return e.disposeIntermediateTensorInfo(u),h}function n_(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const r=null!=a?a.shape:t.shape,o=Sd(r[r.length-1]),s=new e_(r,o,n,null==a),i=null==a?[t]:[t,a],l=e.runWebGLProgram(s,i,"int32");if(l.shape.length===t.shape.length){const a=n_(e,t,n,l);return e.disposeIntermediateTensorInfo(l),a}return l}function a_(e,t,n,a){const r=[n];if(pu("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!dn().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],o=e.texData.get(t.dataId);let s=t;null!==o&&o.isPacked&&(s=e.unpackTensor(t),n.push(s));const[i,l]=hu(s.shape,r),c=Ot(l),u=CD({inputs:{x:s},backend:e,attrs:{shape:[-1,c]}});n.push(u);const h=t_(e,u,a);n.push(h);const d=CD({inputs:{x:h},backend:e,attrs:{shape:i}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),d}return n_(e,t,a)}const r_={kernelName:In,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;let s=Ut(o,r.shape);const i=fu(s,r.shape.length);let l=r;const c=[];null!=i&&(l=LD({inputs:{x:r},backend:n,attrs:{perm:i}}),c.push(l),s=mu(s.length,l.shape.length)),pu("argMax",[s[0]],l.shape.length);const u=a_(n,l,s[0],"max");return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};const o_={kernelName:Cn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;let s=Ut(o,r.shape);const i=fu(s,r.shape.length);let l=r;const c=[];null!=i&&(l=LD({inputs:{x:r},backend:n,attrs:{perm:i}}),c.push(l),s=mu(s.length,l.shape.length)),pu("argMin",[s[0]],l.shape.length);const u=a_(n,l,s[0],"min");return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},s_=gD({opSnippet:GF+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),i_={kernelName:Nn,backendName:"webgl",kernelFunc:s_},l_=gD({opSnippet:GF+"return log(x + sqrt(x * x + 1.0));"}),c_={kernelName:En,backendName:"webgl",kernelFunc:l_},u_=gD({opSnippet:GF+"\n  return atan(x);\n"}),h_={kernelName:Tn,backendName:"webgl",kernelFunc:u_},d_=mD({opSnippet:eD+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nD+"\n  return result;\n"}),p_={kernelName:An,backendName:"webgl",kernelFunc:d_},f_=gD({opSnippet:GF+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),g_={kernelName:Rn,backendName:"webgl",kernelFunc:f_};class m_{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideHeight,i=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,g="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),m="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d");let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(s,", ").concat(i,");\n        const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(l,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(c,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a?r?g:m:"wR * ".concat(h," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let y="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(y="avgValue / max(count, 1.0)");const v=4*Math.floor(o/4),x=o%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(s,", ").concat(i,");\n      const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n      const float initializationValue = ").concat(b,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(l,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(v,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(c,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              getValue(batch, xR, xC + 2 * ").concat(c,", d),\n              getValue(batch, xR, xC + 3 * ").concat(c,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(v,";\n          if (").concat(1===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              getValue(batch, xR, xC + 2 * ").concat(c,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(y,");\n      }\n    ")}}class b_{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,u=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,g=e.padInfo.front,m=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let v="0.0";if(y||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(s,", ").concat(i,", ").concat(l,");\n        const ivec3 pads = ivec3(").concat(g,", ").concat(m,", ").concat(b,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d,";\n              wD += ").concat(c,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(h,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a?r?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let x="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(o/4),k=o%4,S="\n      if (".concat(y,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(s,", ").concat(i,", ").concat(l,");\n      const ivec3 pads = ivec3(").concat(g,", ").concat(m,", ").concat(b,");\n      const float initializationValue = ").concat(v,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(v,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d,";\n            wD += ").concat(c,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h,", ch)\n              );\n\n              ").concat(S,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                initializationValue\n              );\n\n              ").concat(S,"\n            }\n          }\n        }\n        setOutput(").concat(x,");\n      }\n    ")}}const y_={kernelName:Fn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;YR(r,"avgPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:l}=a;Ft(vc(s,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const c=cc(r.shape,o,s,1,i,l);if(1===c.filterWidth&&1===c.filterHeight&&Lt(c.inShape,c.outShape))return rD({inputs:{x:r},backend:n});const u=new m_(c,"avg",!1);return n.runWebGLProgram(u,[r],"float32")}};const v_={kernelName:_n,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:l,dataFormat:c}=a,u=uc(r.shape,o,s,[1,1,1],i,l,c),h=new b_(u,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};class x_{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=i-1-e.padInfo.top,u=l-1-e.padInfo.left,h=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(c,", ").concat(u,");\n      const float avgMultiplier = float(").concat(h,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(i,";\n            wR += ").concat(o,") {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(l,";\n            wC+= ").concat(s,") {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class w_{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,u=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=h-1-e.padInfo.top,g=d-1-e.padInfo.left,m=1/(t*n*a);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(g,");\n      const float avgMultiplier = float(").concat(m,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(i,") {\n          float dyD = float(dyDCorner + wD) / ").concat(r,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(h,";\n              wR += ").concat(l,") {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(c,") {\n              float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const k_={kernelName:On,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o,{filterSize:i,strides:l,pad:c,dimRoundingMode:u}=a,h=uc(s.shape,i,l,[1,1,1],c,u),d=new w_(h);return n.runWebGLProgram(d,[r],s.dtype)}};const S_={kernelName:Dn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o;YR([r,o],"avgPoolGrad");const{filterSize:i,strides:l,pad:c}=a,u=cc(s.shape,i,l,1,c),h=new x_(u);return n.runWebGLProgram(h,[r],s.dtype)}};const I_={kernelName:Ln,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o}=t,{transposeA:s,transposeB:i}=a;return MD({a:r,b:o,transposeA:s,transposeB:i,backend:n})}};class C_{constructor(e,t,n,a,r,o){this.outputShape=[],this.variableNames=["x","mean","variance"],kl(e,t),kl(e,n);let s="0.0";null!=a&&(kl(e,a),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let i="1.0";null!=r&&(kl(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(s,";\n        float scale = ").concat(i,";\n        float inv = scale * inversesqrt(variance + float(").concat(o,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class N_{constructor(e,t,n,a,r,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],kl(e,t),kl(e,n);let s="vec4(0.0)";null!=a&&(kl(e,a),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=r&&(kl(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(s,";\n        vec4 scale = ").concat(i,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(o,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const E_={kernelName:Ea,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,mean:o,variance:s,offset:i,scale:l}=t;Ft(o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Ft(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Ft(null==l||o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:c}=a;null==c&&(c=.001);const u=[r,o,s];let h=null;null!=i&&(h=i.shape,u.push(i));let d=null;null!=l&&(d=l.shape,u.push(l));const p=dn().getBool("WEBGL_PACK_NORMALIZATION")?new N_(r.shape,o.shape,s.shape,h,d,c):new C_(r.shape,o.shape,s.shape,h,d,c);return n.runWebGLProgram(p,u,u[0].dtype)}};class T_{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=pA(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return R_.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let a;const r=e.map(((e,t)=>"sourceLoc.".concat(R_[t]," = start[").concat(t,"] + coords.").concat(R_[t],";")));a="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(r.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(a,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const R_=["x","y","z","w","u","v"];class A_{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=pA(this.rank),n=LF("coords",this.rank),a=LF("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":"vec2(".concat(a.slice(-2).join(),")"),o="getChannel(getSource(".concat(a.join(),"), ").concat(r,")"),s="\n      result.x = ".concat(o,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(a[this.rank-1],";\n        result.y = ").concat(o,";\n        --").concat(a[this.rank-1],";\n      }\n    "),i=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(a[this.rank-2],";\n        result.z = ").concat(o,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(a[this.rank-1],";\n          result.w = ").concat(o,";\n        }\n      }\n    "),l=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map(((e,t)=>"start[".concat(t,"]"))).join(),");"):e.map(((e,t)=>"".concat(a[t]," = ").concat(n[t]," + start[").concat(t,"];"))).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(l,"\n        vec4 result = vec4(0.);\n        ").concat(s,"\n        ").concat(i,"\n        setOutput(result);\n      }\n    ")}}function F_(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,size:s}=a,[i,l]=nc(r,o,s);if(Vl(r,i,l),0===Ot(l))return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=vF(e.values,i,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,t)}const{isPacked:c}=n.texData.get(r.dataId),u=ec(r.shape,i,l);if(c||!u){const e=dn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new A_(l):new T_(l),t=[i];return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,a){const r=a.texData.get(e.dataId),o=a.makeTensorInfo(n,e.dtype),s=a.texData.get(o.dataId);Object.assign(s,r),s.refCount=1,s.shape=n,s.dtype=e.dtype;let i=tc(t,Qt(e.shape));r.slice&&(i+=r.slice.flatOffset),s.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||e.dataId};const l=a.dataRefCount.get(s.slice.origDataId)||1;return a.dataRefCount.set(s.slice.origDataId,l+1),o}(r,i,l,n)}const D_={kernelName:Vr,backendName:"webgl",kernelFunc:F_},__={kernelName:zn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,crops:s}=a;Ft(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=o.reduce(((e,t)=>e*t)),l=Cd(r.shape,o,i),c=Nd(l.length,o.length),u=Ed(r.shape,o,i),h=Td(s,o.length),d=Rd(u,s,o.length),p=[],f=CD({inputs:{x:r},backend:n,attrs:{shape:l}}),g=LD({inputs:{x:f},backend:n,attrs:{perm:c}}),m=CD({inputs:{x:g},backend:n,attrs:{shape:u}}),b=F_({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(g),p.push(m),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}};const O_={kernelName:Mn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s}=a,i=n.readSync(r.dataId),l=n.readSync(o.dataId),c=WA(i,l,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,c)}};const L_={kernelName:Pn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,o=dn().getBool("WEBGL_PACK_BINARY_OPERATIONS"),s=dn().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,r])||1===s){const e=n.texData.get(a.dataId).values,t=n.texData.get(r.dataId).values,[o,s]=VA(a.shape,r.shape,e,t,a.dtype),i=n.makeTensorInfo(s,a.dtype);return n.texData.get(i.dataId).values=o,i}let i;return i=o?new aD("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,r.shape,!1):new tD("\n  return float(int(a.r) & int(b.r));\n",a.shape,r.shape),n.runWebGLProgram(i,[a,r],a.dtype)}};const z_={kernelName:Bn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,o=n.readSync(a.dataId),s=n.readSync(r.dataId),i=kl(Array.from(o),Array.from(s));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},M_=mD({opSnippet:"return float(a != b);",cpuKernelImpl:cF,dtype:"bool"}),P_={kernelName:ur,backendName:"webgl",kernelFunc:M_};function B_(e){const{inputs:t,backend:n}=e,{input:a}=t;return rD({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}const W_={kernelName:Cr,backendName:"webgl",kernelFunc:B_};const U_={kernelName:Wn,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:r}=t,{x:o}=n,{dtype:s}=r;if("complex64"===s){if("complex64"===o.dtype)return rD({inputs:{x:o},backend:a});const t=Ru(o.shape),n=e({inputs:{x:o},backend:a,attrs:{dtype:"float32"}}),r=sD({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),r}if("complex64"===o.dtype){const t=B_({inputs:{input:o},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:s}});return a.disposeIntermediateTensorInfo(t),n}if(!Ht(o.dtype,s)){const e=rD({inputs:{x:o},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:s}}if(a.shouldExecuteOnCPU([o])){const e=a.texData.get(o.dataId).values,[t,n,r]=GA(e,o.shape,o.dtype,s);return a.makeTensorInfo(t,n,r)}if("int32"===s)return function(e,t){const n=new VF(e.shape,"return float(int(x));"),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(o,a);if("bool"===s){const e=a.makeTensorInfo([],"bool",Gt("bool",1)),t=M_({inputs:{a:o,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(o.dtype," to ").concat(s))}},V_="return ceil(x);",G_=gD({opSnippet:V_,packedOpSnippet:V_,cpuKernelImpl:jA}),j_={kernelName:Un,backendName:"webgl",kernelFunc:G_};class H_{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class K_{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const q_={kernelName:Vn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:o,clipValueMax:s}=a;let i;i=dn().getBool("WEBGL_PACK_CLIP")?new K_(r.shape):new H_(r.shape);const l=[[o],[s]];return n.runWebGLProgram(i,[r],r.dtype,l)}};class X_{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Y_(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const J_={kernelName:jn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),o=new X_(a.shape),s=[Y_(a,r.complexTensorInfos.real),Y_(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(o,s,s[0].dtype)}};class $_{constructor(e){this.outputShape=[],this.outputShape=md(e,1),this.variableNames=e.map(((e,t)=>"T".concat(t)));const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let o=1;o<t.length;o++){const e=t[o-1];n.push("else if (yC < ".concat(t[o],") ")+"setOutput(getT".concat(o,"(yR, yC-").concat(e,"));"))}const a=t.length,r=t[t.length-1];n.push("else setOutput(getT".concat(a,"(yR, yC-").concat(r,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class Q_{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=md(e,t);const n=this.outputShape,a=n.length,r=pA(a),o=LF("coords",a),s=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map(((e,t)=>"T".concat(t)));const i=new Array(e.length-1);i[0]=e[0][t];for(let f=1;f<i.length;f++)i[f]=i[f-1]+e[f][t];const l=s[t],c=s.slice(-2),u=s.join();let h="if (".concat(l," < ").concat(i[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(c.join(),"));\n        }");for(let f=1;f<i.length;f++){const e=i[f-1];h+="\n        if (".concat(l," < ").concat(i[f],"  && ").concat(l," >= ").concat(i[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(Z_(s,l,e),"),\n            vec2(").concat(Z_(c,l,e),"));\n        }")}const d=i.length,p=i[i.length-1];h+="\n        return getChannel(\n          getT".concat(d,"(").concat(Z_(s,l,p),"),\n          vec2(").concat(Z_(c,l,p),"));"),this.userCode="\n      float getValue(".concat(s.map((e=>"int "+e)),") {\n        ").concat(h,"\n      }\n\n      void main() {\n        ").concat(r," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(o,"), 0., 0., 0.);\n\n        ").concat(o[a-1]," = ").concat(o[a-1]," + 1;\n        if (").concat(o[a-1]," < ").concat(n[a-1],") {\n          result.g = getValue(").concat(o,");\n        }\n\n        ").concat(o[a-2]," = ").concat(o[a-2]," + 1;\n        if (").concat(o[a-2]," < ").concat(n[a-2],") {\n          result.a = getValue(").concat(o,");\n        }\n\n        ").concat(o[a-1]," = ").concat(o[a-1]," - 1;\n        if (").concat(o[a-2]," < ").concat(n[a-2]," &&\n            ").concat(o[a-1]," < ").concat(n[a-1],") {\n          result.b = getValue(").concat(o,");\n        }\n        setOutput(result);\n      }\n    ")}}function Z_(e,t,n){const a=e.indexOf(t),r=e.map(((e,t)=>t===a?"".concat(e," - ").concat(n):e));return r.join()}function eO(e){const{inputs:t,backend:n}=e,{input:a}=t;return rD({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}const tO={kernelName:Oa,backendName:"webgl",kernelFunc:eO};function nO(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map((e=>B_({inputs:{input:e},backend:n}))),r=e.map((e=>eO({inputs:{input:e},backend:n}))),o=nO(a,t,n),s=nO(r,t,n),i=sD({inputs:{real:o,imag:s},backend:n});return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),r.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),i}let r=n.shouldExecuteOnCPU(e);if("string"===a&&(r=!0),r){const r=e.map((e=>{const a=Ot(e.shape.slice(t));return CD({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})})),o=r.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),s=md(r.map((e=>e.shape)),1),i=1===r[0].shape[0],l=HA(o,s,a,i),c=md(e.map((e=>e.shape)),t),u=n.makeTensorInfo(c,a,l);return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const o=e.filter((e=>Ot(e.shape)>0)),s=dn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const t=s?new VF(e[0].shape,qF):new XF(e[0].shape,qF);return n.runWebGLProgram(t,e,a)}const i=dn().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>i){const e=[];for(let r=0;r<o.length;r+=i){const a=o.slice(r,r+i);e.push(nO(a,t,n))}const a=nO(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return a}if(s){const e=new Q_(o.map((e=>e.shape)),t);return n.runWebGLProgram(e,o,a)}const{tensors2D:l,outShape:c}=function(e,t,n){const a=md(e.map((e=>e.shape)),t),r=e.map((e=>CD({inputs:{x:e},attrs:{shape:[-1,Ot(e.shape.slice(t))]},backend:n})));return{tensors2D:r,outShape:a}}(o,t,n),u=new $_(l.map((e=>e.shape))),h=n.runWebGLProgram(u,l,a);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));const d=CD({inputs:{x:h},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(h),d}function aO(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,o=Ut(r,t[0].shape)[0],s=t.map((e=>e.shape));gd(s,o);const i=md(t.map((e=>e.shape)),o);if(0===Ot(i))return n.makeTensorInfo(i,t[0].dtype,[]);const l=t.filter((e=>Ot(e.shape)>0));return 1===l.length?rD({inputs:{x:l[0]},backend:n}):nO(l,o,n)}const rO={kernelName:Hn,backendName:"webgl",kernelFunc:aO};class oO{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,s=e.padInfo.left,i=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,g="channelsLast"===e.dataFormat,m=g?1:2,b=g?2:3,y=g?3:1;let v="",x="";n&&(v=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(v,"\n\n      const ivec2 strides = ivec2(").concat(i,", ").concat(l,");\n      const ivec2 pads = ivec2(").concat(o,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(y,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(m,"], coords[").concat(b,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h,"; wR++) {\n          int xR = xRCorner + wR * ").concat(c,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(g,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(g,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(g,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(g,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(x,"\n        setOutput(result);\n      }\n    ")}}class sO{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,u=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(r,", ").concat(o,", ").concat(s,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(a,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(i,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h,"; wR++) {\n            int xR = xRCorner + wR * ").concat(l,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,"; wC++) {\n              int xC = xCCorner + wC * ").concat(c,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class iO{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=xA(this.outputShape.length);const o=e.padInfo.left,s=e.strideWidth,i=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,u=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+="\n           vec4 xTexelC".concat(2*g,";\n           int xTexelC").concat(2*g,"Ready;\n           vec4 xTexelC").concat(2*g+1,";\n           int xTexelC").concat(2*g+1,"Ready;\n           vec4 xC").concat(g,";");h+="\n     for (int r = 0; r < ".concat(l,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let g=0;g<c;g++)h+="\n           xTexelC".concat(2*g," = vec4(0.0);\n           xTexelC").concat(2*g,"Ready = 0;\n           xTexelC").concat(2*g+1," = vec4(0.0);\n           xTexelC").concat(2*g+1,"Ready = 0;\n           xC").concat(g," = vec4(0.0);");h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(u+1)/2;g++){const t=2*g;if(h+="\n           xC = xCCorner + ".concat(t*i,";\n           "),1===s){if(t<c&&(o%2===1?(h+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),h+=1===i&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):h+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<c)){const e=o%2===0?Rt(i):i;i%2===0&&o%2===1||i%2!==0&&o%2!==1?(h+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),h+=i>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):h+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<c&&(o%2===1?(h+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<c&&(h+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(h+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<c&&(h+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<c&&(h+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<c&&(h+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=a?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):r?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(d,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(h,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class lO{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=xA(this.outputShape.length);const{dataFormat:n}=t,a=$R(),r="channelsLast"===n,o=r?1:2,s=r?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {");let l="";for(let c=0;c<=1;c++)for(let e=0;e<=1;e++)l+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(c,";\n\n          ").concat(i,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(o,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(s,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(r,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*c+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*c+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(l,"\n\n        ").concat(a.output," = result;\n      }\n    ")}}function cO(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function uO(e){let{x:t,filter:n,convInfo:a,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:l=null}=e;const c=t.shape,u=r.texData.get(t.dataId),h=a.inChannels,d=c[0]*c[1]*c[2],p=a.outChannels,f="channelsLast"===a.dataFormat,g=!1;let m;const b=[];if(null!=s){const e=cO(s.shape,f);null!=e&&(s=CD({inputs:{x:s},backend:r,attrs:{shape:e}}),b.push(s))}if(null!=o){const e=cO(o.shape,f);null!=e&&(o=CD({inputs:{x:o},backend:r,attrs:{shape:e}}),b.push(o))}if(!((1===d||1===p)&&h>1e3)&&u.isPacked&&f&&null!=u.texture&&c[2]%2!==0&&Lt(u.shape.slice(-3),c.slice(-3))){const e=c[0]*c[1]*(c[2]+1),h={dataId:t.dataId,shape:[1,e,a.inChannels],dtype:t.dtype},d=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Ft(VR(u.shape,h.shape),(()=>"packed reshape ".concat(u.shape," to ").concat(h.shape," isn't free")));const p=CD({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}});b.push(p);const f=MD({a:h,b:p,backend:r,transposeA:false,transposeB:g,bias:o,activation:l,preluActivationWeights:s,leakyreluAlpha:i}),y=r.texData.get(f.dataId);Ft(y.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=d,y.shape=a.outShape,m=rD({inputs:{x:f},backend:r}),m.shape=a.outShape,b.push(f)}else{const e=a.outHeight*a.outWidth,c=CD({inputs:{x:t},backend:r,attrs:{shape:f?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),u=CD({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}}),h=MD({a:f?c:u,b:f?u:c,transposeA:!f,transposeB:g,backend:r,bias:o,activation:l,preluActivationWeights:s,leakyreluAlpha:i});m=CD({inputs:{x:h},backend:r,attrs:{shape:a.outShape}}),b.push(c),b.push(u),b.push(h)}for(const y of b)r.disposeIntermediateTensorInfo(y);return m}function hO(e){let{x:t,filter:n,convInfo:a,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:l=null}=e;const{filterWidth:c,filterHeight:u,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=a,g="channelsLast"===f,m=c*u*h,b=p*d,y=[a.batchSize,m,b],v=[];if(null!=s){const e=cO(s.shape,g);null!=e&&(s=CD({inputs:{x:s},backend:r,attrs:{shape:e}}),v.push(s))}if(null!=o){const e=cO(o.shape,g);null!=e&&(o=CD({inputs:{x:o},backend:r,attrs:{shape:e}}),v.push(o))}const x=CD({inputs:{x:n},backend:r,attrs:{shape:[1,m,Ot(n.shape)/m]}});v.push(x);const w=new lO(y,a),k=[t.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],S=r.runWebGLProgram(w,[t],"float32",k),I=CD({inputs:{x:S},backend:r,attrs:{shape:y}});v.push(S),v.push(I);const C=null!=o,N=null!=s,E="leakyrelu"===l,T=l?bD(l,!0):null,R=new yD(g?I.shape:x.shape,g?x.shape:I.shape,g?[a.batchSize,b,a.outChannels]:[a.batchSize,a.outChannels,b],!0,!1,C,T,N,E),A=g?[I,x]:[x,I];if(o&&A.push(o),N&&A.push(s),E){const e=r.makeTensorInfo([],"float32",es(i,"float32"));A.push(e),v.push(e)}const F=r.runWebGLProgram(R,A,"float32"),D=CD({inputs:{x:F},backend:r,attrs:{shape:a.outShape}});v.push(F);for(const _ of v)r.disposeIntermediateTensorInfo(_);return D}const dO={kernelName:Kn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dataFormat:l,dilations:c,dimRoundingMode:u}=a,h=wc(l),d=hc(r.shape,o.shape,s,c,i,u,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&dn().getBool("WEBGL_EXP_CONV")){const e=new iO(d),t=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(e,[r,o],"float32",t)}else if(dn().getBool("WEBGL_CONV_IM2COL"))p=hO({x:r,filter:o,convInfo:d,backend:n});else{const e=new oO(d);p=n.runWebGLProgram(e,[r,o],"float32")}else p=uO({x:r,filter:o,convInfo:d,backend:n});const f=CD({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class pO{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              ").concat(o?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class fO{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o="channelsLast"===e.dataFormat,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,l=o?1:2,c=o?2:3,u=o?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(l,"], coords[").concat(c,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(o,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class gO{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,o=e.padInfo.top,s=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(r,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(o,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(a," - ").concat(s,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class mO{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=t-1-e.padInfo.front,l=n-1-e.padInfo.top,c=a-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(i,", ").concat(l,", ").concat(c,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(r,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const bO={kernelName:qn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,dataFormat:l,dimRoundingMode:c,filterShape:u}=a,h=wc(l),d=hc(r.shape,u,s,1,i,c,!1,h),p=new pO(d);return n.runWebGLProgram(p,[r,o],"float32")}};class yO{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=xA(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(a,", ").concat(r,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(e.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(e.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const vO={kernelName:Xn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{inputShape:s,strides:i,pad:l,dataFormat:c,dimRoundingMode:u}=a,h=wc(c),d=hc(s,o.shape,i,1,l,u,!1,h);if(dn().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const e=[[d.strideHeight,d.strideWidth]],t=new yO(d);return n.runWebGLProgram(t,[r,o],"float32",e)}{const e=new fO(d);return n.runWebGLProgram(e,[r,o],"float32")}}};const xO={kernelName:Yn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:l}=a,c=dc(r.shape,o.shape,s,l,i),u=new sO(c);return n.runWebGLProgram(u,[r,o],"float32")}};const wO={kernelName:Jn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,filterShape:l}=a,c=dc(r.shape,l,s,1,i),u=new gO(c);return n.runWebGLProgram(u,[r,o],"float32")}};const kO={kernelName:$n,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{pad:s,strides:i,inputShape:l}=a,c=dc(l,o.shape,i,1,s),u=new mO(c);return n.runWebGLProgram(u,[r,o],"float32")}},SO=gD({opSnippet:fD+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(nD,"\n  return result;\n")}),IO={kernelName:Qn,backendName:"webgl",kernelFunc:SO},CO=gD({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),NO={kernelName:Zn,backendName:"webgl",kernelFunc:CO};class EO{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,s,i,l]=e,[c]=t,[u,h]=n;this.outputShape=[c,u,h,l];const d="bilinear"===a?1:0,[p,f]=["".concat(s-1,".0"),"".concat(i-1,".0")],[g,m,b]=u>1?["".concat((s-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[y,v,x]=h>1?["".concat((i-1)/(h-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(g,");\n      const float width_ratio = float(").concat(y,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(o,") {\n          return;\n        }\n\n        float height_scale = ").concat(m,";\n        float width_scale = ").concat(v,";\n\n        float in_y = ").concat(b,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n        float in_x = ").concat(x,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(d," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const TO={kernelName:na,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:o,boxInd:s}=t,{cropSize:i,method:l,extrapolationValue:c}=a,u=new EO(r.shape,o.shape,i,l,c);return n.runWebGLProgram(u,[r,o,s],"float32")}};var RO;!function(e){e.Prod="*",e.Sum="+"}(RO||(RO={}));class AO{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,o=this.op===RO.Prod?"1.0":"0.0",s=n?o:"getX(".concat(FO(r,"coords",this.op),")"),i=this.outputShape[this.outputShape.length-1];let l="",c="";n?(l=a?"end != ".concat(i-1):"end != 0",c=a?"end + 1":"end - 1"):(l=a?"end + pow2 < ".concat(i):"end >= pow2",c=a?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(pA(r)," coords = getOutputCoords();\n        int end = ").concat(DO(r,"coords",this.op),";\n        float val = ").concat(s,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(l,") {\n          int idx = ").concat(c,";\n          ").concat(DO(r,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(FO(r,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function FO(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function DO(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function _O(e,t,n,a,r,o){const s=t.shape.length,i=fu([a],s);let l=t;null!=i&&(l=LD({inputs:{x:t},backend:n,attrs:{perm:i}}));const c=mu(1,s)[0];if(c!==s-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));const u=l.shape[c];let h=rD({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const t=new AO(e,l.shape,!1,o),a=[[d]],r=h;h=n.runWebGLProgram(t,[h],h.dtype,a),n.disposeIntermediateTensorInfo(r)}if(r){const t=new AO(e,l.shape,r,o),a=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(a)}if(null!=i){const e=LD({inputs:{x:h},backend:n,attrs:{perm:gu(i)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),e}return h}const OO={kernelName:ea,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;return _O(RO.Prod,r,n,o,s,i)}};const LO={kernelName:ta,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;return _O(RO.Sum,r,n,o,s,i)}};const zO={kernelName:aa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s,binaryOutput:i}=a;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(o.dataId),a=WA(e,t,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,a)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(o),a=UA(e,t,s,i);return n.makeTensorInfo(a.shape,o.dtype,a.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};class MO{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const PO={kernelName:ra,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:o,dataFormat:s}=a,i=r.shape[0],l=("NHWC"===s?r.shape[1]:r.shape[2])*o,c=("NHWC"===s?r.shape[2]:r.shape[3])*o,u=("NHWC"===s?r.shape[3]:r.shape[1])/(o*o),h=new MO("NHWC"===s?[i,l,c,u]:[i,u,l,c],o,s);return n.runWebGLProgram(h,[r],r.dtype)}};class BO{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=xA(this.outputShape.length);const o=e.filterHeight,s=e.filterWidth,i=e.outChannels/e.inChannels;let l="",c="";n&&(l=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),c="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(l,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(i,";\n        int q = d2 - d1 * ").concat(i,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(o,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(s,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(c,"\n        setOutput(result);\n      }\n    ")}}class WO{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=xA(this.outputShape.length);const o=e.outChannels/e.inChannels,s=e.padInfo.left,i=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,h=u;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)d+="\n          vec4 xTexelC".concat(2*m,";\n          int xTexelC").concat(2*m,"Ready;\n          vec4 xTexelC").concat(2*m+1,";\n          int xTexelC").concat(2*m+1,"Ready;\n          vec4 xC").concat(m,";");d+="\n    for (int r = 0; r < ".concat(c,"; r++) {\n      ");for(let m=0;m<u;m++)d+="\n          xTexelC".concat(2*m," = vec4(0.0);\n          xTexelC").concat(2*m,"Ready = 0;\n          xTexelC").concat(2*m+1," = vec4(0.0);\n          xTexelC").concat(2*m+1,"Ready = 0;\n          xC").concat(m," = vec4(0.0);");d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let m=0;m<(h+1)/2;m++){const e=2*m;if(d+="\n          xC = xCCorner + ".concat(e*l,";\n          "),1===i){if(e<u&&(s%2===1?(d+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),d+=1===l&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):d+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<u)){const t=s%2===0?Rt(l):l;l%2===0&&s%2===1||l%2!==0&&s%2!==1?(d+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),d+=l>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):d+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<u&&(s%2===1?(d+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<u&&(d+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(d+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<u&&(d+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<u&&(d+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<u&&(d+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o,";\n        int q = d2 - d1 * ").concat(o,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(d,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(g,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const UO={kernelName:oa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:l,dimRoundingMode:c}=a;let u=l;null==u&&(u=[1,1]),Ft(vc(s,u),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(s," and dilations '").concat(u,"'")));const h=hc(r.shape,o.shape,s,u,i,c,!0);let d;d=dn().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new WO(h):new BO(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[r,o],"float32",p)}};class VO{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(o," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class GO{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=t-1-e.padInfo.top,s=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(i,"; dm++) {\n              int d2 = d1 * ").concat(i," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const jO={kernelName:sa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,dilations:i,pad:l,dimRoundingMode:c,filterShape:u}=a,h=hc(r.shape,u,s,i,l,c,!0),d=new VO(h);return n.runWebGLProgram(d,[r,o],"float32")}};const HO={kernelName:ia,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{strides:s,dilations:i,pad:l,dimRoundingMode:c,inputShape:u}=a,h=hc(u,o.shape,s,i,l,c,!0),d=new GO(h);return n.runWebGLProgram(d,[r,o],"float32")}};class KO{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const qO={kernelName:la,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],o=Ot(a.shape),s=CD({inputs:{x:a},backend:n,attrs:{shape:[o]}}),i=new KO(o),l=n.runWebGLProgram(i,[s],s.dtype),c=CD({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(l),c}};class XO{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:o,filterHeight:s,filterWidth:i,dilationHeight:l,dilationWidth:c}=e,{top:u,left:h}=a;this.userCode="\n      const ivec2 strides = ivec2(".concat(r,", ").concat(o,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(h,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(s,"; h++) {\n          int hIn = hBeg + h * ").concat(l,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(i,"; w++) {\n              int wIn = wBeg + w * ").concat(c,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const YO={kernelName:ca,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:l}=a,c=lc(r.shape,o.shape,s,i,"NHWC",l);let u;const h=new XO(c);u=n.runWebGLProgram(h,[r,o],"float32");const d=CD({inputs:{x:u},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(u),d}};const JO={kernelName:fa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,o=t,{allDims:s,summedDims:i,idDims:l}=ep(r,o.length);np(s.length,l,o);const{path:c,steps:u}=ap(i,l),h=u.length;let d=null,p=s.length;const f=[];for(let g=0;g<h;++g){for(const e of u[g]){const{permutationIndices:t,expandDims:a}=tp(p,l[e]);let r;rp(t)?r=o[e]:(r=LD({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(r));const s=r.shape.slice();for(let e=0;e<a.length;++e)s.splice(a[e],0,1);Lt(r.shape,s)||(r=CD({inputs:{x:r},backend:n,attrs:{shape:s}}),f.push(r)),null===d?d=r:(d=SD({inputs:{a:r,b:d},backend:n}),f.push(d))}g<h-1&&(c[g]>=0&&(d=_D({inputs:{x:d},backend:n,attrs:{axis:c[g]-(s.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}},$O=gD({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),QO={kernelName:ga,backendName:"webgl",kernelFunc:$O},ZO={kernelName:ma,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:r}=t,o=dn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new aD("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,r.shape):new tD("return (b >= 0.0) ? a : a * (b + 1.0);",a.shape,r.shape);return n.runWebGLProgram(o,[a,r],a.dtype)}},eL=mD({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:KA}),tL={kernelName:ya,backendName:"webgl",kernelFunc:eL},nL=gD({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(zd,";\n  float a1 = ").concat(Md,";\n  float a2 = ").concat(Pd,";\n  float a3 = ").concat(Bd,";\n  float a4 = ").concat(Wd,";\n  float a5 = ").concat(Ud,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),aL={kernelName:ba,backendName:"webgl",kernelFunc:nL},rL=gD({opSnippet:fD+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:qA,dtype:"float32"}),oL={kernelName:va,backendName:"webgl",kernelFunc:rL};function sL(e){const{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:o}=t,s=o.shape.length,i=o.shape.slice();let l=r;return r<0&&(Ft(-(s+1)<=r,(()=>"Axis must be in the interval [".concat(-(s+1),", ").concat(s,"]"))),l=s+r+1),i.splice(l,0,1),CD({inputs:{x:o},backend:a,attrs:{shape:i}})}const iL={kernelName:xa,backendName:"webgl",kernelFunc:sL},lL="return exp(x) - 1.0;",cL=gD({opSnippet:lL,packedOpSnippet:lL,cpuKernelImpl:XA}),uL={kernelName:wa,backendName:"webgl",kernelFunc:cL};class hL{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const r=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),o=n?"".concat(a,".0"):"1.0";let s;if("real"===e)s="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));s="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(r,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(s,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(o,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function dL(e,t,n){const a=n.texData.get(e.dataId),r=Ot(e.shape),o=e.shape[e.shape.length-1],s=CD({inputs:{x:e},backend:n,attrs:{shape:[r/o,o]}}),i=s.shape,l=new hL("real",i,t),c=new hL("imag",i,t),u=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i}],h=n.runWebGLProgram(l,u,"float32"),d=n.runWebGLProgram(c,u,"float32"),p=sD({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=CD({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(p),f}const pL={kernelName:ka,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return dL(a,!1,n)}};class fL{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function gL(e){const{backend:t,attrs:n}=e,{shape:a,value:r}=n;let{dtype:o}=n;if(o=o||Yt(r),"string"===o){const e=jt(o,Ot(a));return e.fill(r),t.makeTensorInfo(a,o,e)}{const e=new fL(a,r),n=[[r]];return t.runWebGLProgram(e,[],o,n)}}const mL={kernelName:Sa,backendName:"webgl",kernelFunc:gL};class bL{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const yL={kernelName:Ia,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:a}=t,r=n,o=new bL(a.shape);return r.runWebGLProgram(o,[a],a.dtype)}},vL="return floor(x);",xL=gD({opSnippet:vL,packedOpSnippet:vL,cpuKernelImpl:YA}),wL={kernelName:Ca,backendName:"webgl",kernelFunc:xL},kL=mD({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),SL={kernelName:Na,backendName:"webgl",kernelFunc:kL};class IL{constructor(e){this.variableNames=["A"];const t=$R(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(a,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class CL{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=$R(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(a,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}const NL={kernelName:Io,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:r}=t;const{numChannels:o}=a,s="undefined"!==typeof HTMLVideoElement&&r instanceof HTMLVideoElement,i="undefined"!==typeof HTMLImageElement&&r instanceof HTMLImageElement,[l,c]=s?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[c,l],h=[c,l,o];if(i||s){const e=dn().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=EL&&e===TL||(TL=e,EL=document.createElement("canvas").getContext("2d",{willReadFrequently:TL})),EL.canvas.width=l,EL.canvas.height=c,EL.drawImage(r,0,0,l,c),r=EL.canvas}const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=vR.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const p=dn().getBool("WEBGL_PACK")?new CL(h):new IL(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let EL,TL=dn().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const RL={kernelName:Eo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a,g=wc(u),m=hc(r.shape,o.shape,l,h,c,d,!1,g);let b;const y=[],v=null!=s,x=null!=i,w="leakyrelu"===p,k=()=>{const e=[r,o],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=CD({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return y.push(t),t}return e};if(v&&e.push(t(s,u)),x&&e.push(t(i,u)),w){const t=n.makeTensorInfo([],"float32",es(f,"float32"));e.push(t),y.push(t)}return e};if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&dn().getBool("WEBGL_EXP_CONV")){const e=p?bD(p,!0):null,t=new iO(m,v,e,x,w),a=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],r=k();b=n.runWebGLProgram(t,r,"float32",a)}else if(dn().getBool("WEBGL_CONV_IM2COL"))b=hO({x:r,filter:o,convInfo:m,backend:n,bias:s,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const e=p?bD(p,!1):null,t=new oO(m,v,e,x,w),a=k();b=n.runWebGLProgram(t,a,"float32")}else b=uO({x:r,filter:o,convInfo:m,backend:n,bias:s,activation:p,preluActivationWeights:i,leakyreluAlpha:f});const S=CD({inputs:{x:b},backend:n,attrs:{shape:m.outShape}});return y.push(b),y.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const AL={kernelName:To,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=a,f=[];let g=u;null==g&&(g=[1,1]),Ft(vc(l,g),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(l," and dilations '").concat(g,"'")));const m=hc(r.shape,o.shape,l,g,c,h,!0),b=dn().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,y=d?bD(d,b):null,v=[r,o],x=null!=s,w=null!=i,k="leakyrelu"===d;if(x&&v.push(s),w&&v.push(i),k){const e=n.makeTensorInfo([],"float32",es(p,"float32"));v.push(e),f.push(e)}let S;S=b?new WO(m,x,y,w,k):new BO(m,x,y,w,k);const I=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],C=n.runWebGLProgram(S,v,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),C}};class FL{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;const r=pA(n.length);let o="\n    int index;";for(let s=0;s<this.sliceDim;s++)o+="\n          index = round(getIndices(coords[0], ".concat(s,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[s],";\n          flattenIndex += index * ").concat(this.strides[s],";");this.userCode="\n         void main() {\n          ".concat(r," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(o,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const DL={kernelName:Ra,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,o=r.shape,s=o[o.length-1],i=Ot(a.shape),[l,c,u,h]=Ad(a,r),d=CD({inputs:{x:r},backend:n,attrs:{shape:[c,s]}}),p=CD({inputs:{x:a},backend:n,attrs:{shape:[Ot(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,r])||"string"===a.dtype){const e=n.readSync(r.dataId),t=n.bufferSync(a),o=JA(e,t,a.dtype,c,s,u,h,a.shape,i);return n.makeTensorInfo(l,a.dtype,o.values)}const f=new FL(s,h,[c,u],a.shape),g=n.runWebGLProgram(f,[p,d],p.dtype),m=CD({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),m}};class _L{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=pA(this.rank),a=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let a=0;a<e.length;a++)2===a?n.push("index"):n.push("".concat(t[a]));return n.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a,"));\n      }\n    ")}}function OL(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:o}=t,{axis:s,batchDims:i}=a,l=Ut(s,r.shape)[0];if(dn().get("DEBUG")){const e=n.readSync(o.dataId),t=r.shape[l];for(let n=0;n<e.length;++n){const a=e[n];Ft(a<=t-1&&a>=0,(()=>"GatherV2: the index value ".concat(a," is not in [0, ").concat(t-1,"]")))}}const c=wp(r,o,l,i),u=Ot(o.shape),h=[],d=CD({inputs:{x:r},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=CD({inputs:{x:o},backend:n,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(p);const f=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([r,o])||"string"===r.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),a=$A(t,e,f);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c.outputShape,a.dtype,a.values)}const g=new _L(d.shape,f),m=n.runWebGLProgram(g,[d,p],d.dtype);h.push(m);const b=CD({inputs:{x:m},backend:n,attrs:{shape:c.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}const LL={kernelName:Ta,backendName:"webgl",kernelFunc:OL},zL=mD({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:QA,dtype:"bool"}),ML={kernelName:Aa,backendName:"webgl",kernelFunc:zL},PL=mD({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:ZA}),BL={kernelName:Fa,backendName:"webgl",kernelFunc:PL};const WL={kernelName:_a,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return dL(a,!0,n)}},UL=gD({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),VL={kernelName:La,backendName:"webgl",kernelFunc:UL},GL=gD({opSnippet:"return float(isinf(x));",dtype:"bool"}),jL={kernelName:za,backendName:"webgl",kernelFunc:GL},HL=gD({opSnippet:"return float(isnan(x));",dtype:"bool"}),KL={kernelName:Ma,backendName:"webgl",kernelFunc:HL},qL=mD({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:eF,dtype:"bool"}),XL={kernelName:Ba,backendName:"webgl",kernelFunc:qL},YL=mD({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:tF,dtype:"bool"}),JL={kernelName:Wa,backendName:"webgl",kernelFunc:YL};const $L={kernelName:Ua,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:o}=n,s=nF(a,r,o);return t.makeTensorInfo([s.length],"float32",s)}},QL=gD({opSnippet:fD+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:aF}),ZL={kernelName:Va,backendName:"webgl",kernelFunc:QL},ez=gD({opSnippet:fD+"\n  return log(1.0 + x);\n"}),tz={kernelName:Ga,backendName:"webgl",kernelFunc:ez},nz=mD({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),az={kernelName:ja,backendName:"webgl",kernelFunc:nz},rz=gD({opSnippet:"return float(!(x >= 1.0));"}),oz={kernelName:Ha,backendName:"webgl",kernelFunc:rz},sz=mD({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),iz={kernelName:Ka,backendName:"webgl",kernelFunc:sz};class lz{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];const o=t,s=e[3]-1;let i;this.outputShape=e;const l="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(l,")"):1===r?"1.0/(".concat(l,")"):"exp(log(".concat(l,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(o,"; j <= ").concat(o,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(s,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(i,";\n        setOutput(val);\n      }\n    ")}}class cz{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,s=e[3]-1;let i;this.outputShape=e;const l="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(l,")"):1===r?"1.0/(".concat(l,")"):"exp(log(".concat(l,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(o,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(o,"; j <= ").concat(o,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(s,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(i,";\n        setOutput(result);\n      }\n    ")}}const uz={kernelName:qa,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:o,bias:s,alpha:i,beta:l}=a,c=dn().getBool("WEBGL_PACK_NORMALIZATION")?new cz(r.shape,o,s,i,l):new lz(r.shape,o,s,i,l);return n.runWebGLProgram(c,[r],r.dtype)}};class hz{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a,")\n                * float(").concat(r,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const dz={kernelName:Xa,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r,y:o,dy:s}=t,{depthRadius:i,bias:l,alpha:c,beta:u}=a,h=new hz(r.shape,i,l,c,u);return n.runWebGLProgram(h,[r,o,s],r.dtype)}};function pz(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:o,keepDims:s}=a,i=r.shape.length,l=Ut(o,r.shape);let c=l;const u=fu(c,i),h=null!=u,d=n.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(i);for(let n=0;n<t.length;n++)t[n]=r.shape[u[n]];const a=DF(e,r.shape,r.dtype,u,t);p=n.makeTensorInfo(t,r.dtype);n.texData.get(p.dataId).values=a}else p=DD(r,u,n);c=mu(c.length,i)}pu("max",c,i);const[f,g]=hu(p.shape,c);let m,b=f;if(s&&(b=du(f,l)),d){const e=n.texData.get(p.dataId).values,t=rF(e,Ot(g),b,r.dtype);m=n.makeTensorInfo(b,r.dtype);n.texData.get(m.dataId).values=t}else m=function(e,t,n,a){const r=Ot(t),o=CD({inputs:{x:e},attrs:{shape:[Ot(e.shape)/r,r]},backend:a}),s=RD(o,e.dtype,"max",a),i=CD({inputs:{x:s},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}(p,g,b,n);return h&&n.disposeIntermediateTensorInfo(p),m}const fz={kernelName:Ya,backendName:"webgl",kernelFunc:pz},gz=mD({opSnippet:eD+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nD+"\n  return result;\n",cpuKernelImpl:oF}),mz={kernelName:Ja,backendName:"webgl",kernelFunc:gz};const bz={kernelName:$a,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;YR(r,"maxPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:l}=a;Ft(vc(s,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const c=cc(r.shape,o,s,1,i,l);if(1===c.filterWidth&&1===c.filterHeight&&Lt(c.inShape,c.outShape))return rD({inputs:{x:r},backend:n});const u=new m_(c,"max",!1);return n.runWebGLProgram(u,[r],r.dtype)}};const yz={kernelName:Za,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dataFormat:l,dimRoundingMode:c}=a,u=uc(r.shape,o,s,[1,1,1],i,c,l),h=new b_(u,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};class vz{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,o=e.effectiveFilterWidth,s=r-1-e.padInfo.top,i=o-1-e.padInfo.left,l=r*o-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(r,";\n          wR += ").concat(a,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(l," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(o," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class xz{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterDepth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=i-1-e.padInfo.front,h=l-1-e.padInfo.top,d=c-1-e.padInfo.left,p=i*l*c-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(h,", ").concat(d,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(i,";\n           wD += ").concat(r,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(l,";\n              wR += ").concat(o,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(c,";\n                wC += ").concat(s,") {\n              float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(l," * ").concat(c," +\n                  wR * ").concat(c," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const wz={kernelName:er,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o,{filterSize:i,strides:l,pad:c,dimRoundingMode:u}=a,h=uc(s.shape,i,l,[1,1,1],c,u),d=new b_(h,"max",!0),p=n.runWebGLProgram(d,[s],s.dtype),f=new xz(h),g=n.runWebGLProgram(f,[r,p],s.dtype);return n.disposeIntermediateTensorInfo(p),g}};const kz={kernelName:Qa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o,output:s}=t,i=o;YR([o,s],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=a,d=cc(i.shape,l,c,1,u,h),p=new m_(d,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),g=new vz(d),m=n.runWebGLProgram(g,[r,f],i.dtype);return n.disposeIntermediateTensorInfo(f),m}};const Sz={kernelName:tr,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:l}=n,c=a;Ft(4===r.shape.length,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(r.shape.length,".")));const u=[1,1];Ft(vc(s,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(u,"'")));const h=cc(r.shape,o,s,u,i),[d,p]=function(e,t,n,a){let r=new m_(n,"max",!1);const o=a.runWebGLProgram(r,[e],"float32");return r=new m_(n,"max",!0,!0,t),[o,a.runWebGLProgram(r,[e],"float32")]}(r,l,h,c);return[d,p]}};const Iz={kernelName:nr,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{keepDims:o,axis:s}=n,i=a,l=r.shape.length,c=Ut(s,r.shape);let u=c;const h=fu(u,l),d=null!=h,p=i.shouldExecuteOnCPU([r]),f=[];let g=r;if(d){if(p){const e=i.texData.get(g.dataId).values,t=new Array(l);for(let a=0;a<t.length;a++)t[a]=r.shape[h[a]];const n=DF(e,r.shape,r.dtype,h,t);g=i.makeTensorInfo(t,r.dtype);i.texData.get(g.dataId).values=n}else g=DD(r,h,i);f.push(g),u=mu(u.length,l)}pu("sum",u,l);const[m,b]=hu(g.shape,u);let y=m;o&&(y=du(m,c));const v=function(e,t,n,a){const r=Ot(t),o=CD({inputs:{x:e},attrs:{shape:[Ot(e.shape)/r,r]},backend:a}),s=RD(o,"float32","mean",a),i=CD({inputs:{x:s},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}(g,b,y,i);for(const x of f)i.disposeIntermediateTensorInfo(x);return v}};const Cz={kernelName:ar,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,l=Ut(o,r.shape);let c=l;const u=fu(c,i);let h=r;null!=u&&(h=LD({inputs:{x:r},backend:n,attrs:{perm:u}}),c=mu(c.length,r.shape.length)),pu("min",c,i);const[d,p]=hu(h.shape,c),f=CD({inputs:{x:h},backend:n,attrs:{shape:[-1,Ot(p)]}}),g=RD(f,f.dtype,"min",n);let m;if(s){m=CD({inputs:{x:g},backend:n,attrs:{shape:du(d,l)}})}else m=CD({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),m}},Nz=mD({opSnippet:eD+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nD+"\n  return result;\n",cpuKernelImpl:sF}),Ez={kernelName:rr,backendName:"webgl",kernelFunc:Nz};class Tz{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=pA(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),l="reflect"===n?0:1;this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(o,");\n      ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(l,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(l,";\n          }\n        }\n        ").concat(r," coords = outC - start;\n        setOutput(getX(").concat(i,"));\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(s,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(l,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(l,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class Rz{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=pA(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=LF("rc",a),l=LF("source",a),c="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(l.slice(-2).join(),")"),h="reflect"===n?0:1;let d="";if(1===a){const e="\n        ".concat(r," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h,";\n        }\n        source -= start;\n      ");d="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(c,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        }\n      ")}else{const e="\n        ".concat(r," source = rc;\n        ").concat(r," lt = ").concat(r,"(lessThan(source, start));\n        ").concat(r," gte = ").concat(r,"(greaterThanEqual(source, end));\n        ").concat(r," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h,") +\n                gte * ((end - 1) * 2 - source + ").concat(h,");\n        source -= start;\n      ");d="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(c,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(i[a-2]," += 1;\n        if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n          ").concat(i[a-1]," += 1;\n          if(").concat(c,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(o,");\n      const ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d,"\n        setOutput(result);\n      }\n    ")}}const Az={kernelName:or,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r}=t,{paddings:o,mode:s}=a,i=dn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rz(r.shape,o,s):new Tz(r.shape,o,s);return n.runWebGLProgram(i,[r],r.dtype)}},Fz=mD({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+nD+"\n  return result;\n"}),Dz={kernelName:sr,backendName:"webgl",kernelFunc:Fz};class _z{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}const Oz=mD({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Lz={kernelName:pa,backendName:"webgl",kernelFunc:Oz},zz="return a - b;",Mz=mD({opSnippet:zz,packedOpSnippet:zz,supportsComplex:!0,cpuKernelImpl:RF}),Pz={kernelName:ho,backendName:"webgl",kernelFunc:Mz};function Bz(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:o}=a,s=Ut([o],r.shape),i=pz({inputs:{x:r},backend:n,attrs:{reductionIndices:s,keepDims:!1}}),l=du(i.shape,s),c=CD({inputs:{x:i},backend:n,attrs:{shape:l}}),u=Mz({inputs:{a:r,b:c},backend:n}),h=rL({inputs:{x:u},backend:n}),d=_D({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:!1}}),p=CD({inputs:{x:d},backend:n,attrs:{shape:l}}),f=Oz({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const Wz={kernelName:Qr,backendName:"webgl",kernelFunc:Bz};const Uz={kernelName:ir,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:o,seed:s,normalized:i}=a,l=i?r:Bz({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new _z(c,u,o),d=[[s]],p=n.runWebGLProgram(h,[l],"int32",d);return i||n.disposeIntermediateTensorInfo(l),p}},Vz=GF+"\n  return -x;\n";const Gz={kernelName:cr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,r]=lF(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}let r;return r=dn().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new XF(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new VF(a.shape,Vz),n.runWebGLProgram(r,[a],a.dtype)}},jz=zh;const Hz={kernelName:hr,backendName:"webgl",kernelFunc:function(e){Ro("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:l}=a,c=n.readSync(r.dataId),u=n.readSync(o.dataId),{selectedIndices:h}=jz(c,u,s,i,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},Kz=Mh;const qz={kernelName:dr,backendName:"webgl",kernelFunc:function(e){Ro("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:c}=a,u=n.readSync(r.dataId),h=n.readSync(o.dataId),{selectedIndices:d,validOutputs:p}=Kz(u,h,s,i,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},Xz=Ph;const Yz={kernelName:pr,backendName:"webgl",kernelFunc:function(e){Ro("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:l,softNmsSigma:c}=a,u=n.readSync(r.dataId),h=n.readSync(o.dataId),d=s,p=i,f=l,g=c,{selectedIndices:m,selectedScores:b}=Xz(u,h,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class Jz{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const $z={kernelName:gr,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:o,depth:s,onValue:i,offValue:l}=a,c=Ot(r.shape),u=new Jz(c,s,i,l),h=CD({inputs:{x:r},backend:n,attrs:{shape:[c]}}),d=n.runWebGLProgram(u,[h],o);n.disposeIntermediateTensorInfo(h);const p=CD({inputs:{x:d},backend:n,attrs:{shape:[...r.shape,s]}});return n.disposeIntermediateTensorInfo(d),p}};function Qz(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=B_({inputs:{input:a},backend:n}),t=Qz({inputs:{x:e},backend:n}),r=eO({inputs:{input:a},backend:n}),o=Qz({inputs:{x:r},backend:n}),s=sD({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),s}return gL({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const Zz={kernelName:ko,backendName:"webgl",kernelFunc:Qz};const eM={kernelName:fr,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=B_({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),o=eO({inputs:{input:r},backend:a}),s=Qz({inputs:{x:o},backend:a}),i=sD({inputs:{real:n,imag:s},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}return gL({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};const tM={kernelName:mr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return sL({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const o=t[0].shape,s=t[0].dtype;t.forEach((e=>{Dt(o,e.shape,"All tensors passed to stack must have matching shapes"),Ft(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=t.map((e=>{const t=sL({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),c=aO({inputs:l,backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};class nM{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=pA(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(o,");\n      ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r," coords = outC - start;\n          setOutput(getX(").concat(i,"));\n        }\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(s,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class aM{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=pA(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=LF("rc",a),l=LF("source",a),c="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(l.slice(-2).join(),")"),h=["".concat(r," rc = outputLoc;"),"".concat(i[a-1]," += 1;\n       if(").concat(c,") {\n      "),1===a?"":"}\n       rc = outputLoc;\n       ".concat(i[a-2]," += 1;\n       if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {"),1===a?"":"  ".concat(i[a-1]," += 1;\n         if(").concat(c,") {")],d=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,g=1===a?2:4;f<g;f++)p+="\n        ".concat(h[f],"\n        if (").concat(d,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(r," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        }\n      ");p+=1===a?"} ":"}}",this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(o,");\n      const ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const rM=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,constantValue:s}=a;if(0===Ot(r.shape)){const e=o.map(((e,t)=>e[0]+r.shape[t]+e[1]));return gL({backend:n,attrs:{shape:e,value:s,dtype:r.dtype}})}const i=dn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new aM(r.shape,o,s):new nM(r.shape,o,s),l=[[s]];return n.runWebGLProgram(i,[r],r.dtype,l)},oM={kernelName:br,backendName:"webgl",kernelFunc:rM},sM=mD({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+nD+"\n  return result;\n"}),iM={kernelName:yr,backendName:"webgl",kernelFunc:sM};const lM={kernelName:xr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,l=[],c=Ut(o,r.shape);let u=c;const h=fu(u,i);let d,p=r;if(null!=h&&(p=LD({inputs:{x:r},backend:n,attrs:{perm:h}}),u=mu(u.length,i),l.push(p)),pu("prod",u,i),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:a,outDtype:r}=uF(p.shape,p.dtype,e,u);d=n.makeTensorInfo(a,r,t)}else{const[e,t]=hu(p.shape,u),a=Ot(t),o=CD({inputs:{x:p},backend:n,attrs:{shape:[-1,a]}}),s=RD(o,Rs(r.dtype),"prod",n);d=CD({inputs:{x:s},backend:n,attrs:{shape:e}}),l.push(o),l.push(s)}if(s){l.push(d);const e=du(d.shape,c);d=CD({inputs:{x:d},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}};const cM={kernelName:wr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:o,indices:s}=t,{outputRaggedRank:i}=a,l=r.map((e=>n.readSync(e.dataId))),c=r.map((e=>e.shape)),u=n.readSync(o.dataId),h=n.readSync(s.dataId),[d,p,f]=hF(l,c,u,o.shape,o.dtype,h,s.shape,i),g=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),m=n.makeTensorInfo(f,o.dtype,p);return g.concat([m])}};const uM={kernelName:kr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:o}=t,s=n.readSync(a.dataId),i=n.readSync(r.dataId),l=n.readSync(o.dataId),[c,u]=dF(s,a.shape,a.dtype,i,r.shape,l,o.shape);return[n.makeTensorInfo([c.length],"int32",c),n.makeTensorInfo([u.length],a.dtype,u)]}};const hM={kernelName:Sr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:o,defaultValue:s,rowPartitionTensors:i}=t,{rowPartitionTypes:l}=a,c=n.readSync(r.dataId),u=n.readSync(o.dataId),h=n.readSync(s.dataId),d=i.map((e=>n.readSync(e.dataId))),p=i.map((e=>e.shape)),[f,g]=pF(c,r.shape,u,o.shape,o.dtype,h,s.shape,d,p,l);return n.makeTensorInfo(f,o.dtype,g)}},dM=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:o,dtype:s}=n,i=fF(a,r,o,s);return t.makeTensorInfo([i.length],s,i)},pM={kernelName:Ir,backendName:"webgl",kernelFunc:dM},fM=gD({opSnippet:"return 1.0 / x;"}),gM={kernelName:Nr,backendName:"webgl",kernelFunc:fM},mM=gD({opSnippet:GF+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),bM={kernelName:Er,backendName:"webgl",kernelFunc:mM},yM=gD({opSnippet:GF+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),vM={kernelName:_r,backendName:"webgl",kernelFunc:yM};class xM{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[o,s,i,l]=e;this.outputShape=[o,t,n,l];const c=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let h;h=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(s,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class wM{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,l]=e;this.outputShape=[o,t,n,l];const c=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let h;h=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],",\n          ").concat(c[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(s,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const kM={kernelName:Fr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a,[l,c]=i,u=dn().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new wM(r.shape,l,c,o,s):new xM(r.shape,l,c,o,s);return n.runWebGLProgram(u,[r],"float32")}};class SM{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,o,s]=e,i=[n&&o>1?a-1:a,n&&s>1?r-1:r],l=[n&&o>1?o-1:o,n&&s>1?s-1:s],c=i[0]/l[0],u=i[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(c,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(s,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(a-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(r-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const IM={kernelName:Dr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a,i=new SM(o.shape,r.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}};class CM{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[o,s,i,l]=e;this.outputShape=[o,t,n,l];const c=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0";let d;d=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(s,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class NM{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,l]=e;this.outputShape=[o,t,n,l];const c=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0";let d;d=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],",\n          ").concat(c[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(s,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const EM={kernelName:Rr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a,[l,c]=i,u=dn().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new NM(r.shape,l,c,o,s):new CM(r.shape,l,c,o,s);return n.runWebGLProgram(u,[r],r.dtype)}};class TM{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,o,s]=e,i=[n&&o>1?a-1:a,n&&s>1?r-1:r],l=[n&&o>1?o-1:o,n&&s>1?s-1:s],c=i[0]/l[0],u=i[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(c,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(s,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(i[0],") *\n                (float(dyR) / float(").concat(l[0],"));\n\n            float sourceFracCol =\n                float(").concat(i[1],") *\n                  (float(dyC) / float(").concat(l[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const RM={kernelName:Ar,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a,i=new TM(o.shape,r.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}};class AM{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));const a=e.map(((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(a))).join(","),r=pA(n);this.userCode="\n      void main() {\n        ".concat(r," coords = getOutputCoords();\n        setOutput(getX(").concat(a,"));\n      }\n    ")}}class FM{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;const a=LF("rc",n),r="".concat(a[n-1]," + 1 < ").concat(this.outputShape[n-1]),o="".concat(a[n-2]," + 1 < ").concat(this.outputShape[n-2]),s=pA(n);function i(n){const a=e.map(((a,r)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(a[n]," - 1"):"".concat(a[n])}(r,n))),r=a.join(","),o=a.slice(-2).join(",");return"getChannel(getX(".concat(r,"), vec2(").concat(o,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(r,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(s," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return i(e)}(a.slice()),";\n          if(").concat(r,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(a.slice()),";\n          }\n          if(").concat(o,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            if(").concat(r,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const DM={kernelName:Or,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:o}=a,s=r.shape.length,i=Ut(o,r.shape);if(0===s)return rD({inputs:{x:r},backend:n});const l=dn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new FM(r.shape,i):new AM(r.shape,i);return n.runWebGLProgram(l,[r],r.dtype)}};class _M{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],a=e[2];this.outputShape=e;let r="";r="number"===typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r,"\n          if(coordX >= 0 && coordX < ").concat(a," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const OM={kernelName:Co,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:o,fillValue:s,center:i}=n,l=a,c=new _M(r.shape,s),[u,h]=Id(i,r.shape[1],r.shape[2]),d=[[u,h,Math.sin(o),Math.cos(o)]];return l.runWebGLProgram(c,[r],r.dtype,d)}},LM=gD({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),zM={kernelName:Lr,backendName:"webgl",kernelFunc:LM},MM=gD({opSnippet:"return inversesqrt(x);",cpuKernelImpl:gF}),PM={kernelName:zr,backendName:"webgl",kernelFunc:MM};class BM{constructor(e,t,n,a,r,o){let s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const i=pA(r.length),l=pA(o.length);let c="";1===n?c="i":2===n&&(c="i, j");const u="getIndices(".concat(c,")");let h="";1===a?h="i":2===a&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";s&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),g=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(l," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(g,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(d,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class WM{constructor(e,t,n,a,r,o){let s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const i=pA(r.length),l=pA(o.length);let c="";1===n?c="i":2===n&&(c="i, j");const u="getIndices(".concat(c,")");let h="";1===a?h="i":2===a&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";s&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),g=t>1?"strides[j]":"strides",m=t>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(l," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(e,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(t,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(g,";\n              if (j + 1 < ").concat(t,") {\n                flattenedIndex += index.yw * ").concat(m,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(d,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const UM={kernelName:Mr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:o}=t,{shape:s}=a,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=_d(0,r,s),d=[h/c,c];if(0===h)return n.makeTensorInfo(s,r.dtype);const p=CD({inputs:{x:r},backend:n,attrs:{shape:[l,i]}}),f=CD({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let m;m=dn().getBool("WEBGL_PACK")?new WM(l,i,p.shape.length,f.shape.length,u,d):new BM(l,i,p.shape.length,f.shape.length,u,d);const b=n.runWebGLProgram(m,[f,p,g],f.dtype),y=CD({inputs:{x:b},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),y}};class VM{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const r="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),o=2===dn().getNumber("WEBGL_VERSION")?"while (left < right) {":r,s="left"===a?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(o,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(s," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const GM={kernelName:Br,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:o}=t,{side:s}=a,i=new VM(r.shape[0],r.shape[1],o.shape[1],s),l=[[r.shape[1]]];return n.runWebGLProgram(i,[r,o],"int32",l)}};class jM{constructor(e,t,n){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)r="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],s=[];for(let a=0;a<t.length;a++)s.push("".concat(n[a])),a<e&&o.push("".concat(n[a]));a=o.join(),r=s.join()}const o=pA(n);this.userCode="\n      void main() {\n        ".concat(o," resRC = getOutputCoords();\n        float cVal = getC(").concat(a,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r,"));\n        } else {\n          setOutput(getB(").concat(r,"));\n        }\n      }\n    ")}}const HM={kernelName:Wr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:o}=t,s=new jM(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(s,[a,r,o],Ts(r.dtype,o.dtype))}},KM=gD({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(Od,";\n  float scale = ").concat(Ld,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),qM={kernelName:Ur,backendName:"webgl",kernelFunc:KM},XM=gD({opSnippet:fD+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:bF}),YM={kernelName:Kr,backendName:"webgl",kernelFunc:XM},JM=gD({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),$M={kernelName:Hr,backendName:"webgl",kernelFunc:JM},QM=gD({opSnippet:fD+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(nD,"\n  return result;\n")}),ZM={kernelName:Gr,backendName:"webgl",kernelFunc:QM},eP=gD({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),tP={kernelName:jr,backendName:"webgl",kernelFunc:eP},nP=gD({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),aP={kernelName:qr,backendName:"webgl",kernelFunc:nP},rP={kernelName:Jr,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,paddings:s}=a;Ft(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=o.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...s);for(let b=1+o.length;b<r.shape.length;++b)l.push([0,0]);const c=[],u=rM({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),h=Cd(u.shape,o,i,!1),d=Nd(h.length,o.length,!1),p=Ed(u.shape,o,i,!1),f=CD({inputs:{x:u},backend:n,attrs:{shape:h}}),g=LD({inputs:{x:f},backend:n,attrs:{perm:d}}),m=CD({inputs:{x:g},backend:n,attrs:{shape:p}});return c.push(u),c.push(f),c.push(g),c.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}};const oP={kernelName:Zr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:o,defaultValue:s}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(o.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(r.shape));if(0!==s.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(s.shape));const i=n.readSync(a.dataId),l=n.readSync(r.dataId),c=n.readSync(o.dataId),u=n.readSync(s.dataId)[0],[h,d,p,f,g]=xF(i,a.shape,a.dtype,l,r.dtype,c,u);return[n.makeTensorInfo(d,a.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([g.length],a.dtype,new Int32Array(g))]}};const sP={kernelName:eo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:o}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(r.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const s=Array.from(n.readSync(r.dataId)),i=n.readSync(a.dataId),l=Array.from(n.readSync(o.dataId)),[c,u,h]=wF(i,a.shape,a.dtype,s,l);return[n.makeTensorInfo(u,a.dtype,c),n.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}};const iP={kernelName:to,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(o.shape));const s=n.readSync(a.dataId),i=n.readSync(r.dataId),l=n.readSync(o.dataId),[c,u]=kF(s,a.shape,a.dtype,i,l,!0);return n.makeTensorInfo(u,a.dtype,c)}};const lP={kernelName:no,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(o.shape));const s=n.readSync(a.dataId),i=n.readSync(r.dataId),l=n.readSync(o.dataId),[c,u]=kF(s,a.shape,a.dtype,i,l);return n.makeTensorInfo(u,a.dtype,c)}};const cP={kernelName:ao,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:o,defaultValue:s}=t,{outputShape:i}=a,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=_d(0,r,i),p=!1;if("string"===o.dtype){const e=n.bufferSync(r),t=n.bufferSync(o),a=rs(n.readSync(s.dataId)[0]),f=mF(e,t,i,d,u,c,l,h,a,p);return n.makeTensorInfo(i,f.dtype,f.values)}const f=new BM(c,l,r.shape.length,o.shape.length,h,[d,1],p),g=n.runWebGLProgram(f,[o,r,s],o.dtype),m=CD({inputs:{x:g},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(g),m}};const uP={kernelName:$r,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:o,axis:s}=a,i=Ut(s,r.shape)[0],l=sp(r,o,i),c=r.shape.length,u=new Array(c).fill(0),h=r.shape.slice();return l.map((e=>{const t=[...h];t[i]=e;const a=F_({inputs:{x:r},backend:n,attrs:{begin:u,size:t}});return u[i]+=e,a}))}},hP="return sqrt(x);",dP=gD({opSnippet:hP,packedOpSnippet:hP,cpuKernelImpl:SF}),pP={kernelName:Xr,backendName:"webgl",kernelFunc:dP},fP={kernelName:oo,backendName:"webgl",kernelFunc:gD({opSnippet:"return x * x;"})},gP="return (a - b) * (a - b);",mP=mD({opSnippet:gP,packedOpSnippet:gP}),bP={kernelName:ro,backendName:"webgl",kernelFunc:mP};const yP={kernelName:so,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");const o=kp(n.readSync(r.dataId)),s=IF(o,"string",a);return n.makeTensorInfo(r.shape,"string",s)}};const vP={kernelName:So,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,o=GF+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),s=new VF(r.shape,o);return a.runWebGLProgram(s,[r],r.dtype)}};class xP{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,r=pA(n.length),o=pA(n.length);let s="";if(1===a)s="coords * strides + begin";else{let e=0;s=n.map(((t,a)=>(e++,1===n.length?"coords * strides[".concat(a,"] + begin[").concat(a,"]"):"coords[".concat(e-1,"] * strides[").concat(a,"] + begin[").concat(a,"]")))).join(",")}this.userCode="\n      ".concat(r," begin = ").concat(r,"(").concat(e,");\n      ").concat(r," strides = ").concat(r,"(").concat(t,");\n\n      void main() {\n        ").concat(o," coords = getOutputCoords();\n        setOutput(getX(").concat(s,"));\n      }\n    ")}}const wP={kernelName:io,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,end:s,strides:i,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:y,end:v,strides:x}=ac(r.shape,o,s,i,l,c,u,h,d);let w;if(g)w=CD({inputs:{x:r},backend:n,attrs:{shape:f}});else if(m||b){Ft(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=jl(y,v,x),t=F_({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});w=CD({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=Yi(r.shape,r.dtype,e),a=CF(p,t,x,y);w=n.makeTensorInfo(f,r.dtype,a.values)}else{const e=new xP(y,x,p);w=n.runWebGLProgram(e,[r],r.dtype)}}const k=CD({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const kP={kernelName:lo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:s,rightPad:i,padWidth:l,preserveShortSequences:c}=a,{data:u,dataSplits:h}=t,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,g]=NF(d,p,r,o,s,i,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",g)]}};const SP={kernelName:co,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:s}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==s.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(s.shape));const i=n.readSync(o.dataId),l=n.readSync(s.dataId)[0],[c,u,h]=EF(i,l,r),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};const IP={kernelName:uo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const s=n.readSync(o.dataId),i=TF(s,r);return n.makeTensorInfo(o.shape,"int32",i)}},CP=gD({opSnippet:"return tan(x);"}),NP={kernelName:po,backendName:"webgl",kernelFunc:CP},EP=gD({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),TP={kernelName:fo,backendName:"webgl",kernelFunc:EP};const RP={kernelName:Pr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:o,updates:s}=t,{}=a,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=_d(0,o,r.shape),d=[h/c,c];if(0===h)return n.makeTensorInfo(r.shape,o.dtype);const p=CD({inputs:{x:o},backend:n,attrs:{shape:[l,i]}}),f=CD({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),g=CD({inputs:{x:r},backend:n,attrs:{shape:d}}),m=new BM(l,i,p.shape.length,f.shape.length,u,d,!1,!0),b=n.runWebGLProgram(m,[f,p,g],g.dtype),y=CD({inputs:{x:b},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),y}};class AP{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.rank=n.length;const a=pA(this.rank),r=function(e){const t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push("imod(".concat(n[r],", ").concat(e[r],")"));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(a," resRC = getOutputCoords();\n        setOutput(getA(").concat(r,"));\n      }\n    ")}}function FP(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:o}=a;if("string"===r.dtype||r.shape.length>5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map((e=>rs(e))):e,a=Yi(r.shape,r.dtype,t),s=AF(a,o);return n.makeTensorInfo(s.shape,s.dtype,s.values)}const s=new AP(r.shape,o);return n.runWebGLProgram(s,[r],r.dtype)}const DP={kernelName:go,backendName:"webgl",kernelFunc:FP};class _P{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class OP{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function LP(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function zP(e){let t=1;for(;t<e;)t*=2;return t}const MP={kernelName:mo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:o,sorted:s}=a,i=dn().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=dn().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,u=c[c.length-1];if(n.shouldExecuteOnCPU([r])||u<i||o>l){const e=n.readSync(r.dataId),[t,a]=FF(e,c,r.dtype,o,s);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===o)return c[c.length-1]=0,[n.makeTensorInfo(c,r.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(1===u)return[r,gL({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const h=n.texData.get(r.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(r):r,f=Ot(c)/u,g=CD({inputs:{x:p},attrs:{shape:[f,u]},backend:n});d&&LP(n,p);const m=zP(o),b=zP(u);let y=null;const v=()=>null===y?[g,g]:[g,y],x=(e,t,a)=>{const r=v(),o=new _P(a),s=[[u],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],i=y;y=n.runWebGLProgram(o,r,"int32",s),LP(n,i)};for(let C=1;C<m;C*=2){const e=2*C;for(let t=C;t>=1;t/=2)x(e,t,[f,b])}for(let C=b;C>m;C/=2){const e=v(),t=new OP([f,C/2]),a=[[u],[null===y?1:0],[m]],r=y;y=n.runWebGLProgram(t,e,"int32",a),LP(n,r);const o=m/2,s=2*o;for(let n=o;n>=1;n/=2)x(s,n,y.shape)}let w=y;y=F_({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,o]}}),LP(n,w);let k=OL({inputs:{x:g,indices:y},backend:n,attrs:{axis:1,batchDims:1}});LP(n,g);const S=c.slice(0,-1);S.push(o),w=y,y=CD({inputs:{x:y},attrs:{shape:S},backend:n}),LP(n,w);const I=k;return k=CD({inputs:{x:k},attrs:{shape:S},backend:n}),LP(n,I),[k,y]}};class PP{constructor(e,t,n,a,r,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const s="nearest"===n?1:2;let i;switch(a){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(i," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(s," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const BP={kernelName:bo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:o}=t,{interpolation:s,fillMode:i,fillValue:l,outputShape:c}=a,[u,h,d,p]=r.shape,[f,g]=null!=c?c:[h,d],m=new PP(h,d,s,i,l,[u,f,g,p]);return n.runWebGLProgram(m,[r,o],"float32")}};const WP={kernelName:vo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:o}=t;YR(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const s=a.readSync(o.dataId),{outputValues:i,outputShape:l,indices:c}=_F(s,r,o.shape,o.dtype);return[a.makeTensorInfo(l,o.dtype,i),a.makeTensorInfo([c.length],"int32",c)]}};const UP={kernelName:xo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:o}=a;o<0&&(o+=r.shape.length);const s=r,i=s.shape.length,l=r.shape[o],c=new Array(i-1);let u=0;for(let g=0;g<i;g++)g!==o&&(c[u++]=s.shape[g]);const h=[],d=new Array(i).fill(0),p=s.shape.slice();p[o]=1;const f=new Array(l);for(let g=0;g<f.length;g++){d[o]=g;const e=F_({inputs:{x:s},backend:n,attrs:{begin:d,size:p}}),t=CD({inputs:{x:e},backend:n,attrs:{shape:c}});f[g]=t,h.push(e)}return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class VP{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,r=e.inSize,o=e.numSegments,s=o*Math.ceil(r/n);this.outputShape=[a,s];const i=4*Math.floor(n/4),l=n%4,c="\n        sumValue += dot(values, segFilter);\n    ";let u="";r%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      "));let h="";r%n>0&&(h="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(o,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(o,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===l,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(c,"\n        } else if (").concat(2===l,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(c,"\n        } else if (").concat(3===l,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(c,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const GP={kernelName:wo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:o}=t,{numSegments:s}=a,i=r.shape.length,l=[];let c=0;const u=fu([c],i);let h=r;null!=u&&(h=LD({inputs:{x:r},backend:n,attrs:{perm:u}}),l.push(h),c=mu(1,i)[0]);const d=xp(h.shape,c,s),p=Ot([h.shape[c]]),f=CD({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const g=Rs(r.dtype),m=(e,t,a,r,o)=>{const s=e.shape[0],i=e.shape[1],c=vp(i,o),u=new VP({windowSize:c,inSize:i,batchSize:s,numSegments:o},t),h=n.compileAndRun(u,[e,a],r);if(l.push(h),h.shape[1]===o)return h;const d=dM({backend:n,attrs:{start:0,stop:o,step:1,dtype:"float32"}}),p=FP({inputs:{x:d},backend:n,attrs:{reps:[i/c]}});l.push(d),l.push(p);return m(h,t,p,r,o)},b=CD({inputs:{x:m(f,"unsortedSegmentSum",o,g,s)},backend:n,attrs:{shape:d}});let y=b;if(null!=u){l.push(b);const e=gu(u);y=LD({inputs:{x:y},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},jP=[PD,WD,VD,jD,qD,JD,$D,QD,r_,o_,i_,c_,h_,p_,g_,y_,v_,k_,S_,I_,E_,__,O_,L_,z_,U_,j_,q_,iD,J_,rO,dO,bO,vO,xO,wO,kO,IO,NO,TO,OO,LO,zO,PO,UO,jO,HO,qO,YO,JO,QO,ZO,tL,aL,oL,iL,uL,pL,mL,yL,wL,SL,NL,RL,AL,DL,LL,ML,BL,oD,WL,tO,VL,jL,KL,uD,XL,JL,$L,ZL,tz,az,oz,iz,uz,dz,fz,mz,bz,yz,wz,kz,Sz,Iz,Cz,Ez,Az,Dz,Uz,ID,Gz,Hz,qz,Yz,P_,$z,eM,tM,oM,iM,pD,lM,cM,uM,hM,pM,W_,Lz,gM,bM,vM,ND,kM,IM,EM,RM,DM,OM,zM,PM,UM,GM,HM,qM,YM,$M,ZM,tP,D_,Wz,aP,rP,oP,sP,iP,lP,cP,uP,pP,fP,bP,yP,vP,wP,kP,SP,IP,Pz,OD,NP,TP,RP,DP,MP,BP,zD,WP,UP,GP,Zz];for(const n of jP)zo(n);n(844);Object.create(null);const HP={},KP=(e,t,n,a)=>{JP(n)&&HP[n]||(JP(n)&&(HP[n]=new Date),((e,t,n,a)=>{var r,o,s;const i=[n,d({code:t},a||{})];if(null!==e&&void 0!==e&&null!==(r=e.services)&&void 0!==r&&null!==(r=r.logger)&&void 0!==r&&r.forward)return e.services.logger.forward(i,"warn","react-i18next::",!0);JP(i[0])&&(i[0]="react-i18next:: ".concat(i[0])),null!==e&&void 0!==e&&null!==(o=e.services)&&void 0!==o&&null!==(o=o.logger)&&void 0!==o&&o.warn?e.services.logger.warn(...i):null!==(s=console)&&void 0!==s&&s.warn&&console.warn(...i)})(e,t,n,a))},qP=(e,t)=>()=>{if(e.isInitialized)t();else{const n=()=>{setTimeout((()=>{e.off("initialized",n)}),0),t()};e.on("initialized",n)}},XP=(e,t,n)=>{e.loadNamespaces(t,qP(e,n))},YP=(e,t,n,a)=>{if(JP(n)&&(n=[n]),e.options.preload&&e.options.preload.indexOf(t)>-1)return XP(e,n,a);n.forEach((t=>{e.options.ns.indexOf(t)<0&&e.options.ns.push(t)})),e.loadLanguages(t,qP(e,a))},JP=e=>"string"===typeof e,$P=/&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,QP={"&amp;":"&","&#38;":"&","&lt;":"<","&#60;":"<","&gt;":">","&#62;":">","&apos;":"'","&#39;":"'","&quot;":'"',"&#34;":'"',"&nbsp;":" ","&#160;":" ","&copy;":"\xa9","&#169;":"\xa9","&reg;":"\xae","&#174;":"\xae","&hellip;":"\u2026","&#8230;":"\u2026","&#x2F;":"/","&#47;":"/"},ZP=e=>QP[e];let eB={bindI18n:"languageChanged",bindI18nStore:"",transEmptyNodeValue:"",transSupportBasicHtmlNodes:!0,transWrapTextNodes:"",transKeepBasicHtmlNodesFor:["br","strong","i","p"],useSuspense:!0,unescape:e=>e.replace($P,ZP)};let tB;const nB={type:"3rdParty",init(e){!function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};eB=d(d({},eB),e)}(e.options.react),(e=>{tB=e})(e)}},aB=(0,o.createContext)();class rB{constructor(){this.usedNamespaces={}}addUsedNamespaces(e){e.forEach((e=>{this.usedNamespaces[e]||(this.usedNamespaces[e]=!0)}))}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const oB=(e,t,n,a)=>e.getFixedT(t,n,a),sB=function(e){var t,n,a,r;let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{i18n:i}=s,{i18n:l,defaultNS:c}=(0,o.useContext)(aB)||{},u=i||l||tB;if(u&&!u.reportNamespaces&&(u.reportNamespaces=new rB),!u){KP(u,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const e=(e,t)=>{return JP(t)?t:"object"===typeof(n=t)&&null!==n&&JP(t.defaultValue)?t.defaultValue:Array.isArray(e)?e[e.length-1]:e;var n},t=[e,{},!1];return t.t=e,t.i18n={},t.ready=!1,t}null!==(t=u.options.react)&&void 0!==t&&t.wait&&KP(u,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const h=d(d(d({},eB),u.options.react),s),{useSuspense:p,keyPrefix:f}=h;let g=e||c||(null===(n=u.options)||void 0===n?void 0:n.defaultNS);g=JP(g)?[g]:g||["translation"],null===(a=(r=u.reportNamespaces).addUsedNamespaces)||void 0===a||a.call(r,g);const m=(u.isInitialized||u.initializedStoreOnce)&&g.every((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return t.languages&&t.languages.length?t.hasLoadedNamespace(e,{lng:n.lng,precheck:(t,a)=>{var r;if((null===(r=n.bindI18n)||void 0===r?void 0:r.indexOf("languageChanging"))>-1&&t.services.backendConnector.backend&&t.isLanguageChangingTo&&!a(t.isLanguageChangingTo,e))return!1}}):(KP(t,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:t.languages}),!0)}(e,u,h))),b=((e,t,n,a)=>(0,o.useCallback)(oB(e,t,n,a),[e,t,n,a]))(u,s.lng||null,"fallback"===h.nsMode?g:g[0],f),y=()=>b,v=()=>oB(u,s.lng||null,"fallback"===h.nsMode?g:g[0],f),[x,w]=(0,o.useState)(y);let k=g.join();s.lng&&(k="".concat(s.lng).concat(k));const S=((e,t)=>{const n=(0,o.useRef)();return(0,o.useEffect)((()=>{n.current=t?n.current:e}),[e,t]),n.current})(k),I=(0,o.useRef)(!0);(0,o.useEffect)((()=>{const{bindI18n:e,bindI18nStore:t}=h;I.current=!0,m||p||(s.lng?YP(u,s.lng,g,(()=>{I.current&&w(v)})):XP(u,g,(()=>{I.current&&w(v)}))),m&&S&&S!==k&&I.current&&w(v);const n=()=>{I.current&&w(v)};return e&&(null===u||void 0===u||u.on(e,n)),t&&(null===u||void 0===u||u.store.on(t,n)),()=>{I.current=!1,u&&(null===e||void 0===e||e.split(" ").forEach((e=>u.off(e,n)))),t&&u&&t.split(" ").forEach((e=>u.store.off(e,n)))}}),[u,k]),(0,o.useEffect)((()=>{I.current&&m&&w(y)}),[u,f,m]);const C=[x,u,m];if(C.t=x,C.i18n=u,C.ready=m,m)return C;if(!m&&!p)return C;throw new Promise((e=>{s.lng?YP(u,s.lng,g,(()=>e())):XP(u,g,(()=>e()))}))};var iB=n(579);const lB=()=>{const{t:e}=sB(),[t,n]=(0,o.useState)(null),[a,r]=(0,o.useState)(null),[s,i]=(0,o.useState)(null),[l,c]=(0,o.useState)(!1),[u,h]=(0,o.useState)(null),[d,p]=(0,o.useState)(!0),[f,g]=(0,o.useState)(null),[m,b]=(0,o.useState)(!1),[y,v]=(0,o.useState)(null),[x,w]=(0,o.useState)(!1),[k,S]=(0,o.useState)(null),I=(0,o.useRef)(),C=(0,o.useRef)(),N="AIzaSyDmQ5XQV7gwYyYHwRwdSsjdDef_V-gM9Ug",E="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=".concat(N);(0,o.useEffect)((()=>((async()=>{try{h(null),p(!0);const e=await zv("/model/model.json");n(e)}catch(CW){console.error("Error loading model:",CW),h(e("classifier.errors.hospitalError"))}finally{p(!1)}})(),()=>{t&&t.dispose()})),[e]);const T=e=>{let t=e.replace(/\*\*/g,"").replace(/\*/g,"").replace(/\n/g,"<br />");return t=t.replace(/(\d+\.)\s/g,"<br /><br />$1 "),{__html:t}},R=async()=>{try{var t,n,a,r,o;w(!0),h(null);const s=await new Promise(((t,n)=>{navigator.geolocation?navigator.geolocation.getCurrentPosition((e=>{t({lat:e.coords.latitude,lng:e.coords.longitude})}),(e=>{n(e)})):n(new Error(e("classifier.errors.locationUnavailable")))})),i=await(async(e,t)=>{try{const n=await fetch("https://maps.googleapis.com/maps/api/geocode/json?latlng=".concat(e,",").concat(t,"&key=").concat(N)),a=await n.json();return a.results&&a.results.length>0?a.results[0].formatted_address:"".concat(e.toFixed(4),", ").concat(t.toFixed(4))}catch(CW){return console.error("Reverse geocoding error:",CW),"".concat(e.toFixed(4),", ").concat(t.toFixed(4))}})(s.lat,s.lng);S(i);const l="The response must be in this language ".concat(e("TheCurrentLanguage")," and include only a list of 3 pulmonologists clinics or hospitals near ").concat(i," (coordinates: ").concat(s.lat,", ").concat(s.lng,") that specialize in lung cancer conditions.  \n      For each, include:\n      1. Name of the facility\n      2. Approximate distance from the location\n      3. Phone number\n      4. Brief note about services offered\n      \n      Format the response as a clear list with each item separated by 2 line breaks. Use clean, consistent formatting.    \n      "),c=await fetch(E,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({contents:[{parts:[{text:l}]}]})});if(!c.ok)throw new Error("API request failed with status ".concat(c.status));const u=(null===(t=(await c.json()).candidates)||void 0===t||null===(n=t[0])||void 0===n||null===(a=n.content)||void 0===a||null===(r=a.parts)||void 0===r||null===(o=r[0])||void 0===o?void 0:o.text)||e("classifier.errors.hospitalError");v(u)}catch(CW){console.error("Error finding hospitals:",CW);let n=e("classifier.errors.hospitalError");1===CW.code?n=e("classifier.errors.locationDenied"):2===CW.code?n=e("classifier.errors.locationUnavailable"):3===CW.code&&(n=e("classifier.errors.locationTimeout")),h(n)}finally{w(!1)}};return(0,iB.jsx)("div",{className:"derma-app",style:{marginTop:"69px"},children:(0,iB.jsx)("main",{className:"app-container",children:(0,iB.jsxs)("div",{className:"classifier-card glassmorphism",children:[(0,iB.jsxs)("div",{className:"card-header",children:[(0,iB.jsx)("div",{className:"header-icon",children:(0,iB.jsxs)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",children:[(0,iB.jsx)("path",{d:"M12 15a3 3 0 100-6 3 3 0 000 6z"}),(0,iB.jsx)("path",{fillRule:"evenodd",d:"M1.323 11.447C2.811 6.976 7.028 3.75 12.001 3.75c4.97 0 9.185 3.223 10.675 7.69.12.362.12.752 0 1.113-1.487 4.471-5.705 7.697-10.677 7.697-4.97 0-9.186-3.223-10.675-7.69a1.762 1.762 0 010-1.113zM17.25 12a5.25 5.25 0 11-10.5 0 5.25 5.25 0 0110.5 0z",clipRule:"evenodd"})]})}),(0,iB.jsx)("h2",{children:e("classifier.uploadTitle")}),(0,iB.jsx)("p",{className:"subheader",children:e("classifier.uploadSubtitle")})]}),u&&(0,iB.jsx)("div",{className:"error-message",children:u}),d?(0,iB.jsxs)("div",{className:"loading-state",children:[(0,iB.jsx)("div",{className:"pulse-loader"}),(0,iB.jsx)("p",{children:e("classifier.analyzing")})]}):(0,iB.jsxs)(iB.Fragment,{children:[(0,iB.jsxs)("div",{className:"upload-area dropzone",children:[(0,iB.jsx)("input",{type:"file",ref:C,onChange:t=>{const n=t.target.files[0];if(!n)return;if(!n.type.match("image.*"))return void h(e("classifier.errors.invalidImage"));const a=new FileReader;a.onload=e=>{r(e.target.result),i(null),g(null),v(null),S(null)},a.onerror=()=>{h(e("classifier.errors.imageError"))},a.readAsDataURL(n)},accept:"image/*",style:{display:"none"}}),(0,iB.jsxs)("div",{className:"upload-cta",children:[(0,iB.jsxs)("button",{onClick:()=>{C.current.click()},className:"upload-btn primary-btn",children:[(0,iB.jsx)("span",{className:"icon-upload",children:(0,iB.jsxs)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",children:[(0,iB.jsx)("path",{fillRule:"evenodd",d:"M11.47 2.47a.75.75 0 011.06 0l4.5 4.5a.75.75 0 01-1.06 1.06l-3.22-3.22V16.5a.75.75 0 01-1.5 0V4.81L8.03 8.03a.75.75 0 01-1.06-1.06l4.5-4.5z",clipRule:"evenodd"}),(0,iB.jsx)("path",{fillRule:"evenodd",d:"M5.25 9a.75.75 0 01.75.75v6.75h10.5V9.75a.75.75 0 011.5 0v6.75a1.5 1.5 0 01-1.5 1.5H6a1.5 1.5 0 01-1.5-1.5V9.75A.75.75 0 015.25 9z",clipRule:"evenodd"})]})}),e("classifier.selectImage")]}),(0,iB.jsx)("p",{className:"file-types",children:e("classifier.fileTypes")})]}),a&&(0,iB.jsx)("button",{onClick:async()=>{if(t&&a)try{c(!0),h(null),I.current.complete||await new Promise((e=>{I.current.onload=e}));const n=oi((()=>Bl(I.current).resizeNearestNeighbor([224,224]).toFloat().div(sl(255)).expandDims())),a=t.predict(n),r=await a.data();n.dispose(),a.dispose();const o=[e("classifier.results.normal"),e("classifier.results.benign"),e("classifier.results.malignant")];let s=0,l=0;r.forEach(((e,t)=>{e>s&&(s=e,l=t)}));const u=o[l]||"Class ".concat(l);i({className:u,probability:(100*s).toFixed(2)});const d=await(async t=>{try{var n,a,r,o,s;b(!0);const i='Provide a detailed medical explanation for a lung cancer condition diagnosis of "'.concat(t,'". \n      Structure your response with:\n      2. Potential causes (2 points)\n      3. Recommended actions (2 points)\n      4. When to see a doctor\n      \n      Use clear, professional language suitable for patients. the short text prefered.\n      with this language  ').concat(e("TheCurrentLanguage"),"\n      "),l=await fetch(E,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({contents:[{parts:[{text:i}]}]})});if(console.log(i),!l.ok)throw new Error("API request failed with status ".concat(l.status));return(null===(n=(await l.json()).candidates)||void 0===n||null===(a=n[0])||void 0===a||null===(r=a.content)||void 0===r||null===(o=r.parts)||void 0===o||null===(s=o[0])||void 0===s?void 0:s.text)||e("classifier.errors.hospitalError")}catch(CW){return console.error("Error getting AI explanation:",CW),e("classifier.errors.hospitalError")}finally{b(!1)}})(u);g(d)}catch(CW){console.error("Error classifying image:",CW),h(e("classifier.errors.classificationError"))}finally{c(!1)}},className:"analyze-btn primary-btn accent",disabled:l,children:l?(0,iB.jsxs)(iB.Fragment,{children:[(0,iB.jsx)("span",{className:"spinner"}),e("classifier.analyzing")]}):(0,iB.jsxs)(iB.Fragment,{children:[(0,iB.jsx)("span",{className:"icon-analyze",children:(0,iB.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",children:(0,iB.jsx)("path",{fillRule:"evenodd",d:"M9.315 7.584C12.195 3.883 16.695 1.5 21.75 1.5a.75.75 0 01.75.75c0 5.056-2.383 9.555-6.084 12.436A6.75 6.75 0 019.75 22.5a.75.75 0 01-.75-.75 6.75 6.75 0 016.537-6.711A17.914 17.914 0 009.315 7.584z",clipRule:"evenodd"})})}),e("classifier.analyze")]})})]}),a&&(0,iB.jsx)("div",{className:"image-preview-container",children:(0,iB.jsxs)("div",{className:"image-frame",children:[(0,iB.jsx)("img",{ref:I,src:a,alt:e("classifier.uploadTitle"),crossOrigin:"anonymous",className:"preview-image"}),(0,iB.jsx)("div",{className:"image-overlay",children:(0,iB.jsx)("span",{className:"zoom-hint",children:e("classifier.results.foundNearby")})})]})}),s&&(0,iB.jsxs)("div",{className:"results-panel",children:[(0,iB.jsxs)("div",{className:"results-header",children:[(0,iB.jsxs)("div",{className:"result-title",children:[(0,iB.jsx)("h3",{children:e("classifier.results.title")}),(0,iB.jsxs)("div",{className:"confidence-tag ".concat(s.className.toLowerCase()),children:[s.probability,"% ",e("classifier.results.confidence")]})]}),(0,iB.jsx)("div",{className:"result-meta",children:(0,iB.jsx)("span",{className:"timestamp",children:(new Date).toLocaleString()})})]}),(0,iB.jsxs)("div",{className:"diagnosis-card",children:[(0,iB.jsxs)("div",{className:"condition-badge ".concat(s.className.toLowerCase()),children:[(0,iB.jsx)("span",{className:"badge-icon",children:s.className===e("classifier.results.normal")?(0,iB.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",children:(0,iB.jsx)("path",{fillRule:"evenodd",d:"M8.603 3.799A4.49 4.49 0 0112 2.25c1.357 0 2.573.6 3.397 1.549a4.49 4.49 0 013.498 1.307 4.491 4.491 0 011.307 3.497A4.49 4.49 0 0121.75 12a4.49 4.49 0 01-1.549 3.397 4.491 4.491 0 01-1.307 3.497 4.491 4.491 0 01-3.497 1.307A4.49 4.49 0 0112 21.75a4.49 4.49 0 01-3.397-1.549 4.49 4.49 0 01-3.498-1.306 4.491 4.491 0 01-1.307-3.498A4.49 4.49 0 012.25 12c0-1.357.6-2.573 1.549-3.397a4.49 4.49 0 011.307-3.497 4.49 4.49 0 013.497-1.307zm7.007 6.387a.75.75 0 10-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 00-1.06 1.06l2.25 2.25a.75.75 0 001.14-.094l3.75-5.25z",clipRule:"evenodd"})}):(0,iB.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",children:(0,iB.jsx)("path",{fillRule:"evenodd",d:"M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",clipRule:"evenodd"})})}),s.className]}),(0,iB.jsxs)("div",{className:"probability-meter",children:[(0,iB.jsxs)("div",{className:"meter-labels",children:[(0,iB.jsx)("span",{children:"0%"}),(0,iB.jsx)("span",{children:"100%"})]}),(0,iB.jsx)("div",{className:"meter-track",children:(0,iB.jsx)("div",{className:"meter-fill ".concat(s.className.toLowerCase()),style:{width:"".concat(s.probability,"%")}})})]})]}),(0,iB.jsx)("div",{className:"explanation-section",children:m?(0,iB.jsxs)("div",{className:"loading-explanation",children:[(0,iB.jsx)("div",{className:"spinner small"}),(0,iB.jsx)("p",{children:e("classifier.analyzing")})]}):(0,iB.jsx)("div",{className:"explanation-text formatted-text",dangerouslySetInnerHTML:T(f)})}),s.className!==e("classifier.results.normal")&&!y&&(0,iB.jsxs)("div",{className:"action-section",children:[(0,iB.jsx)("button",{onClick:R,disabled:x,className:"find-hospital-btn secondary-btn",children:x?(0,iB.jsxs)(iB.Fragment,{children:[(0,iB.jsx)("span",{className:"spinner small"}),e("classifier.results.findingClinics")]}):(0,iB.jsxs)(iB.Fragment,{children:[(0,iB.jsx)("span",{className:"icon-hospital",children:(0,iB.jsxs)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",children:[(0,iB.jsx)("path",{d:"M11.584 2.376a.75.75 0 01.832 0l9 6a.75.75 0 11-.832 1.248L12 3.901 3.416 9.624a.75.75 0 01-.832-1.248l9-6z"}),(0,iB.jsx)("path",{fillRule:"evenodd",d:"M20.25 10.332v9.918H21a.75.75 0 010 1.5H3a.75.75 0 010-1.5h.75v-9.918a.75.75 0 01.634-.74A49.109 49.109 0 0112 9c2.59 0 5.134.202 7.616.592a.75.75 0 01.634.74zm-7.5 2.418a.75.75 0 00-1.5 0v6.75a.75.75 0 001.5 0v-6.75zm3-.75a.75.75 0 01.75.75v6.75a.75.75 0 01-1.5 0v-6.75a.75.75 0 01.75-.75zM9 12.75a.75.75 0 00-1.5 0v6.75a.75.75 0 001.5 0v-6.75z",clipRule:"evenodd"}),(0,iB.jsx)("path",{d:"M12 7.875a1.125 1.125 0 100-2.25 1.125 1.125 0 000 2.25z"})]})}),e("classifier.results.findClinics")]})}),(0,iB.jsx)("p",{className:"location-disclaimer",children:e("classifier.results.locationDisclaimer")})]}),k&&(0,iB.jsxs)("div",{className:"location-info",children:[(0,iB.jsx)("h5",{children:e("classifier.results.searchingNear")}),(0,iB.jsx)("p",{children:k})]}),y&&(0,iB.jsxs)("div",{className:"hospital-results",children:[(0,iB.jsxs)("div",{className:"results-header",children:[(0,iB.jsx)("h4",{children:e("classifier.results.recommendedClinics")}),(0,iB.jsx)("span",{className:"results-count",children:e("classifier.results.foundNearby")})]}),(0,iB.jsx)("div",{className:"hospital-list formatted-text",dangerouslySetInnerHTML:T(y)}),(0,iB.jsxs)("button",{onClick:R,className:"refresh-btn secondary-btn small",children:[(0,iB.jsx)("span",{className:"icon-refresh",children:(0,iB.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",children:(0,iB.jsx)("path",{fillRule:"evenodd",d:"M4.755 10.059a7.5 7.5 0 0112.548-3.364l1.903 1.903h-3.183a.75.75 0 100 1.5h4.992a.75.75 0 00.75-.75V4.356a.75.75 0 00-1.5 0v3.18l-1.9-1.9A9 9 0 003.306 9.67a.75.75 0 101.45.388zm15.408 3.352a.75.75 0 00-.919.53 7.5 7.5 0 01-12.548 3.364l-1.902-1.903h3.183a.75.75 0 000-1.5H2.984a.75.75 0 00-.75.75v4.992a.75.75 0 001.5 0v-3.18l1.9 1.9a9 9 0 0015.059-4.035.75.75 0 00-.53-.918z",clipRule:"evenodd"})})}),e("classifier.results.refreshResults")]})]})]})]})]})})})};const cB=function(){const{t:e}=sB();return(0,iB.jsxs)("div",{className:"medical-homepage",children:[(0,iB.jsxs)("section",{className:"hero-section",children:[(0,iB.jsx)("div",{className:"hero-overlay"}),(0,iB.jsx)("div",{className:"hero-content",children:(0,iB.jsxs)("div",{className:"hero-text",children:[(0,iB.jsx)("h1",{children:e("home.title")}),(0,iB.jsx)("p",{className:"subtitle",children:e("home.subtitle")})]})})]}),(0,iB.jsx)("section",{className:"selection-section",children:(0,iB.jsxs)("div",{className:"container",children:[(0,iB.jsxs)("div",{className:"section-header",children:[(0,iB.jsx)("h2",{className:"section-title",children:e("home.chooseMethod")}),(0,iB.jsx)("p",{className:"section-subtitle",children:e("home.chooseSubtitle")})]}),(0,iB.jsxs)("div",{className:"card-grid",children:[(0,iB.jsxs)(mt,{to:"/ct",className:"imaging-card",children:[(0,iB.jsxs)("div",{className:"card-content",children:[(0,iB.jsx)("div",{className:"card-icon-container",children:(0,iB.jsx)("svg",{className:"card-icon",viewBox:"0 0 24 24",children:(0,iB.jsx)("path",{d:"M3,3H21V21H3V3M5,5V19H19V5H5M8,7H16V9H8V7M10,11H14V13H10V11M12,15H14V17H12V15Z"})})}),(0,iB.jsxs)("div",{className:"card-text",children:[(0,iB.jsx)("h3",{children:e("home.ctScan.title")}),(0,iB.jsx)("p",{children:e("home.ctScan.description")})]}),(0,iB.jsxs)("div",{className:"card-cta",children:[(0,iB.jsx)("span",{children:e("home.ctScan.button")}),(0,iB.jsx)("svg",{className:"arrow-right",viewBox:"0 0 24 24",children:(0,iB.jsx)("path",{d:"M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"})})]})]}),(0,iB.jsx)("div",{className:"card-highlight"})]}),(0,iB.jsxs)(mt,{to:"/xray",className:"imaging-card",children:[(0,iB.jsxs)("div",{className:"card-content",children:[(0,iB.jsx)("div",{className:"card-icon-container",children:(0,iB.jsx)("svg",{className:"card-icon",viewBox:"0 0 24 24",children:(0,iB.jsx)("path",{d:"M14,12H10V10H14V12M14,16H10V14H14V16M19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3M19,19H5V5H19V19Z"})})}),(0,iB.jsxs)("div",{className:"card-text",children:[(0,iB.jsx)("h3",{children:e("home.xray.title")}),(0,iB.jsx)("p",{children:e("home.xray.description")})]}),(0,iB.jsxs)("div",{className:"card-cta",children:[(0,iB.jsx)("span",{children:e("home.xray.button")}),(0,iB.jsx)("svg",{className:"arrow-right",viewBox:"0 0 24 24",children:(0,iB.jsx)("path",{d:"M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"})})]})]}),(0,iB.jsx)("div",{className:"card-highlight"})]})]})]})})]})},uB=()=>(0,iB.jsxs)("footer",{className:"pulmo-footer",children:[(0,iB.jsx)("div",{className:"footer-glow"}),(0,iB.jsxs)("div",{className:"footer-container",children:[(0,iB.jsx)("h2",{className:"team-name",children:"PulmoDX AI Team"}),(0,iB.jsx)("p",{className:"tagline",children:"Smart Lung Diagnostics Powered by AI"}),(0,iB.jsxs)("p",{className:"credits",children:["\xa9 ",(new Date).getFullYear()," PulmoDX Team | All rights reserved."]})]})]}),hB=e=>"string"===typeof e,dB=()=>{let e,t;const n=new Promise(((n,a)=>{e=n,t=a}));return n.resolve=e,n.reject=t,n},pB=e=>null==e?"":""+e,fB=/###/g,gB=e=>e&&e.indexOf("###")>-1?e.replace(fB,"."):e,mB=e=>!e||hB(e),bB=(e,t,n)=>{const a=hB(t)?t.split("."):t;let r=0;for(;r<a.length-1;){if(mB(e))return{};const t=gB(a[r]);!e[t]&&n&&(e[t]=new n),e=Object.prototype.hasOwnProperty.call(e,t)?e[t]:{},++r}return mB(e)?{}:{obj:e,k:gB(a[r])}},yB=(e,t,n)=>{const{obj:a,k:r}=bB(e,t,Object);if(void 0!==a||1===t.length)return void(a[r]=n);let o=t[t.length-1],s=t.slice(0,t.length-1),i=bB(e,s,Object);for(;void 0===i.obj&&s.length;){var l;o="".concat(s[s.length-1],".").concat(o),s=s.slice(0,s.length-1),i=bB(e,s,Object),null!==(l=i)&&void 0!==l&&l.obj&&"undefined"!==typeof i.obj["".concat(i.k,".").concat(o)]&&(i.obj=void 0)}i.obj["".concat(i.k,".").concat(o)]=n},vB=(e,t)=>{const{obj:n,k:a}=bB(e,t);if(n&&Object.prototype.hasOwnProperty.call(n,a))return n[a]},xB=(e,t,n)=>{for(const a in t)"__proto__"!==a&&"constructor"!==a&&(a in e?hB(e[a])||e[a]instanceof String||hB(t[a])||t[a]instanceof String?n&&(e[a]=t[a]):xB(e[a],t[a],n):e[a]=t[a]);return e},wB=e=>e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&");var kB={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"};const SB=e=>hB(e)?e.replace(/[&<>"'\/]/g,(e=>kB[e])):e;const IB=[" ",",","?","!",";"],CB=new class{constructor(e){this.capacity=e,this.regExpMap=new Map,this.regExpQueue=[]}getRegExp(e){const t=this.regExpMap.get(e);if(void 0!==t)return t;const n=new RegExp(e);return this.regExpQueue.length===this.capacity&&this.regExpMap.delete(this.regExpQueue.shift()),this.regExpMap.set(e,n),this.regExpQueue.push(e),n}}(20),NB=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:".";if(!e)return;if(e[t]){if(!Object.prototype.hasOwnProperty.call(e,t))return;return e[t]}const a=t.split(n);let r=e;for(let o=0;o<a.length;){if(!r||"object"!==typeof r)return;let e,t="";for(let s=o;s<a.length;++s)if(s!==o&&(t+=n),t+=a[s],e=r[t],void 0!==e){if(["string","number","boolean"].indexOf(typeof e)>-1&&s<a.length-1)continue;o+=s-o+1;break}r=e}return r},EB=e=>null===e||void 0===e?void 0:e.replace("_","-"),TB={type:"logger",log(e){this.output("log",e)},warn(e){this.output("warn",e)},error(e){this.output("error",e)},output(e,t){var n,a;null===(n=console)||void 0===n||null===(n=n[e])||void 0===n||null===(a=n.apply)||void 0===a||a.call(n,console,t)}};class RB{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.init(e,t)}init(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.prefix=t.prefix||"i18next:",this.logger=e||TB,this.options=t,this.debug=t.debug}log(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"log","",!0)}warn(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"warn","",!0)}error(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"error","")}deprecate(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"warn","WARNING DEPRECATED: ",!0)}forward(e,t,n,a){return a&&!this.debug?null:(hB(e[0])&&(e[0]="".concat(n).concat(this.prefix," ").concat(e[0])),this.logger[t](e))}create(e){return new RB(this.logger,d(d({},{prefix:"".concat(this.prefix,":").concat(e,":")}),this.options))}clone(e){return(e=e||this.options).prefix=e.prefix||this.prefix,new RB(this.logger,e)}}var AB=new RB;class FB{constructor(){this.observers={}}on(e,t){return e.split(" ").forEach((e=>{this.observers[e]||(this.observers[e]=new Map);const n=this.observers[e].get(t)||0;this.observers[e].set(t,n+1)})),this}off(e,t){this.observers[e]&&(t?this.observers[e].delete(t):delete this.observers[e])}emit(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];if(this.observers[e]){Array.from(this.observers[e].entries()).forEach((e=>{let[t,a]=e;for(let r=0;r<a;r++)t(...n)}))}if(this.observers["*"]){Array.from(this.observers["*"].entries()).forEach((t=>{let[a,r]=t;for(let o=0;o<r;o++)a.apply(a,[e,...n])}))}}}class DB extends FB{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{ns:["translation"],defaultNS:"translation"};super(),this.data=e||{},this.options=t,void 0===this.options.keySeparator&&(this.options.keySeparator="."),void 0===this.options.ignoreJSONStructure&&(this.options.ignoreJSONStructure=!0)}addNamespaces(e){this.options.ns.indexOf(e)<0&&this.options.ns.push(e)}removeNamespaces(e){const t=this.options.ns.indexOf(e);t>-1&&this.options.ns.splice(t,1)}getResource(e,t,n){var a;let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const o=void 0!==r.keySeparator?r.keySeparator:this.options.keySeparator,s=void 0!==r.ignoreJSONStructure?r.ignoreJSONStructure:this.options.ignoreJSONStructure;let i;e.indexOf(".")>-1?i=e.split("."):(i=[e,t],n&&(Array.isArray(n)?i.push(...n):hB(n)&&o?i.push(...n.split(o)):i.push(n)));const l=vB(this.data,i);return!l&&!t&&!n&&e.indexOf(".")>-1&&(e=i[0],t=i[1],n=i.slice(2).join(".")),!l&&s&&hB(n)?NB(null===(a=this.data)||void 0===a||null===(a=a[e])||void 0===a?void 0:a[t],n,o):l}addResource(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{silent:!1};const o=void 0!==r.keySeparator?r.keySeparator:this.options.keySeparator;let s=[e,t];n&&(s=s.concat(o?n.split(o):n)),e.indexOf(".")>-1&&(s=e.split("."),a=t,t=s[1]),this.addNamespaces(t),yB(this.data,s,a),r.silent||this.emit("added",e,t,n,a)}addResources(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{silent:!1};for(const r in n)(hB(n[r])||Array.isArray(n[r]))&&this.addResource(e,t,r,n[r],{silent:!0});a.silent||this.emit("added",e,t,n)}addResourceBundle(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{silent:!1,skipCopy:!1},s=[e,t];e.indexOf(".")>-1&&(s=e.split("."),a=n,n=t,t=s[1]),this.addNamespaces(t);let i=vB(this.data,s)||{};o.skipCopy||(n=JSON.parse(JSON.stringify(n))),a?xB(i,n,r):i=d(d({},i),n),yB(this.data,s,i),o.silent||this.emit("added",e,t,n)}removeResourceBundle(e,t){this.hasResourceBundle(e,t)&&delete this.data[e][t],this.removeNamespaces(t),this.emit("removed",e,t)}hasResourceBundle(e,t){return void 0!==this.getResource(e,t)}getResourceBundle(e,t){return t||(t=this.options.defaultNS),this.getResource(e,t)}getDataByLanguage(e){return this.data[e]}hasLanguageSomeTranslations(e){const t=this.getDataByLanguage(e);return!!(t&&Object.keys(t)||[]).find((e=>t[e]&&Object.keys(t[e]).length>0))}toJSON(){return this.data}}var _B={processors:{},addPostProcessor(e){this.processors[e.name]=e},handle(e,t,n,a,r){return e.forEach((e=>{var o,s;t=null!==(o=null===(s=this.processors[e])||void 0===s?void 0:s.process(t,n,a,r))&&void 0!==o?o:t})),t}};const OB={},LB=e=>!hB(e)&&"boolean"!==typeof e&&"number"!==typeof e;class zB extends FB{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),((e,t,n)=>{e.forEach((e=>{t[e]&&(n[e]=t[e])}))})(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector","i18nFormat","utils"],e,this),this.options=t,void 0===this.options.keySeparator&&(this.options.keySeparator="."),this.logger=AB.create("translator")}changeLanguage(e){e&&(this.language=e)}exists(e){const t=d({},arguments.length>1&&void 0!==arguments[1]?arguments[1]:{interpolation:{}});if(null==e)return!1;const n=this.resolve(e,t);return void 0!==(null===n||void 0===n?void 0:n.res)}extractFromKey(e,t){let n=void 0!==t.nsSeparator?t.nsSeparator:this.options.nsSeparator;void 0===n&&(n=":");const a=void 0!==t.keySeparator?t.keySeparator:this.options.keySeparator;let r=t.ns||this.options.defaultNS||[];const o=n&&e.indexOf(n)>-1,s=!this.options.userDefinedKeySeparator&&!t.keySeparator&&!this.options.userDefinedNsSeparator&&!t.nsSeparator&&!((e,t,n)=>{t=t||"",n=n||"";const a=IB.filter((e=>t.indexOf(e)<0&&n.indexOf(e)<0));if(0===a.length)return!0;const r=CB.getRegExp("(".concat(a.map((e=>"?"===e?"\\?":e)).join("|"),")"));let o=!r.test(e);if(!o){const t=e.indexOf(n);t>0&&!r.test(e.substring(0,t))&&(o=!0)}return o})(e,n,a);if(o&&!s){const t=e.match(this.interpolator.nestingRegexp);if(t&&t.length>0)return{key:e,namespaces:hB(r)?[r]:r};const o=e.split(n);(n!==a||n===a&&this.options.ns.indexOf(o[0])>-1)&&(r=o.shift()),e=o.join(a)}return{key:e,namespaces:hB(r)?[r]:r}}translate(e,t,n){let a="object"===typeof t?d({},t):t;if("object"!==typeof a&&this.options.overloadTranslationOptionHandler&&(a=this.options.overloadTranslationOptionHandler(arguments)),"object"===typeof options&&(a=d({},a)),a||(a={}),null==e)return"";Array.isArray(e)||(e=[String(e)]);const r=void 0!==a.returnDetails?a.returnDetails:this.options.returnDetails,o=void 0!==a.keySeparator?a.keySeparator:this.options.keySeparator,{key:s,namespaces:i}=this.extractFromKey(e[e.length-1],a),l=i[i.length-1];let c=void 0!==a.nsSeparator?a.nsSeparator:this.options.nsSeparator;void 0===c&&(c=":");const u=a.lng||this.language,h=a.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if("cimode"===(null===u||void 0===u?void 0:u.toLowerCase()))return h?r?{res:"".concat(l).concat(c).concat(s),usedKey:s,exactUsedKey:s,usedLng:u,usedNS:l,usedParams:this.getUsedParamsDetails(a)}:"".concat(l).concat(c).concat(s):r?{res:s,usedKey:s,exactUsedKey:s,usedLng:u,usedNS:l,usedParams:this.getUsedParamsDetails(a)}:s;const p=this.resolve(e,a);let f=null===p||void 0===p?void 0:p.res;const g=(null===p||void 0===p?void 0:p.usedKey)||s,m=(null===p||void 0===p?void 0:p.exactUsedKey)||s,b=void 0!==a.joinArrays?a.joinArrays:this.options.joinArrays,y=!this.i18nFormat||this.i18nFormat.handleAsObject,v=void 0!==a.count&&!hB(a.count),x=zB.hasDefaultValue(a),w=v?this.pluralResolver.getSuffix(u,a.count,a):"",k=a.ordinal&&v?this.pluralResolver.getSuffix(u,a.count,{ordinal:!1}):"",S=v&&!a.ordinal&&0===a.count,I=S&&a["defaultValue".concat(this.options.pluralSeparator,"zero")]||a["defaultValue".concat(w)]||a["defaultValue".concat(k)]||a.defaultValue;let C=f;y&&!f&&x&&(C=I);const N=LB(C),E=Object.prototype.toString.apply(C);if(!(y&&C&&N&&["[object Number]","[object Function]","[object RegExp]"].indexOf(E)<0)||hB(b)&&Array.isArray(C))if(y&&hB(b)&&Array.isArray(f))f=f.join(b),f&&(f=this.extendTranslation(f,e,a,n));else{let t=!1,r=!1;!this.isValidLookup(f)&&x&&(t=!0,f=I),this.isValidLookup(f)||(r=!0,f=s);const i=(a.missingKeyNoValueFallbackToKey||this.options.missingKeyNoValueFallbackToKey)&&r?void 0:f,h=x&&I!==f&&this.options.updateMissing;if(r||t||h){if(this.logger.log(h?"updateKey":"missingKey",u,l,s,h?I:f),o){const e=this.resolve(s,d(d({},a),{},{keySeparator:!1}));e&&e.res&&this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")}let e=[];const t=this.languageUtils.getFallbackCodes(this.options.fallbackLng,a.lng||this.language);if("fallback"===this.options.saveMissingTo&&t&&t[0])for(let a=0;a<t.length;a++)e.push(t[a]);else"all"===this.options.saveMissingTo?e=this.languageUtils.toResolveHierarchy(a.lng||this.language):e.push(a.lng||this.language);const n=(e,t,n)=>{var r;const o=x&&n!==f?n:i;this.options.missingKeyHandler?this.options.missingKeyHandler(e,l,t,o,h,a):null!==(r=this.backendConnector)&&void 0!==r&&r.saveMissing&&this.backendConnector.saveMissing(e,l,t,o,h,a),this.emit("missingKey",e,l,t,f)};this.options.saveMissing&&(this.options.saveMissingPlurals&&v?e.forEach((e=>{const t=this.pluralResolver.getSuffixes(e,a);S&&a["defaultValue".concat(this.options.pluralSeparator,"zero")]&&t.indexOf("".concat(this.options.pluralSeparator,"zero"))<0&&t.push("".concat(this.options.pluralSeparator,"zero")),t.forEach((t=>{n([e],s+t,a["defaultValue".concat(t)]||I)}))})):n(e,s,I))}f=this.extendTranslation(f,e,a,p,n),r&&f===s&&this.options.appendNamespaceToMissingKey&&(f="".concat(l).concat(c).concat(s)),(r||t)&&this.options.parseMissingKeyHandler&&(f=this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey?"".concat(l).concat(c).concat(s):s,t?f:void 0,a))}else{if(!a.returnObjects&&!this.options.returnObjects){this.options.returnedObjectHandler||this.logger.warn("accessing an object - but returnObjects options is not enabled!");const e=this.options.returnedObjectHandler?this.options.returnedObjectHandler(g,C,d(d({},a),{},{ns:i})):"key '".concat(s," (").concat(this.language,")' returned an object instead of string.");return r?(p.res=e,p.usedParams=this.getUsedParamsDetails(a),p):e}if(o){const e=Array.isArray(C),t=e?[]:{},n=e?m:g;for(const r in C)if(Object.prototype.hasOwnProperty.call(C,r)){const e="".concat(n).concat(o).concat(r);t[r]=x&&!f?this.translate(e,d(d({},a),{},{defaultValue:LB(I)?I[r]:void 0},{joinArrays:!1,ns:i})):this.translate(e,d(d({},a),{joinArrays:!1,ns:i})),t[r]===e&&(t[r]=C[r])}f=t}}return r?(p.res=f,p.usedParams=this.getUsedParamsDetails(a),p):f}extendTranslation(e,t,n,a,r){var o,s=this;if(null!==(o=this.i18nFormat)&&void 0!==o&&o.parse)e=this.i18nFormat.parse(e,d(d({},this.options.interpolation.defaultVariables),n),n.lng||this.language||a.usedLng,a.usedNS,a.usedKey,{resolved:a});else if(!n.skipInterpolation){var i;n.interpolation&&this.interpolator.init(d(d({},n),{interpolation:d(d({},this.options.interpolation),n.interpolation)}));const o=hB(e)&&(void 0!==(null===n||void 0===n||null===(i=n.interpolation)||void 0===i?void 0:i.skipOnVariables)?n.interpolation.skipOnVariables:this.options.interpolation.skipOnVariables);let l;if(o){const t=e.match(this.interpolator.nestingRegexp);l=t&&t.length}let c=n.replace&&!hB(n.replace)?n.replace:n;if(this.options.interpolation.defaultVariables&&(c=d(d({},this.options.interpolation.defaultVariables),c)),e=this.interpolator.interpolate(e,c,n.lng||this.language||a.usedLng,n),o){const t=e.match(this.interpolator.nestingRegexp);l<(t&&t.length)&&(n.nest=!1)}!n.lng&&a&&a.res&&(n.lng=this.language||a.usedLng),!1!==n.nest&&(e=this.interpolator.nest(e,(function(){for(var e=arguments.length,a=new Array(e),o=0;o<e;o++)a[o]=arguments[o];return(null===r||void 0===r?void 0:r[0])!==a[0]||n.context?s.translate(...a,t):(s.logger.warn("It seems you are nesting recursively key: ".concat(a[0]," in key: ").concat(t[0])),null)}),n)),n.interpolation&&this.interpolator.reset()}const l=n.postProcess||this.options.postProcess,c=hB(l)?[l]:l;return null!=e&&null!==c&&void 0!==c&&c.length&&!1!==n.applyPostProcessor&&(e=_B.handle(c,e,t,this.options&&this.options.postProcessPassResolved?d({i18nResolved:d(d({},a),{},{usedParams:this.getUsedParamsDetails(n)})},n):n,this)),e}resolve(e){let t,n,a,r,o,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return hB(e)&&(e=[e]),e.forEach((e=>{if(this.isValidLookup(t))return;const i=this.extractFromKey(e,s),l=i.key;n=l;let c=i.namespaces;this.options.fallbackNS&&(c=c.concat(this.options.fallbackNS));const u=void 0!==s.count&&!hB(s.count),h=u&&!s.ordinal&&0===s.count,d=void 0!==s.context&&(hB(s.context)||"number"===typeof s.context)&&""!==s.context,p=s.lngs?s.lngs:this.languageUtils.toResolveHierarchy(s.lng||this.language,s.fallbackLng);c.forEach((e=>{var i,c;this.isValidLookup(t)||(o=e,OB["".concat(p[0],"-").concat(e)]||null===(i=this.utils)||void 0===i||!i.hasLoadedNamespace||null!==(c=this.utils)&&void 0!==c&&c.hasLoadedNamespace(o)||(OB["".concat(p[0],"-").concat(e)]=!0,this.logger.warn('key "'.concat(n,'" for languages "').concat(p.join(", "),'" won\'t get resolved as namespace "').concat(o,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),p.forEach((n=>{var o;if(this.isValidLookup(t))return;r=n;const i=[l];if(null!==(o=this.i18nFormat)&&void 0!==o&&o.addLookupKeys)this.i18nFormat.addLookupKeys(i,l,n,e,s);else{let e;u&&(e=this.pluralResolver.getSuffix(n,s.count,s));const t="".concat(this.options.pluralSeparator,"zero"),a="".concat(this.options.pluralSeparator,"ordinal").concat(this.options.pluralSeparator);if(u&&(i.push(l+e),s.ordinal&&0===e.indexOf(a)&&i.push(l+e.replace(a,this.options.pluralSeparator)),h&&i.push(l+t)),d){const n="".concat(l).concat(this.options.contextSeparator).concat(s.context);i.push(n),u&&(i.push(n+e),s.ordinal&&0===e.indexOf(a)&&i.push(n+e.replace(a,this.options.pluralSeparator)),h&&i.push(n+t))}}let c;for(;c=i.pop();)this.isValidLookup(t)||(a=c,t=this.getResource(n,e,c,s))})))}))})),{res:t,usedKey:n,exactUsedKey:a,usedLng:r,usedNS:o}}isValidLookup(e){return void 0!==e&&!(!this.options.returnNull&&null===e)&&!(!this.options.returnEmptyString&&""===e)}getResource(e,t,n){var a;let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return null!==(a=this.i18nFormat)&&void 0!==a&&a.getResource?this.i18nFormat.getResource(e,t,n,r):this.resourceStore.getResource(e,t,n,r)}getUsedParamsDetails(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=["defaultValue","ordinal","context","replace","lng","lngs","fallbackLng","ns","keySeparator","nsSeparator","returnObjects","returnDetails","joinArrays","postProcess","interpolation"],n=e.replace&&!hB(e.replace);let a=n?e.replace:e;if(n&&"undefined"!==typeof e.count&&(a.count=e.count),this.options.interpolation.defaultVariables&&(a=d(d({},this.options.interpolation.defaultVariables),a)),!n){a=d({},a);for(const e of t)delete a[e]}return a}static hasDefaultValue(e){const t="defaultValue";for(const n in e)if(Object.prototype.hasOwnProperty.call(e,n)&&t===n.substring(0,12)&&void 0!==e[n])return!0;return!1}}class MB{constructor(e){this.options=e,this.supportedLngs=this.options.supportedLngs||!1,this.logger=AB.create("languageUtils")}getScriptPartFromCode(e){if(!(e=EB(e))||e.indexOf("-")<0)return null;const t=e.split("-");return 2===t.length?null:(t.pop(),"x"===t[t.length-1].toLowerCase()?null:this.formatLanguageCode(t.join("-")))}getLanguagePartFromCode(e){if(!(e=EB(e))||e.indexOf("-")<0)return e;const t=e.split("-");return this.formatLanguageCode(t[0])}formatLanguageCode(e){if(hB(e)&&e.indexOf("-")>-1){let t;try{t=Intl.getCanonicalLocales(e)[0]}catch(IW){}return t&&this.options.lowerCaseLng&&(t=t.toLowerCase()),t||(this.options.lowerCaseLng?e.toLowerCase():e)}return this.options.cleanCode||this.options.lowerCaseLng?e.toLowerCase():e}isSupportedCode(e){return("languageOnly"===this.options.load||this.options.nonExplicitSupportedLngs)&&(e=this.getLanguagePartFromCode(e)),!this.supportedLngs||!this.supportedLngs.length||this.supportedLngs.indexOf(e)>-1}getBestMatchFromCodes(e){if(!e)return null;let t;return e.forEach((e=>{if(t)return;const n=this.formatLanguageCode(e);this.options.supportedLngs&&!this.isSupportedCode(n)||(t=n)})),!t&&this.options.supportedLngs&&e.forEach((e=>{if(t)return;const n=this.getScriptPartFromCode(e);if(this.isSupportedCode(n))return t=n;const a=this.getLanguagePartFromCode(e);if(this.isSupportedCode(a))return t=a;t=this.options.supportedLngs.find((e=>e===a?e:e.indexOf("-")<0&&a.indexOf("-")<0?void 0:e.indexOf("-")>0&&a.indexOf("-")<0&&e.substring(0,e.indexOf("-"))===a||0===e.indexOf(a)&&a.length>1?e:void 0))})),t||(t=this.getFallbackCodes(this.options.fallbackLng)[0]),t}getFallbackCodes(e,t){if(!e)return[];if("function"===typeof e&&(e=e(t)),hB(e)&&(e=[e]),Array.isArray(e))return e;if(!t)return e.default||[];let n=e[t];return n||(n=e[this.getScriptPartFromCode(t)]),n||(n=e[this.formatLanguageCode(t)]),n||(n=e[this.getLanguagePartFromCode(t)]),n||(n=e.default),n||[]}toResolveHierarchy(e,t){const n=this.getFallbackCodes((!1===t?[]:t)||this.options.fallbackLng||[],e),a=[],r=e=>{e&&(this.isSupportedCode(e)?a.push(e):this.logger.warn("rejecting language code not found in supportedLngs: ".concat(e)))};return hB(e)&&(e.indexOf("-")>-1||e.indexOf("_")>-1)?("languageOnly"!==this.options.load&&r(this.formatLanguageCode(e)),"languageOnly"!==this.options.load&&"currentOnly"!==this.options.load&&r(this.getScriptPartFromCode(e)),"currentOnly"!==this.options.load&&r(this.getLanguagePartFromCode(e))):hB(e)&&r(this.formatLanguageCode(e)),n.forEach((e=>{a.indexOf(e)<0&&r(this.formatLanguageCode(e))})),a}}const PB={zero:0,one:1,two:2,few:3,many:4,other:5},BB={select:e=>1===e?"one":"other",resolvedOptions:()=>({pluralCategories:["one","other"]})};class WB{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.languageUtils=e,this.options=t,this.logger=AB.create("pluralResolver"),this.pluralRulesCache={}}addRule(e,t){this.rules[e]=t}clearCache(){this.pluralRulesCache={}}getRule(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=EB("dev"===e?"en":e),a=t.ordinal?"ordinal":"cardinal",r=JSON.stringify({cleanedCode:n,type:a});if(r in this.pluralRulesCache)return this.pluralRulesCache[r];let o;try{o=new Intl.PluralRules(n,{type:a})}catch(CW){if(!Intl)return this.logger.error("No Intl support, please use an Intl polyfill!"),BB;if(!e.match(/-|_/))return BB;const a=this.languageUtils.getLanguagePartFromCode(e);o=this.getRule(a,t)}return this.pluralRulesCache[r]=o,o}needsPlural(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=this.getRule(e,n);return a||(a=this.getRule("dev",n)),(null===(t=a)||void 0===t?void 0:t.resolvedOptions().pluralCategories.length)>1}getPluralFormsOfKey(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.getSuffixes(e,n).map((e=>"".concat(t).concat(e)))}getSuffixes(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=this.getRule(e,t);return n||(n=this.getRule("dev",t)),n?n.resolvedOptions().pluralCategories.sort(((e,t)=>PB[e]-PB[t])).map((e=>"".concat(this.options.prepend).concat(t.ordinal?"ordinal".concat(this.options.prepend):"").concat(e))):[]}getSuffix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=this.getRule(e,n);return a?"".concat(this.options.prepend).concat(n.ordinal?"ordinal".concat(this.options.prepend):"").concat(a.select(t)):(this.logger.warn("no plural rule found for: ".concat(e)),this.getSuffix("dev",t,n))}}const UB=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:".",r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],o=((e,t,n)=>{const a=vB(e,n);return void 0!==a?a:vB(t,n)})(e,t,n);return!o&&r&&hB(n)&&(o=NB(e,n,a),void 0===o&&(o=NB(t,n,a))),o},VB=e=>e.replace(/\$/g,"$$$$");class GB{constructor(){var e;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.logger=AB.create("interpolator"),this.options=t,this.format=(null===t||void 0===t||null===(e=t.interpolation)||void 0===e?void 0:e.format)||(e=>e),this.init(t)}init(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};e.interpolation||(e.interpolation={escapeValue:!0});const{escape:t,escapeValue:n,useRawValueToEscape:a,prefix:r,prefixEscaped:o,suffix:s,suffixEscaped:i,formatSeparator:l,unescapeSuffix:c,unescapePrefix:u,nestingPrefix:h,nestingPrefixEscaped:d,nestingSuffix:p,nestingSuffixEscaped:f,nestingOptionsSeparator:g,maxReplaces:m,alwaysFormat:b}=e.interpolation;this.escape=void 0!==t?t:SB,this.escapeValue=void 0===n||n,this.useRawValueToEscape=void 0!==a&&a,this.prefix=r?wB(r):o||"{{",this.suffix=s?wB(s):i||"}}",this.formatSeparator=l||",",this.unescapePrefix=c?"":u||"-",this.unescapeSuffix=this.unescapePrefix?"":c||"",this.nestingPrefix=h?wB(h):d||wB("$t("),this.nestingSuffix=p?wB(p):f||wB(")"),this.nestingOptionsSeparator=g||",",this.maxReplaces=m||1e3,this.alwaysFormat=void 0!==b&&b,this.resetRegExp()}reset(){this.options&&this.init(this.options)}resetRegExp(){const e=(e,t)=>(null===e||void 0===e?void 0:e.source)===t?(e.lastIndex=0,e):new RegExp(t,"g");this.regexp=e(this.regexp,"".concat(this.prefix,"(.+?)").concat(this.suffix)),this.regexpUnescape=e(this.regexpUnescape,"".concat(this.prefix).concat(this.unescapePrefix,"(.+?)").concat(this.unescapeSuffix).concat(this.suffix)),this.nestingRegexp=e(this.nestingRegexp,"".concat(this.nestingPrefix,"(.+?)").concat(this.nestingSuffix))}interpolate(e,t,n,a){var r;let o,s,i;const l=this.options&&this.options.interpolation&&this.options.interpolation.defaultVariables||{},c=e=>{if(e.indexOf(this.formatSeparator)<0){const r=UB(t,l,e,this.options.keySeparator,this.options.ignoreJSONStructure);return this.alwaysFormat?this.format(r,void 0,n,d(d(d({},a),t),{},{interpolationkey:e})):r}const r=e.split(this.formatSeparator),o=r.shift().trim(),s=r.join(this.formatSeparator).trim();return this.format(UB(t,l,o,this.options.keySeparator,this.options.ignoreJSONStructure),s,n,d(d(d({},a),t),{},{interpolationkey:o}))};this.resetRegExp();const u=(null===a||void 0===a?void 0:a.missingInterpolationHandler)||this.options.missingInterpolationHandler,h=void 0!==(null===a||void 0===a||null===(r=a.interpolation)||void 0===r?void 0:r.skipOnVariables)?a.interpolation.skipOnVariables:this.options.interpolation.skipOnVariables;return[{regex:this.regexpUnescape,safeValue:e=>VB(e)},{regex:this.regexp,safeValue:e=>this.escapeValue?VB(this.escape(e)):VB(e)}].forEach((t=>{for(i=0;o=t.regex.exec(e);){const n=o[1].trim();if(s=c(n),void 0===s)if("function"===typeof u){const t=u(e,o,a);s=hB(t)?t:""}else if(a&&Object.prototype.hasOwnProperty.call(a,n))s="";else{if(h){s=o[0];continue}this.logger.warn("missed to pass in variable ".concat(n," for interpolating ").concat(e)),s=""}else hB(s)||this.useRawValueToEscape||(s=pB(s));const r=t.safeValue(s);if(e=e.replace(o[0],r),h?(t.regex.lastIndex+=s.length,t.regex.lastIndex-=o[0].length):t.regex.lastIndex=0,i++,i>=this.maxReplaces)break}})),e}nest(e,t){let n,a,r,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=(e,t)=>{var n;const a=this.nestingOptionsSeparator;if(e.indexOf(a)<0)return e;const o=e.split(new RegExp("".concat(a,"[ ]*{")));let s="{".concat(o[1]);e=o[0],s=this.interpolate(s,r);const i=s.match(/'/g),l=s.match(/"/g);((null!==(n=null===i||void 0===i?void 0:i.length)&&void 0!==n?n:0)%2===0&&!l||l.length%2!==0)&&(s=s.replace(/'/g,'"'));try{r=JSON.parse(s),t&&(r=d(d({},t),r))}catch(IW){return this.logger.warn("failed parsing options string in nesting for key ".concat(e),IW),"".concat(e).concat(a).concat(s)}return r.defaultValue&&r.defaultValue.indexOf(this.prefix)>-1&&delete r.defaultValue,e};for(;n=this.nestingRegexp.exec(e);){let i=[];r=d({},o),r=r.replace&&!hB(r.replace)?r.replace:r,r.applyPostProcessor=!1,delete r.defaultValue;let l=!1;if(-1!==n[0].indexOf(this.formatSeparator)&&!/{.*}/.test(n[1])){const e=n[1].split(this.formatSeparator).map((e=>e.trim()));n[1]=e.shift(),i=e,l=!0}if(a=t(s.call(this,n[1].trim(),r),r),a&&n[0]===e&&!hB(a))return a;hB(a)||(a=pB(a)),a||(this.logger.warn("missed to resolve ".concat(n[1]," for nesting ").concat(e)),a=""),l&&(a=i.reduce(((e,t)=>this.format(e,t,o.lng,d(d({},o),{},{interpolationkey:n[1].trim()}))),a.trim())),e=e.replace(n[0],a),this.regexp.lastIndex=0}return e}}const jB=e=>{const t={};return(n,a,r)=>{let o=r;r&&r.interpolationkey&&r.formatParams&&r.formatParams[r.interpolationkey]&&r[r.interpolationkey]&&(o=d(d({},o),{},{[r.interpolationkey]:void 0}));const s=a+JSON.stringify(o);let i=t[s];return i||(i=e(EB(a),r),t[s]=i),i(n)}},HB=e=>(t,n,a)=>e(EB(n),a)(t);class KB{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.logger=AB.create("formatter"),this.options=e,this.init(e)}init(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{interpolation:{}};this.formatSeparator=t.interpolation.formatSeparator||",";const n=t.cacheInBuiltFormats?jB:HB;this.formats={number:n(((e,t)=>{const n=new Intl.NumberFormat(e,d({},t));return e=>n.format(e)})),currency:n(((e,t)=>{const n=new Intl.NumberFormat(e,d(d({},t),{},{style:"currency"}));return e=>n.format(e)})),datetime:n(((e,t)=>{const n=new Intl.DateTimeFormat(e,d({},t));return e=>n.format(e)})),relativetime:n(((e,t)=>{const n=new Intl.RelativeTimeFormat(e,d({},t));return e=>n.format(e,t.range||"day")})),list:n(((e,t)=>{const n=new Intl.ListFormat(e,d({},t));return e=>n.format(e)}))}}add(e,t){this.formats[e.toLowerCase().trim()]=t}addCached(e,t){this.formats[e.toLowerCase().trim()]=jB(t)}format(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const r=t.split(this.formatSeparator);if(r.length>1&&r[0].indexOf("(")>1&&r[0].indexOf(")")<0&&r.find((e=>e.indexOf(")")>-1))){const e=r.findIndex((e=>e.indexOf(")")>-1));r[0]=[r[0],...r.splice(1,e)].join(this.formatSeparator)}const o=r.reduce(((e,t)=>{const{formatName:r,formatOptions:o}=(e=>{let t=e.toLowerCase().trim();const n={};if(e.indexOf("(")>-1){const a=e.split("(");t=a[0].toLowerCase().trim();const r=a[1].substring(0,a[1].length-1);"currency"===t&&r.indexOf(":")<0?n.currency||(n.currency=r.trim()):"relativetime"===t&&r.indexOf(":")<0?n.range||(n.range=r.trim()):r.split(";").forEach((e=>{if(e){const[t,...a]=e.split(":"),r=a.join(":").trim().replace(/^'+|'+$/g,""),o=t.trim();n[o]||(n[o]=r),"false"===r&&(n[o]=!1),"true"===r&&(n[o]=!0),isNaN(r)||(n[o]=parseInt(r,10))}}))}return{formatName:t,formatOptions:n}})(t);if(this.formats[r]){let t=e;try{var s;const i=(null===a||void 0===a||null===(s=a.formatParams)||void 0===s?void 0:s[a.interpolationkey])||{},l=i.locale||i.lng||a.locale||a.lng||n;t=this.formats[r](e,l,d(d(d({},o),a),i))}catch(i){this.logger.warn(i)}return t}return this.logger.warn("there was no format function for ".concat(r)),e}),e);return o}}class qB extends FB{constructor(e,t,n){var a,r;let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(),this.backend=e,this.store=t,this.services=n,this.languageUtils=n.languageUtils,this.options=o,this.logger=AB.create("backendConnector"),this.waitingReads=[],this.maxParallelReads=o.maxParallelReads||10,this.readingCalls=0,this.maxRetries=o.maxRetries>=0?o.maxRetries:5,this.retryTimeout=o.retryTimeout>=1?o.retryTimeout:350,this.state={},this.queue=[],null===(a=this.backend)||void 0===a||null===(r=a.init)||void 0===r||r.call(a,n,o.backend,o)}queueLoad(e,t,n,a){const r={},o={},s={},i={};return e.forEach((e=>{let a=!0;t.forEach((t=>{const s="".concat(e,"|").concat(t);!n.reload&&this.store.hasResourceBundle(e,t)?this.state[s]=2:this.state[s]<0||(1===this.state[s]?void 0===o[s]&&(o[s]=!0):(this.state[s]=1,a=!1,void 0===o[s]&&(o[s]=!0),void 0===r[s]&&(r[s]=!0),void 0===i[t]&&(i[t]=!0)))})),a||(s[e]=!0)})),(Object.keys(r).length||Object.keys(o).length)&&this.queue.push({pending:o,pendingCount:Object.keys(o).length,loaded:{},errors:[],callback:a}),{toLoad:Object.keys(r),pending:Object.keys(o),toLoadLanguages:Object.keys(s),toLoadNamespaces:Object.keys(i)}}loaded(e,t,n){const a=e.split("|"),r=a[0],o=a[1];t&&this.emit("failedLoading",r,o,t),!t&&n&&this.store.addResourceBundle(r,o,n,void 0,void 0,{skipCopy:!0}),this.state[e]=t?-1:2,t&&n&&(this.state[e]=0);const s={};this.queue.forEach((n=>{((e,t,n)=>{const{obj:a,k:r}=bB(e,t,Object);a[r]=a[r]||[],a[r].push(n)})(n.loaded,[r],o),((e,t)=>{void 0!==e.pending[t]&&(delete e.pending[t],e.pendingCount--)})(n,e),t&&n.errors.push(t),0!==n.pendingCount||n.done||(Object.keys(n.loaded).forEach((e=>{s[e]||(s[e]={});const t=n.loaded[e];t.length&&t.forEach((t=>{void 0===s[e][t]&&(s[e][t]=!0)}))})),n.done=!0,n.errors.length?n.callback(n.errors):n.callback())})),this.emit("loaded",s),this.queue=this.queue.filter((e=>!e.done))}read(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:this.retryTimeout,o=arguments.length>5?arguments[5]:void 0;if(!e.length)return o(null,{});if(this.readingCalls>=this.maxParallelReads)return void this.waitingReads.push({lng:e,ns:t,fcName:n,tried:a,wait:r,callback:o});this.readingCalls++;const s=(s,i)=>{if(this.readingCalls--,this.waitingReads.length>0){const e=this.waitingReads.shift();this.read(e.lng,e.ns,e.fcName,e.tried,e.wait,e.callback)}s&&i&&a<this.maxRetries?setTimeout((()=>{this.read.call(this,e,t,n,a+1,2*r,o)}),r):o(s,i)},i=this.backend[n].bind(this.backend);if(2!==i.length)return i(e,t,s);try{const n=i(e,t);n&&"function"===typeof n.then?n.then((e=>s(null,e))).catch(s):s(null,n)}catch(CW){s(CW)}}prepareLoading(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3?arguments[3]:void 0;if(!this.backend)return this.logger.warn("No backend was added via i18next.use. Will not load resources."),a&&a();hB(e)&&(e=this.languageUtils.toResolveHierarchy(e)),hB(t)&&(t=[t]);const r=this.queueLoad(e,t,n,a);if(!r.toLoad.length)return r.pending.length||a(),null;r.toLoad.forEach((e=>{this.loadOne(e)}))}load(e,t,n){this.prepareLoading(e,t,{},n)}reload(e,t,n){this.prepareLoading(e,t,{reload:!0},n)}loadOne(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";const n=e.split("|"),a=n[0],r=n[1];this.read(a,r,"read",void 0,void 0,((n,o)=>{n&&this.logger.warn("".concat(t,"loading namespace ").concat(r," for language ").concat(a," failed"),n),!n&&o&&this.logger.log("".concat(t,"loaded namespace ").concat(r," for language ").concat(a),o),this.loaded(e,n,o)}))}saveMissing(e,t,n,a,r){var o,s,i;let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{},c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:()=>{};if(null===(o=this.services)||void 0===o||null===(o=o.utils)||void 0===o||!o.hasLoadedNamespace||null!==(s=this.services)&&void 0!==s&&null!==(s=s.utils)&&void 0!==s&&s.hasLoadedNamespace(t)){if(void 0!==n&&null!==n&&""!==n){if(null!==(i=this.backend)&&void 0!==i&&i.create){const o=d(d({},l),{},{isUpdate:r}),s=this.backend.create.bind(this.backend);if(s.length<6)try{let r;r=5===s.length?s(e,t,n,a,o):s(e,t,n,a),r&&"function"===typeof r.then?r.then((e=>c(null,e))).catch(c):c(null,r)}catch(CW){c(CW)}else s(e,t,n,a,c,o)}e&&e[0]&&this.store.addResource(e[0],t,n,a)}}else this.logger.warn('did not save key "'.concat(n,'" as the namespace "').concat(t,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")}}const XB=()=>({debug:!1,initAsync:!0,ns:["translation"],defaultNS:["translation"],fallbackLng:["dev"],fallbackNS:!1,supportedLngs:!1,nonExplicitSupportedLngs:!1,load:"all",preload:!1,simplifyPluralSuffix:!0,keySeparator:".",nsSeparator:":",pluralSeparator:"_",contextSeparator:"_",partialBundledLanguages:!1,saveMissing:!1,updateMissing:!1,saveMissingTo:"fallback",saveMissingPlurals:!0,missingKeyHandler:!1,missingInterpolationHandler:!1,postProcess:!1,postProcessPassResolved:!1,returnNull:!1,returnEmptyString:!0,returnObjects:!1,joinArrays:!1,returnedObjectHandler:!1,parseMissingKeyHandler:!1,appendNamespaceToMissingKey:!1,appendNamespaceToCIMode:!1,overloadTranslationOptionHandler:e=>{let t={};if("object"===typeof e[1]&&(t=e[1]),hB(e[1])&&(t.defaultValue=e[1]),hB(e[2])&&(t.tDescription=e[2]),"object"===typeof e[2]||"object"===typeof e[3]){const n=e[3]||e[2];Object.keys(n).forEach((e=>{t[e]=n[e]}))}return t},interpolation:{escapeValue:!0,format:e=>e,prefix:"{{",suffix:"}}",formatSeparator:",",unescapePrefix:"-",nestingPrefix:"$t(",nestingSuffix:")",nestingOptionsSeparator:",",maxReplaces:1e3,skipOnVariables:!0},cacheInBuiltFormats:!0}),YB=e=>{var t,n;return hB(e.ns)&&(e.ns=[e.ns]),hB(e.fallbackLng)&&(e.fallbackLng=[e.fallbackLng]),hB(e.fallbackNS)&&(e.fallbackNS=[e.fallbackNS]),(null===(t=e.supportedLngs)||void 0===t||null===(n=t.indexOf)||void 0===n?void 0:n.call(t,"cimode"))<0&&(e.supportedLngs=e.supportedLngs.concat(["cimode"])),"boolean"===typeof e.initImmediate&&(e.initAsync=e.initImmediate),e},JB=()=>{};class $B extends FB{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;var n;if(super(),this.options=YB(e),this.services={},this.logger=AB,this.modules={external:[]},n=this,Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach((e=>{"function"===typeof n[e]&&(n[e]=n[e].bind(n))})),t&&!this.isInitialized&&!e.isClone){if(!this.options.initAsync)return this.init(e,t),this;setTimeout((()=>{this.init(e,t)}),0)}}init(){var e=this;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;this.isInitializing=!0,"function"===typeof t&&(n=t,t={}),null==t.defaultNS&&t.ns&&(hB(t.ns)?t.defaultNS=t.ns:t.ns.indexOf("translation")<0&&(t.defaultNS=t.ns[0]));const a=XB();this.options=d(d(d({},a),this.options),YB(t)),this.options.interpolation=d(d({},a.interpolation),this.options.interpolation),void 0!==t.keySeparator&&(this.options.userDefinedKeySeparator=t.keySeparator),void 0!==t.nsSeparator&&(this.options.userDefinedNsSeparator=t.nsSeparator);const r=e=>e?"function"===typeof e?new e:e:null;if(!this.options.isClone){let t;this.modules.logger?AB.init(r(this.modules.logger),this.options):AB.init(null,this.options),t=this.modules.formatter?this.modules.formatter:KB;const n=new MB(this.options);this.store=new DB(this.options.resources,this.options);const o=this.services;o.logger=AB,o.resourceStore=this.store,o.languageUtils=n,o.pluralResolver=new WB(n,{prepend:this.options.pluralSeparator,simplifyPluralSuffix:this.options.simplifyPluralSuffix}),!t||this.options.interpolation.format&&this.options.interpolation.format!==a.interpolation.format||(o.formatter=r(t),o.formatter.init(o,this.options),this.options.interpolation.format=o.formatter.format.bind(o.formatter)),o.interpolator=new GB(this.options),o.utils={hasLoadedNamespace:this.hasLoadedNamespace.bind(this)},o.backendConnector=new qB(r(this.modules.backend),o.resourceStore,o,this.options),o.backendConnector.on("*",(function(t){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];e.emit(t,...a)})),this.modules.languageDetector&&(o.languageDetector=r(this.modules.languageDetector),o.languageDetector.init&&o.languageDetector.init(o,this.options.detection,this.options)),this.modules.i18nFormat&&(o.i18nFormat=r(this.modules.i18nFormat),o.i18nFormat.init&&o.i18nFormat.init(this)),this.translator=new zB(this.services,this.options),this.translator.on("*",(function(t){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];e.emit(t,...a)})),this.modules.external.forEach((e=>{e.init&&e.init(this)}))}if(this.format=this.options.interpolation.format,n||(n=JB),this.options.fallbackLng&&!this.services.languageDetector&&!this.options.lng){const e=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);e.length>0&&"dev"!==e[0]&&(this.options.lng=e[0])}this.services.languageDetector||this.options.lng||this.logger.warn("init: no languageDetector is used and no lng is defined");["getResource","hasResourceBundle","getResourceBundle","getDataByLanguage"].forEach((t=>{this[t]=function(){return e.store[t](...arguments)}}));["addResource","addResources","addResourceBundle","removeResourceBundle"].forEach((t=>{this[t]=function(){return e.store[t](...arguments),e}}));const o=dB(),s=()=>{const e=(e,t)=>{this.isInitializing=!1,this.isInitialized&&!this.initializedStoreOnce&&this.logger.warn("init: i18next is already initialized. You should call init just once!"),this.isInitialized=!0,this.options.isClone||this.logger.log("initialized",this.options),this.emit("initialized",this.options),o.resolve(t),n(e,t)};if(this.languages&&!this.isInitialized)return e(null,this.t.bind(this));this.changeLanguage(this.options.lng,e)};return this.options.resources||!this.options.initAsync?s():setTimeout(s,0),o}loadResources(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:JB;const n=hB(e)?e:this.language;if("function"===typeof e&&(t=e),!this.options.resources||this.options.partialBundledLanguages){var a,r;if("cimode"===(null===n||void 0===n?void 0:n.toLowerCase())&&(!this.options.preload||0===this.options.preload.length))return t();const e=[],o=t=>{if(!t)return;if("cimode"===t)return;this.services.languageUtils.toResolveHierarchy(t).forEach((t=>{"cimode"!==t&&e.indexOf(t)<0&&e.push(t)}))};if(n)o(n);else{this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((e=>o(e)))}null===(a=this.options.preload)||void 0===a||null===(r=a.forEach)||void 0===r||r.call(a,(e=>o(e))),this.services.backendConnector.load(e,this.options.ns,(e=>{e||this.resolvedLanguage||!this.language||this.setResolvedLanguage(this.language),t(e)}))}else t(null)}reloadResources(e,t,n){const a=dB();return"function"===typeof e&&(n=e,e=void 0),"function"===typeof t&&(n=t,t=void 0),e||(e=this.languages),t||(t=this.options.ns),n||(n=JB),this.services.backendConnector.reload(e,t,(e=>{a.resolve(),n(e)})),a}use(e){if(!e)throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");if(!e.type)throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");return"backend"===e.type&&(this.modules.backend=e),("logger"===e.type||e.log&&e.warn&&e.error)&&(this.modules.logger=e),"languageDetector"===e.type&&(this.modules.languageDetector=e),"i18nFormat"===e.type&&(this.modules.i18nFormat=e),"postProcessor"===e.type&&_B.addPostProcessor(e),"formatter"===e.type&&(this.modules.formatter=e),"3rdParty"===e.type&&this.modules.external.push(e),this}setResolvedLanguage(e){if(e&&this.languages&&!(["cimode","dev"].indexOf(e)>-1)){for(let e=0;e<this.languages.length;e++){const t=this.languages[e];if(!(["cimode","dev"].indexOf(t)>-1)&&this.store.hasLanguageSomeTranslations(t)){this.resolvedLanguage=t;break}}!this.resolvedLanguage&&this.languages.indexOf(e)<0&&this.store.hasLanguageSomeTranslations(e)&&(this.resolvedLanguage=e,this.languages.unshift(e))}}changeLanguage(e,t){var n=this;this.isLanguageChangingTo=e;const a=dB();this.emit("languageChanging",e);const r=e=>{this.language=e,this.languages=this.services.languageUtils.toResolveHierarchy(e),this.resolvedLanguage=void 0,this.setResolvedLanguage(e)},o=(o,s)=>{s?this.isLanguageChangingTo===e&&(r(s),this.translator.changeLanguage(s),this.isLanguageChangingTo=void 0,this.emit("languageChanged",s),this.logger.log("languageChanged",s)):this.isLanguageChangingTo=void 0,a.resolve((function(){return n.t(...arguments)})),t&&t(o,(function(){return n.t(...arguments)}))},s=t=>{e||t||!this.services.languageDetector||(t=[]);const n=hB(t)?t:t&&t[0],a=this.store.hasLanguageSomeTranslations(n)?n:this.services.languageUtils.getBestMatchFromCodes(hB(t)?[t]:t);var s,i;a&&(this.language||r(a),this.translator.language||this.translator.changeLanguage(a),null===(s=this.services.languageDetector)||void 0===s||null===(i=s.cacheUserLanguage)||void 0===i||i.call(s,a));this.loadResources(a,(e=>{o(e,a)}))};return e||!this.services.languageDetector||this.services.languageDetector.async?!e&&this.services.languageDetector&&this.services.languageDetector.async?0===this.services.languageDetector.detect.length?this.services.languageDetector.detect().then(s):this.services.languageDetector.detect(s):s(e):s(this.services.languageDetector.detect()),a}getFixedT(e,t,n){var a=this;const r=function(e,t){let o;if("object"!==typeof t){for(var s=arguments.length,i=new Array(s>2?s-2:0),l=2;l<s;l++)i[l-2]=arguments[l];o=a.options.overloadTranslationOptionHandler([e,t].concat(i))}else o=d({},t);o.lng=o.lng||r.lng,o.lngs=o.lngs||r.lngs,o.ns=o.ns||r.ns,""!==o.keyPrefix&&(o.keyPrefix=o.keyPrefix||n||r.keyPrefix);const c=a.options.keySeparator||".";let u;return u=o.keyPrefix&&Array.isArray(e)?e.map((e=>"".concat(o.keyPrefix).concat(c).concat(e))):o.keyPrefix?"".concat(o.keyPrefix).concat(c).concat(e):e,a.t(u,o)};return hB(e)?r.lng=e:r.lngs=e,r.ns=t,r.keyPrefix=n,r}t(){for(var e,t=arguments.length,n=new Array(t),a=0;a<t;a++)n[a]=arguments[a];return null===(e=this.translator)||void 0===e?void 0:e.translate(...n)}exists(){for(var e,t=arguments.length,n=new Array(t),a=0;a<t;a++)n[a]=arguments[a];return null===(e=this.translator)||void 0===e?void 0:e.exists(...n)}setDefaultNamespace(e){this.options.defaultNS=e}hasLoadedNamespace(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isInitialized)return this.logger.warn("hasLoadedNamespace: i18next was not initialized",this.languages),!1;if(!this.languages||!this.languages.length)return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty",this.languages),!1;const n=t.lng||this.resolvedLanguage||this.languages[0],a=!!this.options&&this.options.fallbackLng,r=this.languages[this.languages.length-1];if("cimode"===n.toLowerCase())return!0;const o=(e,t)=>{const n=this.services.backendConnector.state["".concat(e,"|").concat(t)];return-1===n||0===n||2===n};if(t.precheck){const e=t.precheck(this,o);if(void 0!==e)return e}return!!this.hasResourceBundle(n,e)||(!(this.services.backendConnector.backend&&(!this.options.resources||this.options.partialBundledLanguages))||!(!o(n,e)||a&&!o(r,e)))}loadNamespaces(e,t){const n=dB();return this.options.ns?(hB(e)&&(e=[e]),e.forEach((e=>{this.options.ns.indexOf(e)<0&&this.options.ns.push(e)})),this.loadResources((e=>{n.resolve(),t&&t(e)})),n):(t&&t(),Promise.resolve())}loadLanguages(e,t){const n=dB();hB(e)&&(e=[e]);const a=this.options.preload||[],r=e.filter((e=>a.indexOf(e)<0&&this.services.languageUtils.isSupportedCode(e)));return r.length?(this.options.preload=a.concat(r),this.loadResources((e=>{n.resolve(),t&&t(e)})),n):(t&&t(),Promise.resolve())}dir(e){var t,n;if(e||(e=this.resolvedLanguage||((null===(t=this.languages)||void 0===t?void 0:t.length)>0?this.languages[0]:this.language)),!e)return"rtl";const a=(null===(n=this.services)||void 0===n?void 0:n.languageUtils)||new MB(XB());return["ar","shu","sqr","ssh","xaa","yhd","yud","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","afb","ajp","apc","apd","arb","arq","ars","ary","arz","auz","avl","ayh","ayl","ayn","ayp","bbz","pga","he","iw","ps","pbt","pbu","pst","prp","prd","ug","ur","ydd","yds","yih","ji","yi","hbo","men","xmn","fa","jpr","peo","pes","prs","dv","sam","ckb"].indexOf(a.getLanguagePartFromCode(e))>-1||e.toLowerCase().indexOf("-arab")>1?"rtl":"ltr"}static createInstance(){return new $B(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},arguments.length>1?arguments[1]:void 0)}cloneInstance(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:JB;const n=e.forkResourceStore;n&&delete e.forkResourceStore;const a=d(d(d({},this.options),e),{isClone:!0}),r=new $B(a);void 0===e.debug&&void 0===e.prefix||(r.logger=r.logger.clone(e));if(["store","services","language"].forEach((e=>{r[e]=this[e]})),r.services=d({},this.services),r.services.utils={hasLoadedNamespace:r.hasLoadedNamespace.bind(r)},n){const e=Object.keys(this.store.data).reduce(((e,t)=>(e[t]=d({},this.store.data[t]),e[t]=Object.keys(e[t]).reduce(((n,a)=>(n[a]=d({},e[t][a]),n)),e[t]),e)),{});r.store=new DB(e,a),r.services.resourceStore=r.store}return r.translator=new zB(r.services,a),r.translator.on("*",(function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];r.emit(e,...n)})),r.init(a,t),r.translator.options=a,r.translator.backendConnector.services.utils={hasLoadedNamespace:r.hasLoadedNamespace.bind(r)},r}toJSON(){return{options:this.options,store:this.store,language:this.language,languages:this.languages,resolvedLanguage:this.resolvedLanguage}}}const QB=$B.createInstance();QB.createInstance=$B.createInstance;QB.createInstance,QB.dir,QB.init,QB.loadResources,QB.reloadResources,QB.use,QB.changeLanguage,QB.getFixedT,QB.t,QB.exists,QB.setDefaultNamespace,QB.hasLoadedNamespace,QB.loadNamespaces,QB.loadLanguages;const{slice:ZB,forEach:eW}=[];const tW=/^[\u0009\u0020-\u007e\u0080-\u00ff]+$/,nW={create(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{path:"/",sameSite:"strict"};n&&(r.expires=new Date,r.expires.setTime(r.expires.getTime()+60*n*1e3)),a&&(r.domain=a),document.cookie=function(e,t){const n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{path:"/"},a=encodeURIComponent(t);let r="".concat(e,"=").concat(a);if(n.maxAge>0){const e=n.maxAge-0;if(Number.isNaN(e))throw new Error("maxAge should be a Number");r+="; Max-Age=".concat(Math.floor(e))}if(n.domain){if(!tW.test(n.domain))throw new TypeError("option domain is invalid");r+="; Domain=".concat(n.domain)}if(n.path){if(!tW.test(n.path))throw new TypeError("option path is invalid");r+="; Path=".concat(n.path)}if(n.expires){if("function"!==typeof n.expires.toUTCString)throw new TypeError("option expires is invalid");r+="; Expires=".concat(n.expires.toUTCString())}if(n.httpOnly&&(r+="; HttpOnly"),n.secure&&(r+="; Secure"),n.sameSite)switch("string"===typeof n.sameSite?n.sameSite.toLowerCase():n.sameSite){case!0:r+="; SameSite=Strict";break;case"lax":r+="; SameSite=Lax";break;case"strict":r+="; SameSite=Strict";break;case"none":r+="; SameSite=None";break;default:throw new TypeError("option sameSite is invalid")}return n.partitioned&&(r+="; Partitioned"),r}(e,t,r)},read(e){const t="".concat(e,"="),n=document.cookie.split(";");for(let a=0;a<n.length;a++){let e=n[a];for(;" "===e.charAt(0);)e=e.substring(1,e.length);if(0===e.indexOf(t))return e.substring(t.length,e.length)}return null},remove(e,t){this.create(e,"",-1,t)}};var aW={name:"cookie",lookup(e){let{lookupCookie:t}=e;if(t&&"undefined"!==typeof document)return nW.read(t)||void 0},cacheUserLanguage(e,t){let{lookupCookie:n,cookieMinutes:a,cookieDomain:r,cookieOptions:o}=t;n&&"undefined"!==typeof document&&nW.create(n,e,a,r,o)}},rW={name:"querystring",lookup(e){let t,{lookupQuerystring:n}=e;if("undefined"!==typeof window){var a;let{search:e}=window.location;!window.location.search&&(null===(a=window.location.hash)||void 0===a?void 0:a.indexOf("?"))>-1&&(e=window.location.hash.substring(window.location.hash.indexOf("?")));const r=e.substring(1).split("&");for(let a=0;a<r.length;a++){const e=r[a].indexOf("=");if(e>0){r[a].substring(0,e)===n&&(t=r[a].substring(e+1))}}}return t}},oW={name:"hash",lookup(e){let t,{lookupHash:n,lookupFromHashIndex:a}=e;if("undefined"!==typeof window){const{hash:e}=window.location;if(e&&e.length>2){const o=e.substring(1);if(n){const e=o.split("&");for(let a=0;a<e.length;a++){const r=e[a].indexOf("=");if(r>0){e[a].substring(0,r)===n&&(t=e[a].substring(r+1))}}}if(t)return t;if(!t&&a>-1){var r;const t=e.match(/\/([a-zA-Z-]*)/g);if(!Array.isArray(t))return;return null===(r=t["number"===typeof a?a:0])||void 0===r?void 0:r.replace("/","")}}}return t}};let sW=null;const iW=()=>{if(null!==sW)return sW;try{if(sW="undefined"!==typeof window&&null!==window.localStorage,!sW)return!1;const e="i18next.translate.boo";window.localStorage.setItem(e,"foo"),window.localStorage.removeItem(e)}catch(IW){sW=!1}return sW};var lW={name:"localStorage",lookup(e){let{lookupLocalStorage:t}=e;if(t&&iW())return window.localStorage.getItem(t)||void 0},cacheUserLanguage(e,t){let{lookupLocalStorage:n}=t;n&&iW()&&window.localStorage.setItem(n,e)}};let cW=null;const uW=()=>{if(null!==cW)return cW;try{if(cW="undefined"!==typeof window&&null!==window.sessionStorage,!cW)return!1;const e="i18next.translate.boo";window.sessionStorage.setItem(e,"foo"),window.sessionStorage.removeItem(e)}catch(IW){cW=!1}return cW};var hW={name:"sessionStorage",lookup(e){let{lookupSessionStorage:t}=e;if(t&&uW())return window.sessionStorage.getItem(t)||void 0},cacheUserLanguage(e,t){let{lookupSessionStorage:n}=t;n&&uW()&&window.sessionStorage.setItem(n,e)}},dW={name:"navigator",lookup(e){const t=[];if("undefined"!==typeof navigator){const{languages:e,userLanguage:n,language:a}=navigator;if(e)for(let r=0;r<e.length;r++)t.push(e[r]);n&&t.push(n),a&&t.push(a)}return t.length>0?t:void 0}},pW={name:"htmlTag",lookup(e){let t,{htmlTag:n}=e;const a=n||("undefined"!==typeof document?document.documentElement:null);return a&&"function"===typeof a.getAttribute&&(t=a.getAttribute("lang")),t}},fW={name:"path",lookup(e){var t;let{lookupFromPathIndex:n}=e;if("undefined"===typeof window)return;const a=window.location.pathname.match(/\/([a-zA-Z-]*)/g);if(!Array.isArray(a))return;return null===(t=a["number"===typeof n?n:0])||void 0===t?void 0:t.replace("/","")}},gW={name:"subdomain",lookup(e){var t;let{lookupFromSubdomainIndex:n}=e;const a="number"===typeof n?n+1:1,r="undefined"!==typeof window&&(null===(t=window.location)||void 0===t||null===(t=t.hostname)||void 0===t?void 0:t.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i));if(r)return r[a]}};let mW=!1;try{document.cookie,mW=!0}catch(IW){}const bW=["querystring","cookie","localStorage","sessionStorage","navigator","htmlTag"];mW||bW.splice(1,1);class yW{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.type="languageDetector",this.detectors={},this.init(e,t)}init(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{languageUtils:{}},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.services=e,this.options=function(e){return eW.call(ZB.call(arguments,1),(t=>{if(t)for(const n in t)void 0===e[n]&&(e[n]=t[n])})),e}(t,this.options||{},{order:bW,lookupQuerystring:"lng",lookupCookie:"i18next",lookupLocalStorage:"i18nextLng",lookupSessionStorage:"i18nextLng",caches:["localStorage"],excludeCacheFor:["cimode"],convertDetectedLanguage:e=>e}),"string"===typeof this.options.convertDetectedLanguage&&this.options.convertDetectedLanguage.indexOf("15897")>-1&&(this.options.convertDetectedLanguage=e=>e.replace("-","_")),this.options.lookupFromUrlIndex&&(this.options.lookupFromPathIndex=this.options.lookupFromUrlIndex),this.i18nOptions=n,this.addDetector(aW),this.addDetector(rW),this.addDetector(lW),this.addDetector(hW),this.addDetector(dW),this.addDetector(pW),this.addDetector(fW),this.addDetector(gW),this.addDetector(oW)}addDetector(e){return this.detectors[e.name]=e,this}detect(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.order,t=[];return e.forEach((e=>{if(this.detectors[e]){let n=this.detectors[e].lookup(this.options);n&&"string"===typeof n&&(n=[n]),n&&(t=t.concat(n))}})),t=t.filter((e=>void 0!==e&&null!==e&&!function(e){return"string"===typeof e&&[/<\s*script.*?>/i,/<\s*\/\s*script\s*>/i,/<\s*img.*?on\w+\s*=/i,/<\s*\w+\s*on\w+\s*=.*?>/i,/javascript\s*:/i,/vbscript\s*:/i,/expression\s*\(/i,/eval\s*\(/i,/alert\s*\(/i,/document\.cookie/i,/document\.write\s*\(/i,/window\.location/i,/innerHTML/i].some((t=>t.test(e)))}(e))).map((e=>this.options.convertDetectedLanguage(e))),this.services&&this.services.languageUtils&&this.services.languageUtils.getBestMatchFromCodes?t:t.length>0?t[0]:null}cacheUserLanguage(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.caches;t&&(this.options.excludeCacheFor&&this.options.excludeCacheFor.indexOf(e)>-1||t.forEach((t=>{this.detectors[t]&&this.detectors[t].cacheUserLanguage(e,this.options)})))}}yW.type="languageDetector";const vW={en:{translation:JSON.parse('{"TheCurrentLanguage":"English","home":{"title":"Advanced Medical Imaging Analysis","subtitle":"AI-powered diagnostic tools for accurate and fast medical imaging interpretation","chooseMethod":"Choose Analysis Method","chooseSubtitle":"Select the imaging modality you need to analyze","ctScan":{"title":"CT Scan","description":"Detailed cross-sectional imaging evaluation with 3D reconstruction capabilities","button":"Select CT Scan"},"xray":{"title":"X-ray","description":"Comprehensive bone and soft tissue structure assessment","button":"Select X-ray"}},"classifier":{"title":"PulmoDX AI","tagline":"Advanced Lung Cancer Analysis Powered by AI | Machine Learning","uploadTitle":"Upload Lung Image for Analysis","uploadSubtitle":"Get instant AI-powered assessment of your lung condition","selectImage":"Select Image","fileTypes":"Supports JPEG, PNG","analyze":"Analyze Now","analyzing":"Analyzing...","results":{"title":"Analysis Result","confidence":"Confidence","normal":"Normal","benign":"Benign","malignant":"Malignant","findClinics":"Find Nearest Pulmonologists Clinic","findingClinics":"Finding Nearby Clinics...","locationDisclaimer":"We\'ll use your device\'s location to find clinics near you","searchingNear":"Searching near:","recommendedClinics":"Recommended Pulmonologists Clinics","foundNearby":"Found nearby","refreshResults":"Refresh Results","ShowLocatinoPrompet":"The response must include only a list of 3 pulmonologists clinics or hospitals near ${address} (coordinates: ${location.lat}, ${location.lng}) that specialize in lung cancer conditions. For each, include: 1. Name of the facility .2. Approximate distance from the location .3. Phone number .4. Brief note about services offered .Format the response as a clear list with each item separated by 2 line breaks. Use clean, consistent formatting."},"errors":{"invalidImage":"Please upload an image file (JPEG, PNG)","imageError":"Error reading image file","classificationError":"Error classifying image. Please try a different image.","locationDenied":"Location access denied. Please enable location services or enter your location manually.","locationUnavailable":"Location unavailable. Please check your connection or enter your location manually.","locationTimeout":"Location request timed out. Please try again or enter your location manually.","hospitalError":"Error finding nearby hospitals."},"header":{"home":"Home","about":"About","contact":"Contact"},"language":{"change":"Change language"}}}')},es:{translation:JSON.parse('{"TheCurrentLanguage":"Spanish","home":{"title":"An\xe1lisis Avanzado de Im\xe1genes M\xe9dicas","subtitle":"Herramientas de diagn\xf3stico con IA para interpretaci\xf3n precisa y r\xe1pida de im\xe1genes m\xe9dicas","chooseMethod":"Seleccione M\xe9todo de An\xe1lisis","chooseSubtitle":"Seleccione la modalidad de imagen que necesita analizar","ctScan":{"title":"Tomograf\xeda Computarizada","description":"Evaluaci\xf3n detallada de im\xe1genes transversales con capacidades de reconstrucci\xf3n 3D","button":"Seleccionar TC"},"xray":{"title":"Radiograf\xeda","description":"Evaluaci\xf3n integral de la estructura \xf3sea y de tejidos blandos","button":"Seleccionar Radiograf\xeda"}},"classifier":{"title":"PulmoDX IA","tagline":"An\xe1lisis Avanzado de C\xe1ncer de Pulm\xf3n con IA | Aprendizaje Autom\xe1tico","uploadTitle":"Subir Imagen Pulmonar para An\xe1lisis","uploadSubtitle":"Obtenga una evaluaci\xf3n instant\xe1nea basada en IA de su condici\xf3n pulmonar","selectImage":"Seleccionar Imagen","fileTypes":"Soporta JPEG, PNG","analyze":"Analizar Ahora","analyzing":"Analizando...","results":{"title":"Resultado del An\xe1lisis","confidence":"Confianza","normal":"Normal","benign":"Benigno","malignant":"Maligno","findClinics":"Encontrar Cl\xednica de Neum\xf3logos M\xe1s Cercana","findingClinics":"Buscando Cl\xednicas Cercanas...","locationDisclaimer":"Usaremos la ubicaci\xf3n de su dispositivo para encontrar cl\xednicas cerca de usted","searchingNear":"Buscando cerca de:","recommendedClinics":"Cl\xednicas de Neum\xf3logos Recomendadas","foundNearby":"Encontradas cerca","refreshResults":"Actualizar Resultados","ShowLocatinoPrompet":"The response must include only a list of 3 pulmonologists clinics or hospitals near the location in the end of this prompet that specialize in lung cancer conditions. For each, include: 1. Name of the facility .2. Approximate distance from the location .3. Phone number .4. Brief note about services offered .Format the response as a clear list with each item separated by 2 line breaks. Use clean, consistent formatting."},"errors":{"invalidImage":"Por favor suba un archivo de imagen (JPEG, PNG)","imageError":"Error al leer el archivo de imagen","classificationError":"Error al clasificar la imagen. Por favor intente con una imagen diferente.","locationDenied":"Acceso a ubicaci\xf3n denegado. Por favor active los servicios de ubicaci\xf3n o ingrese su ubicaci\xf3n manualmente.","locationUnavailable":"Ubicaci\xf3n no disponible. Por favor verifique su conexi\xf3n o ingrese su ubicaci\xf3n manualmente.","locationTimeout":"Tiempo de espera agotado. Por favor intente nuevamente o ingrese su ubicaci\xf3n manualmente.","hospitalError":"Error al buscar hospitales cercanos."},"header":{"home":"Inicio","about":"Acerca de","contact":"Contacto"},"language":{"change":"Cambiar idioma"}}}')},ar:{translation:JSON.parse('{"TheCurrentLanguage":"\u0627\u0644\u0639\u0631\u0628\u064a\u064e\u0651\u0629","home":{"title":"\u062a\u062d\u0644\u064a\u0644\u064f \u0627\u0644\u0635\u0648\u0631\u0650 \u0627\u0644\u0637\u0628\u064a\u064e\u0651\u0629\u0650 \u0627\u0644\u0645\u064f\u062a\u0642\u062f\u0650\u0651\u0645","subtitle":"\u0623\u062f\u0648\u0627\u062a\u064f \u062a\u0634\u062e\u064a\u0635\u064d \u0645\u062f\u0639\u0648\u0645\u0629\u064c \u0628\u0627\u0644\u0630\u064e\u0651\u0643\u0627\u0621\u0650 \u0627\u0644\u0627\u0635\u0637\u0646\u0627\u0639\u064a\u0650\u0651 \u0644\u062a\u0641\u0633\u064a\u0631\u064d \u062f\u0642\u064a\u0642\u064d \u0648\u0633\u0631\u064a\u0639\u064d \u0644\u0644\u0635\u0648\u0631\u0650 \u0627\u0644\u0637\u0628\u064a\u064e\u0651\u0629\u0650","chooseMethod":"\u0627\u062e\u062a\u0631\u0652 \u0637\u0631\u064a\u0642\u0629\u064e \u0627\u0644\u062a\u064e\u0651\u062d\u0644\u064a\u0644\u0650","chooseSubtitle":"\u062d\u062f\u0650\u0651\u062f\u0652 \u0646\u0648\u0639\u064e \u0627\u0644\u062a\u064e\u0651\u0635\u0648\u064a\u0631\u0650 \u0627\u0644\u0637\u0628\u064a\u0650\u0651 \u0627\u0644\u064e\u0651\u0630\u064a \u062a\u0631\u063a\u0628\u064f \u0641\u064a \u062a\u062d\u0644\u064a\u0644\u0650\u0647\u0650","ctScan":{"title":"\u0627\u0644\u0623\u0634\u0639\u064e\u0651\u0629\u064f \u0627\u0644\u0645\u0642\u0637\u0639\u064a\u064e\u0651\u0629\u064f","description":"\u062a\u0642\u064a\u064a\u0645\u064c \u062a\u0641\u0635\u064a\u0644\u064a\u064c\u0651 \u0644\u0644\u0635\u0648\u0631\u0650 \u0627\u0644\u0645\u0642\u0637\u0639\u064a\u064e\u0651\u0629\u0650 \u0645\u0639 \u0625\u0645\u0643\u0627\u0646\u064a\u064e\u0651\u0629\u0650 \u0627\u0644\u0625\u0639\u0627\u062f\u0629\u0650 \u062b\u0644\u0627\u062b\u064a\u064e\u0651\u0629\u0650 \u0627\u0644\u0623\u0628\u0639\u0627\u062f\u0650","button":"\u0627\u062e\u062a\u0631\u0650 \u0627\u0644\u0623\u0634\u0639\u064e\u0651\u0629\u064e \u0627\u0644\u0645\u0642\u0637\u0639\u064a\u064e\u0651\u0629\u064e"},"xray":{"title":"\u0627\u0644\u0623\u0634\u0639\u064e\u0651\u0629\u064f \u0627\u0644\u0633\u0650\u0651\u064a\u0646\u064a\u064e\u0651\u0629\u064f","description":"\u062a\u0642\u064a\u064a\u0645\u064c \u0634\u0627\u0645\u0644\u064c \u0644\u0644\u0639\u0638\u0627\u0645\u0650 \u0648\u0627\u0644\u0623\u0646\u0633\u062c\u0629\u0650 \u0627\u0644\u0631\u064e\u0651\u062e\u0648\u0629\u0650","button":"\u0627\u062e\u062a\u0631\u0650 \u0627\u0644\u0623\u0634\u0639\u064e\u0651\u0629\u064e \u0627\u0644\u0633\u0650\u0651\u064a\u0646\u064a\u064e\u0651\u0629\u064e"}},"classifier":{"title":"\u0646\u0638\u0627\u0645\u064f PulmoDX \u0627\u0644\u0630\u064e\u0651\u0643\u064a\u064f\u0651","tagline":"\u062a\u062d\u0644\u064a\u0644\u064c \u0645\u062a\u0642\u062f\u0650\u0651\u0645\u064c \u0644\u0633\u0631\u0637\u0627\u0646\u0650 \u0627\u0644\u0631\u0650\u0651\u0626\u0629\u0650 \u0645\u062f\u0639\u0648\u0645\u064c \u0628\u0627\u0644\u0630\u064e\u0651\u0643\u0627\u0621\u0650 \u0627\u0644\u0627\u0635\u0637\u0646\u0627\u0639\u064a\u0650\u0651 | \u062a\u0639\u0644\u064f\u0651\u0645\u064f \u0627\u0644\u0622\u0644\u0629\u0650","uploadTitle":"\u062d\u0645\u0650\u0651\u0644\u0652 \u0635\u0648\u0631\u0629\u064e \u0627\u0644\u0631\u0650\u0651\u0626\u0629\u0650 \u0645\u0646 \u0623\u062c\u0644\u0650 \u0627\u0644\u062a\u064e\u0651\u062d\u0644\u064a\u0644\u0650","uploadSubtitle":"\u0627\u062d\u0635\u0644\u0652 \u0639\u0644\u0649 \u062a\u0642\u064a\u064a\u0645\u064d \u0641\u0648\u0631\u064a\u064d\u0651 \u0644\u062d\u0627\u0644\u0629\u0650 \u0627\u0644\u0631\u0650\u0651\u0626\u0629\u0650 \u0628\u0627\u0633\u062a\u062e\u062f\u0627\u0645\u0650 \u0627\u0644\u0630\u064e\u0651\u0643\u0627\u0621\u0650 \u0627\u0644\u0627\u0635\u0637\u0646\u0627\u0639\u064a\u0650\u0651","selectImage":"\u0627\u062e\u062a\u0631\u0652 \u0635\u0648\u0631\u0629\u064b","fileTypes":"\u064a\u064e\u062f\u0639\u0645\u064f JPEG\u060c PNG","analyze":"\u062d\u0644\u0650\u0651\u0644\u0650 \u0627\u0644\u0622\u0646\u064e","analyzing":"\u062c\u0627\u0631\u064d \u0627\u0644\u062a\u064e\u0651\u062d\u0644\u064a\u0644\u064f...","results":{"title":"\u0646\u062a\u064a\u062c\u0629\u064f \u0627\u0644\u062a\u064e\u0651\u062d\u0644\u064a\u0644\u0650","confidence":"\u0646\u0633\u0628\u0629\u064f \u0627\u0644\u062b\u0650\u0651\u0642\u0629\u0650","normal":"\u0637\u0628\u064a\u0639\u064a\u064c\u0651","benign":"\u062d\u0645\u064a\u062f\u064c","malignant":"\u062e\u0628\u064a\u062b\u064c","findClinics":"\u0627\u0628\u062d\u062b\u0652 \u0639\u0646 \u0623\u0642\u0631\u0628\u0650 \u0639\u064a\u0627\u062f\u0629\u064d \u0644\u0623\u0645\u0631\u0627\u0636\u0650 \u0627\u0644\u0631\u0650\u0651\u0626\u0629\u0650","findingClinics":"\u062c\u0627\u0631\u064d \u0627\u0644\u0628\u062d\u062b\u064f \u0639\u0646 \u0627\u0644\u0639\u064a\u0627\u062f\u0627\u062a\u0650 \u0627\u0644\u0642\u0631\u064a\u0628\u0629\u0650...","locationDisclaimer":"\u0633\u0646\u0633\u062a\u062e\u062f\u0645\u064f \u0645\u0648\u0642\u0639\u064e \u062c\u0647\u0627\u0632\u0650\u0643\u064e \u0644\u0644\u0639\u062b\u0648\u0631\u0650 \u0639\u0644\u0649 \u0627\u0644\u0639\u064a\u0627\u062f\u0627\u062a\u0650 \u0627\u0644\u0642\u0631\u064a\u0628\u0629\u0650 \u0645\u0646\u0643\u064e","searchingNear":"\u064a\u064f\u062c\u0631\u0649 \u0627\u0644\u0628\u062d\u062b\u064f \u0628\u0627\u0644\u0642\u0631\u0628\u0650 \u0645\u0646:","recommendedClinics":"\u0627\u0644\u0639\u064a\u0627\u062f\u0627\u062a\u064f \u0627\u0644\u0645\u064f\u0648\u0635\u0649 \u0628\u0647\u0627 \u0644\u0623\u0645\u0631\u0627\u0636\u0650 \u0627\u0644\u0631\u0650\u0651\u0626\u0629\u0650","foundNearby":"\u062a\u0645\u064e\u0651 \u0627\u0644\u0639\u062b\u0648\u0631\u064f \u0639\u0644\u0649 \u0645\u0648\u0627\u0642\u0639\u064e \u0642\u0631\u064a\u0628\u0629\u064d","refreshResults":"\u062a\u062d\u062f\u064a\u062b\u064f \u0627\u0644\u0646\u064e\u0651\u062a\u0627\u0626\u062c\u0650","ShowLocatinoPrompet":"\u064a\u062c\u0628\u064f \u0623\u0646 \u062a\u062a\u0636\u0645\u064e\u0651\u0646\u064e \u0627\u0644\u0627\u0633\u062a\u062c\u0627\u0628\u0629\u064f \u0642\u0627\u0626\u0645\u0629\u064b \u0628\u062b\u0644\u0627\u062b\u0650 \u0639\u064a\u0627\u062f\u0627\u062a\u064d \u0623\u0648 \u0645\u0633\u062a\u0634\u0641\u064a\u0627\u062a\u064d \u0645\u062a\u062e\u0635\u0650\u0651\u0635\u0629\u064d \u0641\u064a \u0633\u0631\u0637\u0627\u0646\u0650 \u0627\u0644\u0631\u0650\u0651\u0626\u0629\u0650 \u0628\u0627\u0644\u0642\u0631\u0628\u0650 \u0645\u0646 ${address} (\u0627\u0644\u0625\u062d\u062f\u0627\u062b\u064a\u0627\u062a: ${location.lat}, ${location.lng})\u060c \u0648\u064a\u062c\u0628\u064f \u0623\u0646 \u062a\u062a\u0636\u0645\u064e\u0651\u0646\u064e: \u0661. \u0627\u0633\u0645\u064e \u0627\u0644\u0645\u0646\u0634\u0623\u0629\u0650\u060c \u0662. \u0627\u0644\u0645\u0633\u0627\u0641\u0629\u064e \u0627\u0644\u062a\u0642\u0631\u064a\u0628\u064a\u064e\u0651\u0629\u064e \u0645\u0646 \u0627\u0644\u0645\u0648\u0642\u0639\u0650\u060c \u0663. \u0631\u0642\u0645\u064e \u0627\u0644\u0647\u0627\u062a\u0641\u0650\u060c \u0664. \u0645\u0644\u0627\u062d\u0638\u0629\u064b \u0645\u0648\u062c\u0632\u0629\u064b \u0639\u0646 \u0627\u0644\u062e\u062f\u0645\u0627\u062a\u0650 \u0627\u0644\u0645\u0642\u062f\u064e\u0651\u0645\u0629\u0650. \u064a\u064f\u0631\u062c\u0649 \u062a\u0646\u0633\u064a\u0642\u064f \u0627\u0644\u0625\u062c\u0627\u0628\u0629\u0650 \u0639\u0644\u0649 \u0634\u0643\u0644\u0650 \u0642\u0627\u0626\u0645\u0629\u064d \u0648\u0627\u0636\u062d\u0629\u064d\u060c \u0645\u0639 \u0641\u0635\u0644\u0650 \u0643\u0644\u0650\u0651 \u0639\u0646\u0635\u0631\u064d \u0628\u0641\u0627\u0635\u0644\u064a\u0646 \u0645\u0632\u062f\u0648\u062c\u064a\u0646."},"errors":{"invalidImage":"\u064a\u064f\u0631\u062c\u0649 \u062a\u062d\u0645\u064a\u0644\u064f \u0645\u0644\u0641\u0650\u0651 \u0635\u0648\u0631\u0629\u064d (JPEG \u0623\u0648 PNG)","imageError":"\u062d\u062f\u062b\u064e \u062e\u0637\u0623\u064c \u0623\u062b\u0646\u0627\u0621\u064e \u0642\u0631\u0627\u0621\u0629\u0650 \u0645\u0644\u0641\u0650\u0651 \u0627\u0644\u0635\u0648\u0631\u0629\u0650","classificationError":"\u062d\u062f\u062b\u064e \u062e\u0637\u0623\u064c \u0623\u062b\u0646\u0627\u0621\u064e \u062a\u0635\u0646\u064a\u0641\u0650 \u0627\u0644\u0635\u0648\u0631\u0629\u0650. \u064a\u064f\u0631\u062c\u0649 \u062a\u062c\u0631\u0628\u0629\u064f \u0635\u0648\u0631\u0629\u064d \u0623\u062e\u0631\u0649.","locationDenied":"\u062a\u0645\u064e\u0651 \u0631\u0641\u0636\u064f \u0627\u0644\u0648\u0635\u0648\u0644\u0650 \u0625\u0644\u0649 \u0627\u0644\u0645\u0648\u0642\u0639\u0650. \u064a\u064f\u0631\u062c\u0649 \u062a\u0641\u0639\u064a\u0644\u064f \u062e\u062f\u0645\u0627\u062a\u0650 \u0627\u0644\u0645\u0648\u0642\u0639\u0650 \u0623\u0648 \u0625\u062f\u062e\u0627\u0644\u064f \u0645\u0648\u0642\u0639\u0650\u0643\u064e \u064a\u062f\u0648\u064a\u064b\u0651\u0627.","locationUnavailable":"\u0627\u0644\u0645\u0648\u0642\u0639\u064f \u063a\u064a\u0631\u064f \u0645\u062a\u0627\u062d\u064d. \u064a\u064f\u0631\u062c\u0649 \u0627\u0644\u062a\u064e\u0651\u062d\u0642\u064f\u0651\u0642\u064f \u0645\u0646 \u0627\u0644\u0627\u062a\u0650\u0651\u0635\u0627\u0644\u0650 \u0623\u0648 \u0625\u062f\u062e\u0627\u0644\u064f \u0627\u0644\u0645\u0648\u0642\u0639\u0650 \u064a\u062f\u0648\u064a\u064b\u0651\u0627.","locationTimeout":"\u0627\u0646\u062a\u0647\u062a\u0652 \u0645\u0647\u0644\u0629\u064f \u0637\u0644\u0628\u0650 \u0627\u0644\u0645\u0648\u0642\u0639\u0650. \u064a\u064f\u0631\u062c\u0649 \u0627\u0644\u0645\u062d\u0627\u0648\u0644\u0629\u064f \u0645\u062c\u062f\u064e\u0651\u062f\u064b\u0627 \u0623\u0648 \u0625\u062f\u062e\u0627\u0644\u064f \u0627\u0644\u0645\u0648\u0642\u0639\u0650 \u064a\u062f\u0648\u064a\u064b\u0651\u0627.","hospitalError":"\u062d\u062f\u062b\u064e \u062e\u0637\u0623\u064c \u0623\u062b\u0646\u0627\u0621\u064e \u0627\u0644\u0628\u062d\u062b\u0650 \u0639\u0646 \u0627\u0644\u0645\u0633\u062a\u0634\u0641\u064a\u0627\u062a\u0650 \u0627\u0644\u0642\u0631\u064a\u0628\u0629\u0650."},"header":{"home":"\u0627\u0644\u0631\u064e\u0651\u0626\u064a\u0633\u064a\u064e\u0651\u0629\u064f","about":"\u0645\u0639\u0644\u0648\u0645\u0627\u062a\u064c","contact":"\u0627\u062a\u0650\u0651\u0635\u0627\u0644\u064c"},"language":{"change":"\u062a\u063a\u064a\u064a\u0631\u064f \u0627\u0644\u0644\u063a\u0629\u0650"}}}')},cn:{translation:JSON.parse('{"TheCurrentLanguage":"\u4e2d\u6587","home":{"title":"\u5148\u8fdb\u533b\u5b66\u5f71\u50cf\u5206\u6790","subtitle":"\u7531 AI \u9a71\u52a8\u7684\u8bca\u65ad\u5de5\u5177\uff0c\u5b9e\u73b0\u533b\u5b66\u5f71\u50cf\u7684\u7cbe\u51c6\u5feb\u901f\u89e3\u8bfb","chooseMethod":"\u9009\u62e9\u5206\u6790\u65b9\u5f0f","chooseSubtitle":"\u9009\u62e9\u60a8\u9700\u8981\u5206\u6790\u7684\u5f71\u50cf\u7c7b\u578b","ctScan":{"title":"CT \u626b\u63cf","description":"\u8be6\u7ec6\u7684\u6a2a\u65ad\u9762\u6210\u50cf\u8bc4\u4f30\uff0c\u652f\u6301 3D \u91cd\u5efa","button":"\u9009\u62e9 CT \u626b\u63cf"},"xray":{"title":"X \u5149","description":"\u5168\u9762\u8bc4\u4f30\u9aa8\u9abc\u548c\u8f6f\u7ec4\u7ec7\u7ed3\u6784","button":"\u9009\u62e9 X \u5149"}},"classifier":{"title":"PulmoDX AI","tagline":"AI \u9a71\u52a8\u7684\u5148\u8fdb\u80ba\u764c\u5206\u6790 | \u673a\u5668\u5b66\u4e60","uploadTitle":"\u4e0a\u4f20\u80ba\u90e8\u5f71\u50cf\u8fdb\u884c\u5206\u6790","uploadSubtitle":"\u83b7\u53d6 AI \u5373\u65f6\u8bc4\u4f30\u60a8\u7684\u80ba\u90e8\u72b6\u51b5","selectImage":"\u9009\u62e9\u56fe\u50cf","fileTypes":"\u652f\u6301\u683c\u5f0f\uff1aJPEG\u3001PNG","analyze":"\u7acb\u5373\u5206\u6790","analyzing":"\u5206\u6790\u4e2d\u2026","results":{"title":"\u5206\u6790\u7ed3\u679c","confidence":"\u7f6e\u4fe1\u5ea6","normal":"\u6b63\u5e38","benign":"\u826f\u6027","malignant":"\u6076\u6027","findClinics":"\u67e5\u627e\u6700\u8fd1\u80ba\u75c5\u8bca\u6240","findingClinics":"\u6b63\u5728\u67e5\u627e\u9644\u8fd1\u8bca\u6240\u2026","locationDisclaimer":"\u6211\u4eec\u4f1a\u4f7f\u7528\u8bbe\u5907\u4f4d\u7f6e\u67e5\u627e\u9644\u8fd1\u8bca\u6240","searchingNear":"\u6b63\u5728\u641c\u7d22\uff1a","recommendedClinics":"\u63a8\u8350\u80ba\u75c5\u8bca\u6240","foundNearby":"\u9644\u8fd1\u627e\u5230","refreshResults":"\u5237\u65b0\u7ed3\u679c","ShowLocatinoPrompet":"\u54cd\u5e94\u5e94\u4ec5\u5305\u542b 3 \u4e2a\u9760\u8fd1 ${address}\uff08\u5750\u6807\uff1a${location.lat}\uff0c${location.lng}\uff09\u7684\u80ba\u764c\u4e13\u79d1\u8bca\u6240\u6216\u533b\u9662\u7684\u5217\u8868\u3002\u6bcf\u4e2a\u6761\u76ee\u5e94\u5305\u542b\uff1a1. \u673a\u6784\u540d\u79f0\uff1b2. \u8ddd\u79bb\uff1b3. \u7535\u8bdd\u53f7\u7801\uff1b4. \u63d0\u4f9b\u670d\u52a1\u7b80\u4ecb\u3002\u8bf7\u4ee5\u6e05\u6670\u5217\u8868\u5f62\u5f0f\uff0c\u6761\u76ee\u4e4b\u95f4\u7559\u4e24\u4e2a\u6362\u884c\u3002"},"errors":{"invalidImage":"\u8bf7\u4e0a\u4f20\u56fe\u50cf\u6587\u4ef6\uff08JPEG \u6216 PNG\uff09","imageError":"\u8bfb\u53d6\u56fe\u50cf\u6587\u4ef6\u65f6\u51fa\u9519","classificationError":"\u56fe\u50cf\u5206\u7c7b\u51fa\u9519\uff0c\u8bf7\u5c1d\u8bd5\u5176\u4ed6\u56fe\u50cf\u3002","locationDenied":"\u4f4d\u7f6e\u8bbf\u95ee\u88ab\u62d2\u7edd\u3002\u8bf7\u542f\u7528\u4f4d\u7f6e\u670d\u52a1\u6216\u624b\u52a8\u8f93\u5165\u4f4d\u7f6e\u3002","locationUnavailable":"\u4f4d\u7f6e\u4e0d\u53ef\u7528\u3002\u8bf7\u68c0\u67e5\u8fde\u63a5\u6216\u624b\u52a8\u8f93\u5165\u4f4d\u7f6e\u3002","locationTimeout":"\u4f4d\u7f6e\u8bf7\u6c42\u8d85\u65f6\u3002\u8bf7\u91cd\u8bd5\u6216\u624b\u52a8\u8f93\u5165\u4f4d\u7f6e\u3002","hospitalError":"\u67e5\u627e\u9644\u8fd1\u533b\u9662\u65f6\u51fa\u9519\u3002"},"header":{"home":"\u4e3b\u9875","about":"\u5173\u4e8e","contact":"\u8054\u7cfb"},"language":{"change":"\u66f4\u6539\u8bed\u8a00"}}}')},it:{translation:JSON.parse('{"TheCurrentLanguage":"Italiano","home":{"title":"Analisi Avanzata delle Immagini Mediche","subtitle":"Strumenti diagnostici basati su IA per un\'interpretazione rapida e accurata","chooseMethod":"Scegli il Metodo di Analisi","chooseSubtitle":"Seleziona la modalit\xe0 di imaging da analizzare","ctScan":{"title":"TC (Tomografia Computerizzata)","description":"Valutazione dettagliata con ricostruzione tridimensionale","button":"Seleziona TC"},"xray":{"title":"Radiografia","description":"Valutazione completa delle ossa e dei tessuti molli","button":"Seleziona Radiografia"}},"classifier":{"title":"PulmoDX IA","tagline":"Analisi Avanzata del Cancro Polmonare con Intelligenza Artificiale","uploadTitle":"Carica un\u2019Immagine Polmonare per l\u2019Analisi","uploadSubtitle":"Ricevi una valutazione immediata basata su IA","selectImage":"Seleziona Immagine","fileTypes":"Supporta JPEG, PNG","analyze":"Analizza Ora","analyzing":"Analisi in corso...","results":{"title":"Risultato dell\'Analisi","confidence":"Affidabilit\xe0","normal":"Normale","benign":"Benigno","malignant":"Maligno","findClinics":"Trova il Pneumologo pi\xf9 Vicino","findingClinics":"Ricerca in corso...","locationDisclaimer":"Utilizzeremo la posizione del tuo dispositivo per trovare cliniche vicine","searchingNear":"Ricerca nei pressi di:","recommendedClinics":"Cliniche Pneumologiche Consigliate","foundNearby":"Trovate nelle vicinanze","refreshResults":"Aggiorna Risultati","ShowLocatinoPrompet":"La risposta deve contenere solo un elenco di 3 cliniche o ospedali specializzati in condizioni polmonari vicino a ${address} (coordinate: ${location.lat}, ${location.lng}). Per ciascuno includere: 1. Nome della struttura 2. Distanza approssimativa 3. Numero di telefono 4. Breve nota sui servizi offerti. Formatta l\'elenco chiaramente, separando ogni voce con 2 interlinee."},"errors":{"invalidImage":"Carica un file immagine valido (JPEG, PNG)","imageError":"Errore durante la lettura del file immagine","classificationError":"Errore durante la classificazione dell\'immagine. Prova con un\'altra immagine.","locationDenied":"Accesso alla posizione negato. Abilita i servizi di localizzazione o inserisci la posizione manualmente.","locationUnavailable":"Posizione non disponibile. Verifica la connessione o inserisci la posizione manualmente.","locationTimeout":"Tempo scaduto per la richiesta di posizione. Riprova o inserisci manualmente.","hospitalError":"Errore durante la ricerca di ospedali nelle vicinanze."},"header":{"home":"Home","about":"Chi siamo","contact":"Contatto"},"language":{"change":"Cambia lingua"}}}')},in:{translation:JSON.parse('{"TheCurrentLanguage":"\u0939\u093f\u0928\u094d\u0926\u0940","home":{"title":"\u0909\u0928\u094d\u0928\u0924 \u091a\u093f\u0915\u093f\u0924\u094d\u0938\u0915\u0940\u092f \u0907\u092e\u0947\u091c\u093f\u0902\u0917 \u0935\u093f\u0936\u094d\u0932\u0947\u0937\u0923","subtitle":"AI- \u0938\u0902\u091a\u093e\u0932\u093f\u0924 \u0928\u093f\u0926\u093e\u0928 \u0909\u092a\u0915\u0930\u0923, \u0938\u091f\u0940\u0915 \u0914\u0930 \u0924\u0947\u091c\u093c \u091a\u093f\u0915\u093f\u0924\u094d\u0938\u093e \u091b\u0935\u093f\u092f\u093e\u0901 \u0935\u094d\u092f\u093e\u0916\u094d\u092f\u093e \u0939\u0947\u0924\u0941","chooseMethod":"\u0935\u093f\u0936\u094d\u0932\u0947\u0937\u0923 \u0935\u093f\u0927\u093f \u091a\u0941\u0928\u0947\u0902","chooseSubtitle":"\u0909\u0938 \u0907\u092e\u0947\u091c\u093f\u0902\u0917 \u092a\u094d\u0930\u0915\u093e\u0930 \u0915\u093e \u091a\u092f\u0928 \u0915\u0930\u0947\u0902 \u091c\u093f\u0938\u0947 \u0906\u092a \u0935\u093f\u0936\u094d\u0932\u0947\u0937\u0923 \u0915\u0930\u0928\u093e \u091a\u093e\u0939\u0924\u0947 \u0939\u0948\u0902","ctScan":{"title":"\u0938\u0940\u091f\u0940 \u0938\u094d\u0915\u0948\u0928","description":"3D \u092a\u0941\u0928\u0930\u094d\u0928\u093f\u0930\u094d\u092e\u093e\u0923 \u0915\u094d\u0937\u092e\u0924\u093e\u0913\u0902 \u0915\u0947 \u0938\u093e\u0925 \u0935\u093f\u0938\u094d\u0924\u0943\u0924 \u0915\u094d\u0930\u0949\u0938-\u0938\u0947\u0915\u094d\u0936\u0928 \u091b\u0935\u093f \u092e\u0942\u0932\u094d\u092f\u093e\u0902\u0915\u0928","button":"\u0938\u0940\u091f\u0940 \u0938\u094d\u0915\u0948\u0928 \u091a\u0941\u0928\u0947\u0902"},"xray":{"title":"\u090f\u0915\u094d\u0938-\u0930\u0947","description":"\u0939\u0921\u094d\u0921\u093f\u092f\u094b\u0902 \u0914\u0930 \u0928\u0930\u092e \u090a\u0924\u0915\u094b\u0902 \u0915\u0940 \u0938\u0902\u0930\u091a\u0928\u093e\u0924\u094d\u092e\u0915 \u0935\u094d\u092f\u093e\u092a\u0915 \u091c\u093e\u0902\u091a","button":"\u090f\u0915\u094d\u0938-\u0930\u0947 \u091a\u0941\u0928\u0947\u0902"}},"classifier":{"title":"PulmoDX AI","tagline":"AI \u0938\u0902\u091a\u093e\u0932\u093f\u0924 \u0909\u0928\u094d\u0928\u0924 \u092b\u0947\u092b\u0921\u093c\u0947 \u0915\u0948\u0902\u0938\u0930 \u0935\u093f\u0936\u094d\u0932\u0947\u0937\u0923 | \u092e\u0936\u0940\u0928 \u0932\u0930\u094d\u0928\u093f\u0902\u0917","uploadTitle":"\u0935\u093f\u0936\u094d\u0932\u0947\u0937\u0923 \u0939\u0947\u0924\u0941 \u092b\u0947\u092b\u0921\u093c\u0947 \u0915\u0940 \u091b\u0935\u093f \u0905\u092a\u0932\u094b\u0921 \u0915\u0930\u0947\u0902","uploadSubtitle":"AI \u0926\u094d\u0935\u093e\u0930\u093e \u0924\u0924\u094d\u0915\u093e\u0932 \u0906\u092a\u0915\u0947 \u092b\u0947\u092b\u0921\u093c\u094b\u0902 \u0915\u0940 \u0938\u094d\u0925\u093f\u0924\u093f \u0915\u093e \u0906\u0915\u0932\u0928 \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u0915\u0930\u0947\u0902","selectImage":"\u091b\u0935\u093f \u091a\u0941\u0928\u0947\u0902","fileTypes":"\u0938\u092e\u0930\u094d\u0925\u093f\u0924 \u092b\u0949\u0930\u094d\u092e\u0947\u091f: JPEG, PNG","analyze":"\u0905\u092d\u0940 \u0935\u093f\u0936\u094d\u0932\u0947\u0937\u0923 \u0915\u0930\u0947\u0902","analyzing":"\u0935\u093f\u0936\u094d\u0932\u0947\u0937\u0923 \u0939\u094b \u0930\u0939\u093e \u0939\u0948...","results":{"title":"\u0935\u093f\u0936\u094d\u0932\u0947\u0937\u0923 \u092a\u0930\u093f\u0923\u093e\u092e","confidence":"\u092d\u0930\u094b\u0938\u093e","normal":"\u0928\u093f\u092f\u092e\u093f\u0924","benign":"\u0938\u094c\u092e\u094d\u092f","malignant":"\u0926\u0941\u0937\u094d\u091f","findClinics":"\u0928\u091c\u0926\u0940\u0915\u0940 \u092a\u0932\u094d\u092e\u094b\u0928\u094b\u0932\u0949\u091c\u093f\u0938\u094d\u091f \u0915\u094d\u0932\u093f\u0928\u093f\u0915 \u0916\u094b\u091c\u0947\u0902","findingClinics":"\u0928\u091c\u0926\u0940\u0915\u0940 \u0915\u094d\u0932\u093f\u0928\u093f\u0915 \u0916\u094b\u091c \u0930\u0939\u0947 \u0939\u0948\u0902...","locationDisclaimer":"\u0928\u091c\u0926\u0940\u0915\u0940 \u0915\u094d\u0932\u093f\u0928\u093f\u0915 \u0916\u094b\u091c\u0928\u0947 \u0915\u0947 \u0932\u093f\u090f \u0939\u092e \u0906\u092a\u0915\u0947 \u0909\u092a\u0915\u0930\u0923 \u0915\u0940 \u0938\u094d\u0925\u093f\u0924\u093f \u0915\u093e \u0909\u092a\u092f\u094b\u0917 \u0915\u0930\u0947\u0902\u0917\u0947","searchingNear":"\u0915\u0947 \u092a\u093e\u0938 \u0916\u094b\u091c \u0930\u0939\u0947 \u0939\u0948\u0902:","recommendedClinics":"\u092a\u094d\u0930\u0938\u094d\u0924\u093e\u0935\u093f\u0924 \u092a\u0932\u094d\u092e\u094b\u0928\u094b\u0932\u0949\u091c\u093f\u0938\u094d\u091f \u0915\u094d\u0932\u093f\u0928\u093f\u0915","foundNearby":"\u0928\u091c\u0926\u0940\u0915\u0940 \u092a\u093e\u092f\u093e \u0917\u092f\u093e","refreshResults":"\u092a\u0930\u093f\u0923\u093e\u092e \u0924\u093e\u091c\u093c\u093e \u0915\u0930\u0947\u0902","ShowLocatinoPrompet":"\u0909\u0924\u094d\u0924\u0930 \u092e\u0947\u0902 \u0915\u0947\u0935\u0932 ${address} (\u0928\u093f\u0930\u094d\u0927\u0947\u0936\u093e\u0902\u0915: ${location.lat}, ${location.lng}) \u0915\u0947 \u092a\u093e\u0938 \u092b\u0947\u092b\u0921\u093c\u0947 \u0915\u0947 \u0915\u0948\u0902\u0938\u0930 \u0915\u0947 \u0935\u093f\u0936\u0947\u0937\u091c\u094d\u091e 3 \u0915\u094d\u0932\u093f\u0928\u093f\u0915 \u092f\u093e \u0905\u0938\u094d\u092a\u0924\u093e\u0932\u094b\u0902 \u0915\u0940 \u0938\u0942\u091a\u0940 \u0939\u094b\u0928\u0940 \u091a\u093e\u0939\u093f\u090f\u0964 \u092a\u094d\u0930\u0924\u094d\u092f\u0947\u0915 \u092e\u0947\u0902 \u0936\u093e\u092e\u093f\u0932 \u0939\u094b\u0902: 1. \u0938\u094d\u0925\u093e\u0928 \u0915\u093e \u0928\u093e\u092e; 2. \u0926\u0942\u0930\u0940; 3. \u092b\u093c\u094b\u0928 \u0928\u0902\u092c\u0930; 4. \u092a\u094d\u0930\u0926\u093e\u0928 \u0915\u0940 \u091c\u093e\u0928\u0947 \u0935\u093e\u0932\u0940 \u0938\u0947\u0935\u093e\u0913\u0902 \u0915\u093e \u0938\u0902\u0915\u094d\u0937\u093f\u092a\u094d\u0924 \u0935\u093f\u0935\u0930\u0923\u0964 \u0915\u0943\u092a\u092f\u093e \u092a\u094d\u0930\u0924\u094d\u092f\u0947\u0915 \u0906\u0907\u091f\u092e \u0915\u094b \u0926\u094b \u0932\u093e\u0907\u0928 \u092c\u094d\u0930\u0947\u0915 \u0926\u094d\u0935\u093e\u0930\u093e \u0938\u094d\u092a\u0937\u094d\u091f \u0938\u0942\u091a\u0940 \u092e\u0947\u0902 \u0938\u094d\u0935\u0930\u0942\u092a\u093f\u0924 \u0915\u0930\u0947\u0902\u0964"},"errors":{"invalidImage":"\u0915\u0943\u092a\u092f\u093e \u090f\u0915 \u091b\u0935\u093f \u092b\u093c\u093e\u0907\u0932 (JPEG \u092f\u093e PNG) \u0905\u092a\u0932\u094b\u0921 \u0915\u0930\u0947\u0902","imageError":"\u091b\u0935\u093f \u092b\u093c\u093e\u0907\u0932 \u092a\u0922\u093c\u0928\u0947 \u092e\u0947\u0902 \u0924\u094d\u0930\u0941\u091f\u093f","classificationError":"\u091b\u0935\u093f \u0935\u0930\u094d\u0917\u0940\u0915\u0930\u0923 \u092e\u0947\u0902 \u0924\u094d\u0930\u0941\u091f\u093f\u0964 \u0915\u0943\u092a\u092f\u093e \u0926\u0942\u0938\u0930\u0940 \u091b\u0935\u093f \u0906\u091c\u093c\u092e\u093e\u090f\u0901\u0964","locationDenied":"\u0938\u094d\u0925\u093e\u0928 \u090f\u0915\u094d\u0938\u0947\u0938 \u0905\u0938\u094d\u0935\u0940\u0915\u0943\u0924\u0964 \u0915\u0943\u092a\u092f\u093e \u0938\u094d\u0925\u093e\u0928 \u0938\u0947\u0935\u093e\u090f\u0901 \u0938\u0915\u094d\u0937\u092e \u0915\u0930\u0947\u0902 \u092f\u093e \u0905\u092a\u0928\u093e \u0938\u094d\u0925\u093e\u0928 \u092e\u0948\u0928\u094d\u092f\u0941\u0905\u0932\u0940 \u0926\u0930\u094d\u091c \u0915\u0930\u0947\u0902\u0964","locationUnavailable":"\u0938\u094d\u0925\u093e\u0928 \u0909\u092a\u0932\u092c\u094d\u0927 \u0928\u0939\u0940\u0902 \u0939\u0948\u0964 \u0915\u0943\u092a\u092f\u093e \u0915\u0928\u0947\u0915\u094d\u0936\u0928 \u091c\u093e\u0902\u091a\u0947\u0902 \u092f\u093e \u0938\u094d\u0925\u093e\u0928 \u092e\u0948\u0928\u094d\u092f\u0941\u0905\u0932\u0940 \u0926\u0930\u094d\u091c \u0915\u0930\u0947\u0902\u0964","locationTimeout":"\u0938\u094d\u0925\u093e\u0928 \u0905\u0928\u0941\u0930\u094b\u0927 \u0938\u092e\u092f\u092a\u0942\u0930\u094d\u0935 \u0938\u092e\u093e\u092a\u094d\u0924 \u0939\u094b \u0917\u092f\u093e\u0964 \u0915\u0943\u092a\u092f\u093e \u092a\u0941\u0928\u0903 \u092a\u094d\u0930\u092f\u093e\u0938 \u0915\u0930\u0947\u0902 \u092f\u093e \u0938\u094d\u0925\u093e\u0928 \u092e\u0948\u0928\u094d\u092f\u0941\u0905\u0932\u0940 \u0926\u0930\u094d\u091c \u0915\u0930\u0947\u0902\u0964","hospitalError":"\u092a\u093e\u0938 \u0915\u0947 \u0905\u0938\u094d\u092a\u0924\u093e\u0932\u094b\u0902 \u0915\u094b \u0922\u0942\u0902\u0922\u0928\u0947 \u092e\u0947\u0902 \u0924\u094d\u0930\u0941\u091f\u093f\u0964"},"header":{"home":"\u0939\u094b\u092e","about":"\u0939\u092e\u093e\u0930\u0947 \u092c\u093e\u0930\u0947 \u092e\u0947\u0902","contact":"\u0938\u0902\u092a\u0930\u094d\u0915 \u0915\u0930\u0947\u0902"},"language":{"change":"\u092d\u093e\u0937\u093e \u092c\u0926\u0932\u0947\u0902"}}}')},de:{translation:JSON.parse('{"TheCurrentLanguage":"Deutsch","home":{"title":"Fortgeschrittene medizinische Bildanalyse","subtitle":"KI-gest\xfctzte Diagnosewerkzeuge f\xfcr eine pr\xe4zise und schnelle Interpretation medizinischer Bilder","chooseMethod":"W\xe4hlen Sie die Analysemethode","chooseSubtitle":"W\xe4hlen Sie die Bildgebungsmodalit\xe4t aus, die analysiert werden soll","ctScan":{"title":"Computertomographie (CT)","description":"Detaillierte Querschnittsbilder mit 3D-Rekonstruktionsm\xf6glichkeiten","button":"CT-Scan ausw\xe4hlen"},"xray":{"title":"R\xf6ntgenaufnahme","description":"Umfassende Bewertung von Knochen- und Weichteilstrukturen","button":"R\xf6ntgen ausw\xe4hlen"}},"classifier":{"title":"PulmoDX KI","tagline":"Fortschrittliche Lungenkrebserkennung unterst\xfctzt durch KI | Maschinelles Lernen","uploadTitle":"Laden Sie ein Lungenbild zur Analyse hoch","uploadSubtitle":"Erhalten Sie eine sofortige KI-basierte Bewertung Ihres Lungenzustands","selectImage":"Bild ausw\xe4hlen","fileTypes":"Unterst\xfctzte Formate: JPEG, PNG","analyze":"Jetzt analysieren","analyzing":"Analyse l\xe4uft...","results":{"title":"Analyseergebnis","confidence":"Vertrauen","normal":"Normal","benign":"Gutartig","malignant":"B\xf6sartig","findClinics":"N\xe4chste Pneumologen-Klinik finden","findingClinics":"Suche nach Kliniken in der N\xe4he...","locationDisclaimer":"Wir verwenden Ihren Ger\xe4testandort, um nahegelegene Kliniken zu finden","searchingNear":"Suche in der N\xe4he von:","recommendedClinics":"Empfohlene Pneumologen-Kliniken","foundNearby":"In der N\xe4he gefunden","refreshResults":"Ergebnisse aktualisieren","ShowLocatinoPrompet":"Die Antwort darf nur eine Liste mit 3 Pneumologen-Kliniken oder Krankenh\xe4usern in der N\xe4he von ${address} (Koordinaten: ${location.lat}, ${location.lng}) enthalten. F\xfcr jede Einrichtung: 1. Name. 2. Ungef\xe4hre Entfernung vom Standort. 3. Telefonnummer. 4. Kurze Notiz zu den angebotenen Leistungen. Formatiere die Antwort als klare Liste mit doppeltem Zeilenumbruch zwischen den Eintr\xe4gen."},"errors":{"invalidImage":"Bitte laden Sie eine Bilddatei hoch (JPEG oder PNG)","imageError":"Fehler beim Lesen der Bilddatei","classificationError":"Fehler bei der Klassifizierung des Bildes. Bitte versuchen Sie ein anderes Bild.","locationDenied":"Standortzugriff verweigert. Bitte aktivieren Sie die Standortdienste oder geben Sie Ihren Standort manuell ein.","locationUnavailable":"Standort nicht verf\xfcgbar. Bitte pr\xfcfen Sie Ihre Verbindung oder geben Sie Ihren Standort manuell ein.","locationTimeout":"Standortanfrage abgelaufen. Bitte erneut versuchen oder Standort manuell eingeben.","hospitalError":"Fehler bei der Suche nach nahegelegenen Krankenh\xe4usern."},"header":{"home":"Startseite","about":"\xdcber uns","contact":"Kontakt"},"language":{"change":"Sprache \xe4ndern"}}}')},fr:{translation:JSON.parse('{"TheCurrentLanguage":"Fran\xe7ais","home":{"title":"Analyse d\u2019imagerie m\xe9dicale avanc\xe9e","subtitle":"Outils de diagnostic pilot\xe9s par IA pour une interpr\xe9tation pr\xe9cise et rapide des images m\xe9dicales","chooseMethod":"Choisissez la m\xe9thode d\u2019analyse","chooseSubtitle":"S\xe9lectionnez la modalit\xe9 d\u2019imagerie \xe0 analyser","ctScan":{"title":"Scanner","description":"\xc9valuation d\xe9taill\xe9e de l\u2019imagerie en coupes transversales avec reconstruction 3D","button":"S\xe9lectionner le scanner"},"xray":{"title":"Radiographie","description":"\xc9valuation compl\xe8te des structures osseuses et des tissus mous","button":"S\xe9lectionner la radiographie"}},"classifier":{"title":"PulmoDX IA","tagline":"Analyse avanc\xe9e du cancer du poumon assist\xe9e par IA | Apprentissage automatique","uploadTitle":"T\xe9l\xe9chargez une image pulmonaire pour analyse","uploadSubtitle":"Obtenez une \xe9valuation instantan\xe9e de votre condition pulmonaire gr\xe2ce \xe0 l\u2019IA","selectImage":"S\xe9lectionner une image","fileTypes":"Formats pris en charge\u202f: JPEG, PNG","analyze":"Analyser maintenant","analyzing":"Analyse en cours...","results":{"title":"R\xe9sultat de l\u2019analyse","confidence":"Confiance","normal":"Normal","benign":"B\xe9nin","malignant":"Malin","findClinics":"Trouver la clinique pneumologique la plus proche","findingClinics":"Recherche de cliniques \xe0 proximit\xe9...","locationDisclaimer":"Nous utiliserons la position de votre appareil pour trouver des cliniques \xe0 proximit\xe9","searchingNear":"Recherche pr\xe8s de :","recommendedClinics":"Cliniques pneumologiques recommand\xe9es","foundNearby":"Acc\xe8s trouv\xe9 \xe0 proximit\xe9","refreshResults":"Rafra\xeechir les r\xe9sultats","ShowLocatinoPrompet":"La r\xe9ponse doit inclure uniquement une liste de 3 cliniques ou h\xf4pitaux sp\xe9cialis\xe9s dans le cancer du poumon pr\xe8s de ${address} (coordonn\xe9es\u202f: ${location.lat}, ${location.lng}). Pour chacun, incluez : 1. Nom de l\u2019\xe9tablissement. 2. Distance approximative du lieu. 3. Num\xe9ro de t\xe9l\xe9phone. 4. Br\xe8ve note sur les services offerts. Formattez la r\xe9ponse comme une liste claire avec un double saut de ligne entre chaque \xe9l\xe9ment."},"errors":{"invalidImage":"Veuillez t\xe9l\xe9charger un fichier image (JPEG ou PNG)","imageError":"Erreur lors de la lecture du fichier image","classificationError":"Erreur lors de la classification de l\u2019image. Veuillez essayer une autre image.","locationDenied":"Acc\xe8s \xe0 la localisation refus\xe9. Veuillez activer les services de localisation ou entrer votre position manuellement.","locationUnavailable":"Localisation non disponible. Veuillez v\xe9rifier votre connexion ou entrer manuellement votre position.","locationTimeout":"D\xe9lai de localisation d\xe9pass\xe9. Veuillez r\xe9essayer ou entrer votre position manuellement.","hospitalError":"Erreur lors de la recherche des h\xf4pitaux \xe0 proximit\xe9."},"header":{"home":"Accueil","about":"\xc0 propos","contact":"Contact"},"language":{"change":"Changer la langue"}}}')},id:{translation:JSON.parse('{"TheCurrentLanguage":"Bahasa","home":{"title":"Analisis Pencitraan Medis Tingkat Lanjut","subtitle":"Alat diagnostik berbasis AI untuk interpretasi citra medis yang akurat dan cepat","chooseMethod":"Pilih Metode Analisis","chooseSubtitle":"Pilih jenis pencitraan yang ingin Anda analisis","ctScan":{"title":"CT Scan","description":"Evaluasi citra penampang mendetail dengan kemampuan rekonstruksi 3D","button":"Pilih CT Scan"},"xray":{"title":"Sinar-X","description":"Evaluasi menyeluruh terhadap struktur tulang dan jaringan lunak","button":"Pilih Sinar-X"}},"classifier":{"title":"PulmoDX AI","tagline":"Analisis Kanker Paru canggih yang didukung AI | Pembelajaran Mesin","uploadTitle":"Unggah Gambar Paru untuk Analisis","uploadSubtitle":"Dapatkan penilaian instan kondisi paru Anda menggunakan AI","selectImage":"Pilih gambar","fileTypes":"Format didukung: JPEG, PNG","analyze":"Analisis Sekarang","analyzing":"Sedang menganalisis...","results":{"title":"Hasil Analisis","confidence":"Keyakinan","normal":"Normal","benign":"Jinak","malignant":"Ganas","findClinics":"Cari Klinik Pulmonologi Terdekat","findingClinics":"Mencari klinik terdekat...","locationDisclaimer":"Kami akan menggunakan lokasi perangkat Anda untuk menemukan klinik terdekat","searchingNear":"Mencari di dekat:","recommendedClinics":"Klinik Pulmonologi Rekomendasi","foundNearby":"Ditemukan di dekat","refreshResults":"Segarkan Hasil","ShowLocatinoPrompet":"Respons harus hanya mencantumkan daftar 3 klinik atau rumah sakit pulmo-onkologi di dekat ${address} (koordinat: ${location.lat}, ${location.lng}). Untuk setiap, sertakan: 1. Nama lembaga; 2. Jarak perkiraan; 3. Nomor telepon; 4. Catatan singkat tentang layanan yang disediakan. Harap format sebagai daftar jelas dengan dua jeda baris antar item."},"errors":{"invalidImage":"Silakan unggah file gambar (JPEG atau PNG)","imageError":"Kesalahan saat membaca file gambar","classificationError":"Kesalahan dalam mengklasifikasi gambar. Silakan coba gambar lain.","locationDenied":"Akses lokasi ditolak. Harap aktifkan layanan lokasi atau masukkan lokasi Anda secara manual.","locationUnavailable":"Lokasi tidak tersedia. Harap periksa koneksi atau masukkan lokasi Anda secara manual.","locationTimeout":"Permintaan lokasi habis waktu. Harap coba lagi atau masukkan lokasi secara manual.","hospitalError":"Kesalahan saat mencari rumah sakit terdekat."},"header":{"home":"Beranda","about":"Tentang","contact":"Kontak"},"language":{"change":"Ganti bahasa"}}}')},ru:{translation:JSON.parse('{"TheCurrentLanguage":"\u0420\u0443\u0441\u0441\u043a\u0438\u0439","home":{"title":"\u041f\u0440\u043e\u0434\u0432\u0438\u043d\u0443\u0442\u044b\u0439 \u0430\u043d\u0430\u043b\u0438\u0437 \u043c\u0435\u0434\u0438\u0446\u0438\u043d\u0441\u043a\u0438\u0445 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0439","subtitle":"\u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u044b \u0434\u0438\u0430\u0433\u043d\u043e\u0441\u0442\u0438\u043a\u0438 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u0418\u0418 \u0434\u043b\u044f \u0442\u043e\u0447\u043d\u043e\u0439 \u0438 \u0431\u044b\u0441\u0442\u0440\u043e\u0439 \u0438\u043d\u0442\u0435\u0440\u043f\u0440\u0435\u0442\u0430\u0446\u0438\u0438 \u043c\u0435\u0434\u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0439","chooseMethod":"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043c\u0435\u0442\u043e\u0434 \u0430\u043d\u0430\u043b\u0438\u0437\u0430","chooseSubtitle":"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0442\u0438\u043f \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0434\u043b\u044f \u0430\u043d\u0430\u043b\u0438\u0437\u0430","ctScan":{"title":"\u041a\u0422-\u0441\u043a\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435","description":"\u0414\u0435\u0442\u0430\u043b\u044c\u043d\u0430\u044f \u043e\u0446\u0435\u043d\u043a\u0430 \u0441\u0440\u0435\u0437\u043e\u0432 \u0441 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c\u044e 3D-\u0440\u0435\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438","button":"\u0412\u044b\u0431\u0440\u0430\u0442\u044c \u041a\u0422"},"xray":{"title":"\u0420\u0435\u043d\u0442\u0433\u0435\u043d","description":"\u041a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u043d\u0430\u044f \u043e\u0446\u0435\u043d\u043a\u0430 \u043a\u043e\u0441\u0442\u0435\u0439 \u0438 \u043c\u044f\u0433\u043a\u0438\u0445 \u0442\u043a\u0430\u043d\u0435\u0439","button":"\u0412\u044b\u0431\u0440\u0430\u0442\u044c \u0440\u0435\u043d\u0442\u0433\u0435\u043d"}},"classifier":{"title":"PulmoDX \u0418\u0418","tagline":"\u041f\u0440\u043e\u0434\u0432\u0438\u043d\u0443\u0442\u044b\u0439 \u0430\u043d\u0430\u043b\u0438\u0437 \u0440\u0430\u043a\u0430 \u043b\u0451\u0433\u043a\u0438\u0445 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0418\u0418 | \u041c\u0430\u0448\u0438\u043d\u043d\u043e\u0435 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u0435","uploadTitle":"\u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u043b\u0451\u0433\u043a\u0438\u0445 \u0434\u043b\u044f \u0430\u043d\u0430\u043b\u0438\u0437\u0430","uploadSubtitle":"\u041f\u043e\u043b\u0443\u0447\u0438\u0442\u0435 \u043c\u0433\u043d\u043e\u0432\u0435\u043d\u043d\u0443\u044e \u043e\u0446\u0435\u043d\u043a\u0443 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u043b\u0451\u0433\u043a\u0438\u0445 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0418\u0418","selectImage":"\u0412\u044b\u0431\u0440\u0430\u0442\u044c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435","fileTypes":"\u041f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043c\u044b\u0435 \u0444\u043e\u0440\u043c\u0430\u0442\u044b: JPEG, PNG","analyze":"\u0410\u043d\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0439\u0447\u0430\u0441","analyzing":"\u0418\u0434\u0451\u0442 \u0430\u043d\u0430\u043b\u0438\u0437\u2026","results":{"title":"\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0430\u043d\u0430\u043b\u0438\u0437\u0430","confidence":"\u0423\u0432\u0435\u0440\u0435\u043d\u043d\u043e\u0441\u0442\u044c","normal":"\u041d\u043e\u0440\u043c\u0430","benign":"\u0414\u043e\u0431\u0440\u043e\u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439","malignant":"\u0417\u043b\u043e\u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439","findClinics":"\u041d\u0430\u0439\u0442\u0438 \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0443\u044e \u043f\u0443\u043b\u044c\u043c\u043e\u043d\u043e\u043b\u043e\u0433\u0438\u0447\u0435\u0441\u043a\u0443\u044e \u043a\u043b\u0438\u043d\u0438\u043a\u0443","findingClinics":"\u041f\u043e\u0438\u0441\u043a \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0438\u0445 \u043a\u043b\u0438\u043d\u0438\u043a\u2026","locationDisclaimer":"\u041c\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u043c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0432\u0430\u0448\u0435\u0433\u043e \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u0430 \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430 \u043a\u043b\u0438\u043d\u0438\u043a \u043f\u043e\u0431\u043b\u0438\u0437\u043e\u0441\u0442\u0438","searchingNear":"\u041f\u043e\u0438\u0441\u043a \u0440\u044f\u0434\u043e\u043c \u0441:","recommendedClinics":"\u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0443\u0435\u043c\u044b\u0435 \u043f\u0443\u043b\u044c\u043c\u043e\u043d\u043e\u043b\u043e\u0433\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043a\u043b\u0438\u043d\u0438\u043a\u0438","foundNearby":"\u041d\u0430\u0439\u0434\u0435\u043d\u043e \u0440\u044f\u0434\u043e\u043c","refreshResults":"\u041e\u0431\u043d\u043e\u0432\u0438\u0442\u044c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b","ShowLocatinoPrompet":"\u041e\u0442\u0432\u0435\u0442 \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u043f\u0438\u0441\u043e\u043a \u0438\u0437 3 \u043a\u043b\u0438\u043d\u0438\u043a \u0438\u043b\u0438 \u0431\u043e\u043b\u044c\u043d\u0438\u0446, \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u044e\u0449\u0438\u0445\u0441\u044f \u043d\u0430 \u0440\u0430\u043a\u0435 \u043b\u0451\u0433\u043a\u0438\u0445, \u0440\u044f\u0434\u043e\u043c \u0441 ${address} (\u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b: ${location.lat}, ${location.lng}). \u0414\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u0443\u043a\u0430\u0436\u0438\u0442\u0435: 1. \u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435; 2. \u041f\u0440\u0438\u0431\u043b\u0438\u0437\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435; 3. \u041d\u043e\u043c\u0435\u0440 \u0442\u0435\u043b\u0435\u0444\u043e\u043d\u0430; 4. \u041a\u0440\u0430\u0442\u043a\u043e\u0435 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0443\u0441\u043b\u0443\u0433. \u041e\u0444\u043e\u0440\u043c\u0438\u0442\u0435 \u043e\u0442\u0432\u0435\u0442 \u0432 \u0432\u0438\u0434\u0435 \u0441\u043f\u0438\u0441\u043a\u0430, \u0441 \u0434\u0432\u043e\u0439\u043d\u044b\u043c \u043f\u0435\u0440\u0435\u043d\u043e\u0441\u043e\u043c \u0441\u0442\u0440\u043e\u043a \u043c\u0435\u0436\u0434\u0443 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\u0438."},"errors":{"invalidImage":"\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 (JPEG \u0438\u043b\u0438 PNG)","imageError":"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0447\u0442\u0435\u043d\u0438\u0438 \u0444\u0430\u0439\u043b\u0430 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f","classificationError":"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043a\u043b\u0430\u0441\u0441\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f. \u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u043f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0434\u0440\u0443\u0433\u043e\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435.","locationDenied":"\u0414\u043e\u0441\u0442\u0443\u043f \u043a \u043c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u044e \u043e\u0442\u043a\u043b\u043e\u043d\u0451\u043d. \u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435 \u0441\u0435\u0440\u0432\u0438\u0441\u044b \u043c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0438\u043b\u0438 \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0430\u0448\u0435 \u043c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0432\u0440\u0443\u0447\u043d\u0443\u044e.","locationUnavailable":"\u041c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e. \u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u043f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0438\u043b\u0438 \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0430\u0448\u0435 \u043c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0432\u0440\u0443\u0447\u043d\u0443\u044e.","locationTimeout":"\u0412\u0440\u0435\u043c\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u043c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0438\u0441\u0442\u0435\u043a\u043b\u043e. \u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u043f\u043e\u0432\u0442\u043e\u0440\u0438\u0442\u0435 \u043f\u043e\u043f\u044b\u0442\u043a\u0443 \u0438\u043b\u0438 \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u043c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0432\u0440\u0443\u0447\u043d\u0443\u044e.","hospitalError":"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u043e\u0438\u0441\u043a\u0435 \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0438\u0445 \u0431\u043e\u043b\u044c\u043d\u0438\u0446."},"header":{"home":"\u0413\u043b\u0430\u0432\u043d\u0430\u044f","about":"\u041e \u043d\u0430\u0441","contact":"\u041a\u043e\u043d\u0442\u0430\u043a\u0442"},"language":{"change":"\u0421\u043c\u0435\u043d\u0438\u0442\u044c \u044f\u0437\u044b\u043a"}}}')},tr:{translation:JSON.parse('{"TheCurrentLanguage":"T\xfcrk\xe7e","home":{"title":"Geli\u015fmi\u015f T\u0131bbi G\xf6r\xfcnt\xfc Analizi","subtitle":"Hassas ve h\u0131zl\u0131 t\u0131bbi g\xf6r\xfcnt\xfc yorumu i\xe7in AI destekli te\u015fhis ara\xe7lar\u0131","chooseMethod":"Analiz y\xf6ntemini se\xe7in","chooseSubtitle":"Analiz etmek istedi\u011finiz g\xf6r\xfcnt\xfc t\xfcr\xfcn\xfc se\xe7in","ctScan":{"title":"BT Taramas\u0131","description":"3D yeniden yap\u0131land\u0131rma \xf6zellikleriyle detayl\u0131 kesitsel g\xf6r\xfcnt\xfc de\u011ferlendirmesi","button":"BT Taramas\u0131 Se\xe7"},"xray":{"title":"R\xf6ntgen","description":"Kemik ve yumu\u015fak doku yap\u0131lar\u0131n\u0131n kapsaml\u0131 de\u011ferlendirmesi","button":"R\xf6ntgen Se\xe7"}},"classifier":{"title":"PulmoDX AI","tagline":"AI destekli geli\u015fmi\u015f akci\u011fer kanseri analizi | Makine \xd6\u011frenimi","uploadTitle":"Analiz i\xe7in akci\u011fer g\xf6r\xfcnt\xfcs\xfc y\xfckleyin","uploadSubtitle":"AI ile akci\u011fer durumunuzun anl\u0131k de\u011ferlendirmesini al\u0131n","selectImage":"G\xf6r\xfcnt\xfc Se\xe7in","fileTypes":"Desteklenen formatlar: JPEG, PNG","analyze":"\u015eimdi Analiz Et","analyzing":"Analiz ediliyor...","results":{"title":"Analiz Sonucu","confidence":"G\xfcven","normal":"Normal","benign":"\u0130yi Huylu","malignant":"K\xf6t\xfc Huylu","findClinics":"En Yak\u0131n G\xf6\u011f\xfcs Hastal\u0131klar\u0131 Klini\u011fini Bul","findingClinics":"Yak\u0131n klinikler aran\u0131yor...","locationDisclaimer":"Cihaz konumunuzu yak\u0131n klinikleri bulmak i\xe7in kullanaca\u011f\u0131z","searchingNear":"\u015euraya yak\u0131n aran\u0131yor:","recommendedClinics":"\xd6nerilen G\xf6\u011f\xfcs Hastal\u0131klar\u0131 Klinikleri","foundNearby":"Yak\u0131n bulundu","refreshResults":"Sonu\xe7lar\u0131 Yenile","ShowLocatinoPrompet":"Yan\u0131t yaln\u0131zca ${address} yak\u0131nlar\u0131ndaki (koordinatlar: ${location.lat}, ${location.lng}) akci\u011fer kanseri konusunda uzman 3 klinik veya hastanenin listesini i\xe7ermelidir. Her biri i\xe7in: 1. Kurumun ad\u0131; 2. Konuma yakla\u015f\u0131k mesafe; 3. Telefon numaras\u0131; 4. Sunulan hizmetler hakk\u0131nda k\u0131sa not. Yan\u0131t\u0131 \xe7ift sat\u0131r aral\u0131\u011f\u0131 ile net bir liste format\u0131nda d\xfczenleyin."},"errors":{"invalidImage":"L\xfctfen bir resim dosyas\u0131 y\xfckleyin (JPEG veya PNG)","imageError":"Resim dosyas\u0131 okunurken hata olu\u015ftu","classificationError":"Resim s\u0131n\u0131fland\u0131r\u0131l\u0131rken hata oldu. L\xfctfen ba\u015fka bir resim deneyin.","locationDenied":"Konum eri\u015fimi reddedildi. L\xfctfen konum hizmetlerini etkinle\u015ftirin veya konumunuzu manuel girin.","locationUnavailable":"Konum kullan\u0131lam\u0131yor. L\xfctfen ba\u011flant\u0131n\u0131z\u0131 kontrol edin veya konumunuzu manuel girin.","locationTimeout":"Konum iste\u011fi zaman a\u015f\u0131m\u0131na u\u011frad\u0131. L\xfctfen tekrar deneyin veya konumunuzu manuel girin.","hospitalError":"Yak\u0131ndaki hastaneler aran\u0131rken hata olu\u015ftu."},"header":{"home":"Ana Sayfa","about":"Hakk\u0131nda","contact":"\u0130leti\u015fim"},"language":{"change":"Dili De\u011fi\u015ftir"}}}')},pt:{translation:JSON.parse('{"TheCurrentLanguage":"Portugu\xeas","home":{"title":"An\xe1lise Avan\xe7ada de Imagens M\xe9dicas","subtitle":"Ferramentas de diagn\xf3stico com IA para interpreta\xe7\xe3o precisa e r\xe1pida de imagens m\xe9dicas","chooseMethod":"Escolha o m\xe9todo de an\xe1lise","chooseSubtitle":"Selecione a modalidade de imagem que deseja analisar","ctScan":{"title":"Tomografia (TC)","description":"Avalia\xe7\xe3o detalhada de imagens seccionais com reconstru\xe7\xe3o 3D","button":"Selecionar Tomografia"},"xray":{"title":"Raio\u2011X","description":"Avalia\xe7\xe3o completa de estruturas \xf3sseas e tecidos moles","button":"Selecionar Raio\u2011X"}},"classifier":{"title":"PulmoDX IA","tagline":"An\xe1lise avan\xe7ada de c\xe2ncer de pulm\xe3o com IA | Aprendizado de m\xe1quina","uploadTitle":"Envie uma imagem pulmonar para an\xe1lise","uploadSubtitle":"Receba uma avalia\xe7\xe3o instant\xe2nea da condi\xe7\xe3o pulmonar com IA","selectImage":"Selecionar imagem","fileTypes":"Formatos suportados: JPEG, PNG","analyze":"Analisar agora","analyzing":"Analisando\u2026","results":{"title":"Resultado da an\xe1lise","confidence":"Confian\xe7a","normal":"Normal","benign":"Benigno","malignant":"Maligno","findClinics":"Encontrar a cl\xednica pneumol\xf3gica mais pr\xf3xima","findingClinics":"Buscando cl\xednicas pr\xf3ximas\u2026","locationDisclaimer":"Usaremos a localiza\xe7\xe3o do seu dispositivo para encontrar cl\xednicas pr\xf3ximas","searchingNear":"Pesquisando perto de:","recommendedClinics":"Cl\xednicas pneumol\xf3gicas recomendadas","foundNearby":"Encontrado pr\xf3ximo","refreshResults":"Atualizar resultados","ShowLocatinoPrompet":"A resposta deve incluir somente uma lista de 3 cl\xednicas ou hospitais especializados em c\xe2ncer de pulm\xe3o pr\xf3ximos a ${address} (coordenadas: ${location.lat}, ${location.lng}). Para cada um, inclua: 1. Nome da institui\xe7\xe3o; 2. Dist\xe2ncia aproximada; 3. N\xfamero de telefone; 4. Breve nota sobre os servi\xe7os oferecidos. Formate como uma lista clara, com duas quebras de linha entre cada item."},"errors":{"invalidImage":"Por favor, envie um arquivo de imagem (JPEG ou PNG)","imageError":"Erro ao ler o arquivo de imagem","classificationError":"Erro ao classificar a imagem. Por favor, tente outra imagem.","locationDenied":"Acesso \xe0 localiza\xe7\xe3o negado. Por favor, ative os servi\xe7os de localiza\xe7\xe3o ou insira manualmente seu local.","locationUnavailable":"Localiza\xe7\xe3o indispon\xedvel. Por favor, verifique sua conex\xe3o ou insira seu local manualmente.","locationTimeout":"Tempo de solicita\xe7\xe3o de localiza\xe7\xe3o esgotado. Por favor, tente novamente ou insira manualmente seu local.","hospitalError":"Erro ao encontrar hospitais pr\xf3ximos."},"header":{"home":"P\xe1gina inicial","about":"Sobre","contact":"Contato"},"language":{"change":"Mudar idioma"}}}')}};QB.use(yW).use(nB).init({resources:vW,fallbackLng:"en",interpolation:{escapeValue:!1}});const xW=QB,wW=()=>{const{t:e}=sB(),[t,n]=(0,o.useState)(!1),[a,r]=(0,o.useState)(!1),s=[{code:"en",name:"English",flag:"\ud83c\uddec\ud83c\udde7"},{code:"es",name:"Espa\xf1ol",flag:"\ud83c\uddea\ud83c\uddf8"},{code:"fr",name:"Fran\xe7ais",flag:"\ud83c\uddeb\ud83c\uddf7"},{code:"de",name:"Deutsch",flag:"\ud83c\udde9\ud83c\uddea"},{code:"ar",name:"\u0627\u0644\u0639\u0631\u0628\u064a\u0629",flag:"\ud83c\uddf8\ud83c\udde6"},{code:"cn",name:"\u4e2d\u6587",flag:"\ud83c\udde8\ud83c\uddf3"},{code:"in",name:"\u0939\u093f\u0928\u094d\u0926\u0940",flag:"\ud83c\uddee\ud83c\uddf3"},{code:"pt",name:"Portugu\xeas",flag:"\ud83c\uddf5\ud83c\uddf9"},{code:"ru",name:"\u0420\u0443\u0441\u0441\u043a\u0438\u0439",flag:"\ud83c\uddf7\ud83c\uddfa"},{code:"tr",name:"T\xfcrk\xe7e",flag:"\ud83c\uddf9\ud83c\uddf7"},{code:"id",name:"Bahasa Indonesia",flag:"\ud83c\uddee\ud83c\udde9"},{code:"it",name:"Italiano",flag:"\ud83c\uddee\ud83c\uddf9"}],i=s.find((e=>e.code===xW.language))||s[0];return(0,iB.jsxs)(iB.Fragment,{children:[(0,iB.jsx)("header",{className:"app-header",children:(0,iB.jsxs)("div",{className:"header-container",children:[(0,iB.jsx)("div",{className:"logo-container",children:(0,iB.jsx)(mt,{to:"/",className:"logo-link",children:(0,iB.jsx)("h1",{children:"PulmoDX"})})}),(0,iB.jsx)("button",{className:"mobile-menu-button",onClick:()=>r(!a),"aria-label":"Toggle menu",children:a?"\u2715":"\u2630"}),(0,iB.jsxs)("div",{className:"nav-container ".concat(a?"open":""),children:[(0,iB.jsxs)("nav",{className:"nav-links",children:[(0,iB.jsx)(mt,{to:"/",className:"nav-link",onClick:()=>r(!1),children:e("classifier.header.home")}),(0,iB.jsx)(mt,{to:"/about",className:"nav-link",onClick:()=>r(!1),children:e("classifier.header.about")}),(0,iB.jsx)(mt,{to:"/contact",className:"nav-link",onClick:()=>r(!1),children:e("classifier.header.contact")})]}),(0,iB.jsxs)("div",{className:"language-switcher ".concat(t?"open":""),children:[(0,iB.jsxs)("button",{className:"current-language",onClick:()=>n(!t),"aria-label":e("language.change"),children:[(0,iB.jsx)("span",{className:"flag",children:i.flag}),(0,iB.jsx)("span",{className:"language-name",children:i.name}),(0,iB.jsx)("span",{className:"arrow-icon",children:t?"\u25b2":"\u25bc"})]}),t&&(0,iB.jsx)("div",{className:"language-dropdown",children:s.map((e=>(0,iB.jsxs)("button",{onClick:()=>{return t=e.code,xW.changeLanguage(t),void n(!1);var t},className:"language-option ".concat(xW.language===e.code?"active":""),children:[(0,iB.jsx)("span",{className:"flag",children:e.flag}),(0,iB.jsx)("span",{className:"language-name",children:e.name})]},e.code)))})]})]})]})}),(0,iB.jsx)("div",{className:"header-spacer"})]})};const kW=function(){return(0,iB.jsxs)(ft,{children:[(0,iB.jsx)(wW,{}),(0,iB.jsxs)(_e,{children:[(0,iB.jsx)(Fe,{path:"/",element:(0,iB.jsx)(cB,{})}),(0,iB.jsx)(Fe,{path:"/ct",element:(0,iB.jsx)(lB,{})}),(0,iB.jsx)(Fe,{path:"/xray",element:(0,iB.jsx)(lB,{})})]}),(0,iB.jsx)(uB,{})]})},SW=e=>{e&&e instanceof Function&&n.e(453).then(n.bind(n,453)).then((t=>{let{getCLS:n,getFID:a,getFCP:r,getLCP:o,getTTFB:s}=t;n(e),a(e),r(e),o(e),s(e)}))};s.createRoot(document.getElementById("root")).render((0,iB.jsx)(o.StrictMode,{children:(0,iB.jsx)(kW,{})})),SW()})()})();
//# sourceMappingURL=main.47943505.js.map